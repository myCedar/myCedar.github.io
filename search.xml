<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[promise实现]]></title>
    <url>%2F2019%2F06%2F02%2Fpromise%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文主要写promise自己的实现方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198// 判断变量否为function const isFunction = variable =&gt; typeof variable === &apos;function&apos; // 定义Promise的三种状态常量 const PENDING = &apos;PENDING&apos; const FULFILLED = &apos;FULFILLED&apos; const REJECTED = &apos;REJECTED&apos; class MyPromise &#123; constructor (handle) &#123; if (!isFunction(handle)) &#123; throw new Error(&apos;MyPromise must accept a function as a parameter&apos;) &#125; // 添加状态 this._status = PENDING // 添加状态 this._value = undefined // 添加成功回调函数队列 this._fulfilledQueues = [] // 添加失败回调函数队列 this._rejectedQueues = [] // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (err) &#123; this._reject(err) &#125; &#125; // 添加resovle时执行的函数 _resolve (val) &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return this._status = FULFILLED // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; &#123; let cb; while (cb = this._fulfilledQueues.shift()) &#123; cb(value) &#125; &#125; // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; &#123; let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(error) &#125; &#125; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then(value =&gt; &#123; this._value = value runFulfilled(value) &#125;, err =&gt; &#123; this._value = err runRejected(err) &#125;) &#125; else &#123; this._value = val runFulfilled(val) &#125; &#125; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0) &#125; // 添加reject时执行的函数 _reject (err) &#123; if (this._status !== PENDING) return // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED this._value = err let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(err) &#125; &#125; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0) &#125; // 添加then方法 then (onFulfilled, onRejected) &#123; const &#123; _value, _status &#125; = this // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 let fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value) &#125; else &#123; let res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res) &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err) &#125; &#125; // 封装一个失败时执行的函数 let rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error) &#125; else &#123; let res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res) &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err) &#125; &#125; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled) this._rejectedQueues.push(rejected) break // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value) break case REJECTED: rejected(_value) break &#125; &#125;) &#125; // 添加catch方法 catch (onRejected) &#123; return this.then(undefined, onRejected) &#125; // 添加静态resolve方法 static resolve (value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value return new MyPromise(resolve =&gt; resolve(value)) &#125; // 添加静态reject方法 static reject (value) &#123; return new MyPromise((resolve ,reject) =&gt; reject(value)) &#125; // 添加静态all方法 static all (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; /** * 返回值的集合 */ let values = [] let count = 0 for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then(res =&gt; &#123; values[i] = res count++ // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values) &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err) &#125;) &#125; &#125;) &#125; // 添加静态race方法 static race (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; reject(err) &#125;) &#125; &#125;) &#125; finally (cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason &#125;) ); &#125; &#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST]]></title>
    <url>%2F2019%2F06%2F02%2FAST%2F</url>
    <content type="text"><![CDATA[本文主要讲一种js语法树 ASTAST有很多解析的JS 如：Babylon、esprima、acorn、UglifyJS2、AST explorer。在这个网址可以看到解析结果 解析结果下方的的js123var a = 42;var b = 5;var c = a + b; 展示结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&#123; "type": "Program", "start": 0, "end": 37, "body": [ &#123; "type": "VariableDeclaration", "start": 0, "end": 11, "declarations": [ &#123; "type": "VariableDeclarator", "start": 4, "end": 10, "id": &#123; "type": "Identifier", "start": 4, "end": 5, "name": "a" &#125;, "init": &#123; "type": "Literal", "start": 8, "end": 10, "value": 42, "raw": "42" &#125; &#125; ], "kind": "var" &#125;, &#123; "type": "VariableDeclaration", "start": 12, "end": 22, "declarations": [ &#123; "type": "VariableDeclarator", "start": 16, "end": 21, "id": &#123; "type": "Identifier", "start": 16, "end": 17, "name": "b" &#125;, "init": &#123; "type": "Literal", "start": 20, "end": 21, "value": 5, "raw": "5" &#125; &#125; ], "kind": "var" &#125;, &#123; "type": "VariableDeclaration", "start": 23, "end": 37, "declarations": [ &#123; "type": "VariableDeclarator", "start": 27, "end": 36, "id": &#123; "type": "Identifier", "start": 27, "end": 28, "name": "c" &#125;, "init": &#123; "type": "BinaryExpression", "start": 31, "end": 36, "left": &#123; "type": "Identifier", "start": 31, "end": 32, "name": "a" &#125;, "operator": "+", "right": &#123; "type": "Identifier", "start": 35, "end": 36, "name": "b" &#125; &#125; &#125; ], "kind": "var" &#125; ],&#125; 使用方法esprima estraverse escodegen babel esprima 解析 JS 生成 AST123456789101112131415161718192021const esprima = require('esprima');let code = 'function fn() &#123;&#125;';// 结果let tree = esprima.parseScript(code);console.log(tree);// Script &#123;// type: 'Program',// body:// [ FunctionDeclaration &#123;// type: 'FunctionDeclaration',// id: [Identifier],// params: [],// body: [BlockStatement],// generator: false,// expression: false,// async: false &#125; ],// sourceType: 'script' &#125; estraverse 遍历 AST1234567891011121314151617181920212223const esprima = require('esprima');const estraverse = require('estraverse');let code = 'function fn() &#123;&#125;';// 遍历路径estraverse.traverse(esprima.parseScript(code), &#123; enter(node) &#123; console.log('enter', node.type); &#125;, leave() &#123; console.log('leave', node.type); &#125;&#125;);// enter Program// enter FunctionDeclaration// enter Identifier// leave Identifier// enter BlockStatement// leave BlockStatement// leave FunctionDeclaration// leave Program escodegen 将AST重新生成为源码：1234567891011121314151617181920212223242526const esprima = require('esprima');const estraverse = require('estraverse');const escodegen = require('escodegen');let code = 'function fn() &#123;&#125;';// 解析let tree = esprima.parseScript(code);// 遍历estraverse.traverse(tree, &#123; enter(node) &#123; // 判断类型，改变函数名称 if (node.type === 'FunctionDeclaration') &#123; node.id.name = 'ast'; &#125; &#125;&#125;);// 重新生成JS源码let result = escodegen.generate(tree);console.log(result);// function ast() &#123;// &#125; AST三板斧： 通过 esprima 把源码转化为AST 通过 estraverse 遍历并更新AST 通过 escodegen 将AST重新生成源码 UglifyJS2进行代码混淆压缩]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QRCode]]></title>
    <url>%2F2019%2F06%2F02%2FQRCODE%20%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[QRCode.js 是一个用于生成二维码的 JavaScript 库。主要是通过获取 DOM 的标签,再通过 HTML5 Canvas 绘制而成,不依赖任何库QRCode.js ：https://www.jianshu.com/p/b53eae520de4 案例12345678910111213&lt;div id='qrcode'&gt;&lt;/div&gt;&lt;button onclick='createQrcode();'&gt;生成二维码&lt;button&gt;var qrcode = new QRCode('qrcode', &#123; width: 150, height: 150,&#125;)qrcode.clear();function createQrcode()&#123; qrcode.clear(); var QRCodeStr = "https://www.baidu.com" qrcode.makeCode(QRCodeStr);&#125; 小程序里面生成二维码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;view&gt; &lt;!-- 存放二维码的图片--&gt; &lt;view class='container'&gt; &lt;image style='width:310rpx;height:310rpx;margin-top:30rpx;' src="&#123;&#123;imagePath&#125;&#125;"&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 画布，用来画二维码，只用来站位，不用来显示 --&gt; &lt;view class="canvas-box"&gt; &lt;canvas hidden="&#123;&#123;canvasHidden&#125;&#125;" style="width: 170px;height: 170px;background:#f1f1f1;" canvas-id="mycanvas" /&gt; &lt;/view&gt;&lt;/view&gt;//小程序js的配置var QR = require("../../utils/qrcode.js");/*** 页面的初始数据*/data: &#123; canvasHidden: false, //默认不让canvas二维码隐藏，否则不能生成二维码 imagePath: "" //弹出框二维码显示图片地址&#125;,/*** 生命周期函数--监听页面加载*/onLoad: function(options) &#123; var that = this; var initUrl = 'https://www.baidu.com?id='+id; //创建二维码 that.createQrCode(initUrl, "mycanvas", 170, 170);&#125;/*** 绘制二维码图片*/createQrCode: function(url, canvasId, cavW, cavH) &#123; //调用插件中的draw方法，绘制二维码图片 QR.api.draw(url, canvasId, cavW, cavH); setTimeout(() =&gt; &#123; this.canvasToTempImage(); &#125;, 500); &#125;,/*** 获取临时缓存照片路径，存入data中*/canvasToTempImage: function() &#123; var that = this; //把当前画布指定区域的内容导出生成指定大小的图片，并返回文件路径。 wx.canvasToTempFilePath(&#123; canvasId: 'mycanvas', success: function(res) &#123; var tempFilePath = res.tempFilePath; that.setData(&#123; imagePath: tempFilePath, // canvasHidden:true &#125;); &#125;, fail: function(res) &#123; console.log(res); &#125; &#125;);&#125;,]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tapable]]></title>
    <url>%2F2019%2F06%2F02%2Ftapable%2F</url>
    <content type="text"><![CDATA[本文主要讲webpack核心工作流 tapable的一些用法 apply 方法12345Tapable.prototype.apply = function apply() &#123; for(var i = 0; i &lt; arguments.length; i++) &#123; arguments[i].apply(this); &#125;&#125;; 毫无悬念，就是 挨个顺序 执行传入到该函数方法中对象的 apply 方法；通常传入该函数的对象也是 Tapable 插件 对象，因此必然也存在 apply 方法；（Webpack 的插件就是Tapable对象，因此必须要提供 apply 方法 ） 只是更改上下文为当前 this 因此当前这里最大的作用就是传入当前 Tapable 的上下文 tap注册函数 call触发同步方法 SyncHock依次执行所有的注册函数 syncBailHock依次执行所有的注册函数，但是可以判断当返回undefined 停止执行 syncWaterfallHock依次执行所有的注册函数，前一个函数的返回值为后一个的参数 syncLoopHock循环执行注册函数 只有返回undefined 才会继续向下执行 tapAsync注册异步方法 多一个参数回调函数 callAsync触发异步方法 tapPromise注册一个promise函数，返回一个promise对象 promise最后执行注册函数 promise.then()来进行所有完成后的回调 AsyncParallelHook并发执行当所有的注册函数执行完毕 执行最后的方法 比同步多一个回调函数 AsyncParallelBailHook并发执行当所有的注册函数执行完毕 执行最后的方法 比同步多一个回调函数 如果出错了 将不再执行]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE-G]]></title>
    <url>%2F2019%2F06%2F02%2Fvueg%2F</url>
    <content type="text"><![CDATA[本章会介绍 vue-g的用法参考网址为vue-router添加转场效果，只需要Vue.use(vueg)，即可获得转场效果，并能够根据url级别(/)和历史记录判断是前进和后退。 使用方法 / Usage安装 / Installationnpm i vueg -G引入插件12345678import Vue from 'vue' import App from './App' import router from './router'// ↓↓↓↓↓↓↓↓↓↓↓↓import vueg from 'vueg' import 'vueg/css/transition-min.css'Vue.use(vueg, router) //←注意这一句应该在router实例化(router = new VueRouter(&#123;&#125;)之后 禁用动画123456// &lt;router-view&gt;上添加v-transition="false"，可以禁用动画&lt;template&gt; &lt;div id="app"&gt; &lt;router-view v-transition="false"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 配置项 / Config12345678910111213141516const options=&#123; duration: '0.3', //转场动画时长，默认为0.3，单位秒 firstEntryDisable: false, //值为true时禁用首次进入应用时的渐现动画，默认为false firstEntryDuration: '.6', //首次进入应用时的渐现动画时长，默认为.6 forwardAnim: 'fadeInRight', //前进动画，默认为fadeInRight backAnim: 'fadeInLeft', //后退动画，默认为fedeInLeft sameDepthDisable: false, //url深度相同时禁用动画，默认为false tabs: [&#123; name:'home' &#125;,&#123; name:'my' &#125;], //默认为[]，name对应路由的name,以实现类似app中点击tab页面水平转场效果，如tab[1]到tab[0]，会使用backAnim动画，tab[1]到tab[2]，会使用forwardAnim动画 tabsDisable: false, //值为true时，tabs间的转场没有动画，默认为false disable: false, //禁用转场动画，默认为false，嵌套路由默认为true &#125; Vue.use(vueg, router,options) 全部的动画效果见这里组件中配置12345678data()&#123; return &#123; vuegConfig:&#123; forwardAnim:'bounceInUp',//options所有配置可以写在这个对象里，会覆盖全局的配置 disable:false //对于嵌套路由，默认为关闭动画，需要在组件的data.vuegConfig中配置disable为false启用 &#125; &#125;&#125; 注意点 基于vue v2.3.4版本开发、调试 非新项目使用这个插件后，因为css问题，可能造成原本元素在转场动画时有些地方排版错乱，那就需要调整css； 每个路由匹配的组件模板高度最好大于等于屏幕高度，否则转场不好看，可以为 添加class，设置min-height:100%; 插件60Kb左右大小，其中css 57Kb，如果想减小，可以编辑vueg/css/transition-min.css ，将不需要的动画样式删除；]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE懒加载]]></title>
    <url>%2F2019%2F06%2F02%2Fvue%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[本章会介绍 vue如何进行懒加载 什么是懒加载懒加载也叫延迟加载，即在需要的时候进行加载，随用随载。 如何与webpack配合实现组件懒加载 在webpack配置文件中的output路径配置chunkFilename属性123456output: &#123; path: resolve(__dirname, 'dist'), filename: options.dev ? '[name].js' : '[name].js?[chunkhash]', chunkFilename: 'chunk[id].js?[chunkhash]', publicPath: options.dev ? '/assets/' : publicPath&#125;, chunkFilename路径将会作为组件懒加载的路径 配合webpack支持的异步加载方法 resolve =&gt; require([URL], resolve), 支持性好 () =&gt; import(URL), webpack2官网推荐使用, 属于es7范畴, 需要配合babel的syntax-dynamic-import插件使用, 具体使用方法如下npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es20151234567use: [&#123; loader: 'babel-loader', options: &#123; presets: [['es2015', &#123;modules: false&#125;]], plugins: ['syntax-dynamic-import'] &#125; &#125;] 具体实例中实现懒加载 路由中配置异步组件 12345678910export default new Router(&#123; routes: [ &#123; mode: 'history', path: '/my', name: 'my', component: resolve =&gt; require(['../page/my/my.vue'], resolve),//懒加载 &#125;, ]&#125;) 实例中配置异步组件 1234components: &#123; historyTab: resolve =&gt; &#123;require(['../../component/historyTab/historyTab.vue'], resolve)&#125;,//懒加载 //historyTab: () =&gt; import('../../component/historyTab/historyTab.vue') &#125;, 全局注册异步组件 123Vue.component('mideaHeader', () =&gt; &#123; System.import('./component/header/header.vue')&#125;) 避免问题同时使用懒加载和正常引入1234567891011import historyTab from '../../component/historyTab/historyTab.vue';export default &#123; components: &#123; historyTab &#125;,&#125;export default &#123; components: &#123; historyTab: resolve =&gt; &#123;require(['../../component/historyTab/historyTab.vue'], resolve)&#125;,//懒加载 &#125;,&#125; 异步加载页面中载嵌入异步加载的组件因为在首次加载组件的时候会有加载时间，出现页面滞后，所以需要合理的进行页面结构设计，避免首次出现跳闪现象； 建议最终实现方案 路由页面全都使用懒加载 路由页面中的组件何磊安排 当一个页面中嵌套多个组件时将发送多次的http请求，可能会造成网页显示过慢且渲染参差不齐的问题，所以针对这种特殊情况需要合理安排 结合vuex 动态路由加载页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); export default new Vuex.Store(&#123; state: &#123; //路由组件存储器 routers: &#123;&#125; &#125;, getters: &#123; routers: state =&gt; &#123; return state.data; &#125; &#125;, mutations: &#123; //动态增加路由 addRouter: (state, data) =&gt; &#123; state.routers = Object.assign(&#123;&#125;, state.routers, &#123;[data.name]: data.component&#125;);&#125; &#125;, actions: &#123; acMethods(&#123;commit&#125;) &#123; &#125; &#125;,&#125;)//根目录中注册路由组件window.midea = &#123; registerRouter(name, component) &#123; Store.commit('addRouter', &#123; name: name, component: component &#125;) &#125;&#125;;//页面使用路由导航openAnyPage() &#123; midea.registerRouter('module', resolve =&gt; &#123;require(['../module/module.vue'], resolve)&#125;);//懒加载 this.$router.push(&#123;path: '/home/module', query: &#123;title: this.title&#125;&#125;);&#125;//页面中使用动态组件 &lt;template&gt;&lt;component :is="currentRouter" :moduleName="title"&gt;&lt;/component&gt; &lt;/template&gt;&lt;br&gt;&lt;script src="./any.js"&gt;export default &#123; data () &#123; return &#123; routeName: '', currentRouter: '', title: '', &#125; &#125;, created() &#123; this.routeName = this.$route.params.name; this.title = this.$route.query.title; this.currentRouter = this.$store.state.routers[this.routeName]; &#125;, methods: &#123; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFF]]></title>
    <url>%2F2019%2F06%2F02%2FBFF%2F</url>
    <content type="text"><![CDATA[本文主要讲一种前端设计思想参照这个网站 什么是BFFBFF，即 Backend For Frontend（服务于前端的后端），也就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理，又称为用户体验适配器。 什么时候用BFF 多端运用 我们在设计 API 时会考虑到不同设备的需求，也就是为不同的设备提供不同的 API，虽然它们可能是实现相同的功能，但因为不同设备的特殊性，它们对服务端的 API 访问也各有其特点，需要区别处理。 服务聚合 随着微服务的兴起，原本在同一个进程内运行的业务流程被拆分到了不同的服务中。这在增加业务灵活性的同时，也让前端的调用变得更复杂。BFF 的出现为前端应用提供了一个对业务服务调用的聚合点，它屏蔽了复杂的服务调用链，让前端可以聚焦在所需要的数据上，而不用关注底层提供这些数据的服务。 非必要，莫新增 我们在看到 BFF 带来的各种好处的同时，也要注意到它所带来的代码重复和工作量增加方面的问题。如果与已有 BFF 功能类似，且展现数据的要求也相近的话，一定要谨慎对待新增 BFF 的行为。因此，建议非必要，莫新增。 用法 访问控制 例如，服务中的权限控制，将所有服务中的权限控制集中在 BFF 层，使下层服务更加纯粹和独立。 应用缓存 项目中时常存在一些需要缓存的临时数据，此时 BFF 作为业务的汇聚点，距离用户请求最近，遂将该缓存操作放在 BFF 层。 第三方入口 在业务中需要与第三交互时，将该交互放在 BFF 层，这样可以只暴露必要信息给第三方，从而便于控制第三方的访问。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 闭包实现构造函数var Book=(function(){ //静态私有变量 var bookNum=100; //静态私有方法 function checkBook(name){} //创建类 function _book(newId, newName, newPrice){ //私有变量 //var name,price; //私有方法 function checkId(id){} //特权方法 this.getName=function(){} this.getPrice=function(){} this.setName=function(){} this.setPrice=function(){} //公有属性 this.id=newId; //公有方法 this.copy=function(){}; bookNum++; if(bookNum&gt;100) throw new Error(&quot;只有100本书可以被创建&quot;) //构造器 this.setName(name); this.setPrice(price); } //构建原型 _book.prototype = { //静态公有变量 isJsBook : false, //静态公有方法 display : function(){} }; //返回类 return _book; })() 安全模式12345678910//构造函数，防止未new直接var mybook = Book();var Book=function(title,time,type)&#123; if(this instanceof Book)&#123; this.title = title; this.time = time; this.type = type; &#125;else&#123; return new Book(title,time,type); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 实现迭代器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//迭代器var Iterator = function(items)&#123; //获取长度，下标 var length = items.length, index = 0, splice = [].splice; return &#123; //第一个元素 first : function()&#123; index = 0; return items[index]; &#125;, //最后一个元素 last : function()&#123; index = length-1; return items[index]; &#125;, //前一个元素 pre : function()&#123; if(--index &gt; 0)&#123; return items[index] &#125;else&#123; index = 0; return null; &#125; &#125;, //下一个元素 next : function()&#123; if(++index &lt; length)&#123; return items[index] &#125;else&#123; index = length-1; return null; &#125; &#125;, //获取某一个 num 的元素 get : function(num)&#123; index = num&gt;=0 ? num % length : num % length + length; return items[index]; &#125;, //进行 fn 的全量处理 dealEach : function(fn)&#123; var args = splice.call(arguments,1); for(var i=0;i&lt;length;i++)&#123; fn.apply(items[i],args); &#125; &#125;, //对某一个 num 的元素进行 fn 的处理 dealItem : function(num,fn)&#123; fn.apply(this.get(num),splice.call(arguments,2)) &#125;, //对 mem 中的元素 进行 numFn 的处理 allFn 针对所有的处理 exclusive : function(mem,allFn,numFn)&#123; this.dealEach(allFn); if(Array.isArray(mem))&#123; for(var i=0;i&lt;mem.length;i++)&#123; this.dealItem(mem[i],numFn) &#125; &#125;else&#123; this.dealItem(mem,numFn) &#125; &#125; &#125;&#125; 数组迭代器123456789var eachArray = function(arr,fn)&#123; var i = 0, len = arr.length; for(;i &lt; len;i++)&#123; if(fn.call(arr[i],i,arr[i]) === false)&#123; break; &#125; &#125;&#125; 对象迭代器1234567var eachObj = function(obj,fn)&#123; for(var i in obj)&#123; if(fn.call(obj[i],i,obj[i]) === false)&#123; break; &#125; &#125;&#125; 分支循环嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 绘制特效图片*param t 类型*param x x坐标*param y y坐标*param w 宽度*param h 高度*param a 透明度*/function dealImage(t,x,y,w,h,a)&#123; var canvasData = ctx.getImageData(x,y,w,h), data = canvasData.data, //封装算法 Deal = function ()&#123; var method = &#123; default : function(i)&#123; return method["gray"](i) &#125;, red : function()&#123; data[i + 1] = 0; data[i + 2] = 0; data[i + 3] = a; &#125;, green : function()&#123; data[i + 0] = 0; data[i + 2] = 0; data[i + 3] = a; &#125; blue : function()&#123; data[i + 1] = 0; data[i + 0] = 0; data[i + 3] = a; &#125;, grey : function()&#123; data[i] = data[i + 1]=parseInt(data[i + 2] = (data[i + 0] + data[i + 1] +data[i + 2])/3); data[i + 3] = a; &#125; &#125; return function(type)&#123; return method[type] || method["default"] &#125; &#125;(); //迭代器处理数据 function eachData(fn)&#123; for(var i = 0,len = data.length;i &lt; len;i += 4)&#123; fn(i); &#125; &#125;; //处理数据 eachData(Deal(t)); ctx.putImageData(canvasData,width+x,y);&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%A7%82%E5%AF%9F%E8%80%85%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 创建一个观察者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var Observer=(function()&#123; //建立闭包保存消息 var _messages=&#123;&#125;; return&#123; //注册接口 regist : function(type,fn)&#123; //如果不存在这个消息类型，创建一个，否则推入对应的执行队列中去 if(typeof _messages[type] === "undefined")&#123; //将消息推入动作执行队列中 _messages[type] = [fn]; &#125;else&#123; //将消息推入动作执行队列中 _messages[type].push(fn); &#125; &#125; , //发布信息接口 fire : function(type,args)&#123; //如果不存在，直接退出 if(!_messages[type]) return; //定义消息的信息及参数 var events = &#123; type:type,//消息类型 args :args || &#123;&#125;//消息参数 &#125;,i = 0,len = _messages[type].length; //便利消息队列 for(;i&lt; len;i++)&#123; //依次执行对应的动作 _messages[type][i].call(this,events) &#125; &#125;, //移出信息接口 remove : function(type,fn)&#123; debugger; //判断消息队列存在 if(_messages[type] instanceof Array)&#123; //遍历消息队列 var i = _messages[type].length - 1; for(;i&gt;=0;i--)&#123; //移除相应的动作函数 _messages[type][i] === fn &amp;&amp; _messages[type].splice(i,1); &#125; &#125; &#125;, getMessages:function()&#123; return _messages; &#125; &#125;&#125;)() 对象间解耦1234567891011121314151617181920212223242526272829303132333435363738//学生类var Student = function(result)&#123; var that=this; //回答结果； that.result = result; //回答问题 that.say = function()&#123; console.log(that.result) &#125;&#125;//回答问题的方法Student.prototype.answer = function(quertion)&#123; Observer.regist(quertion,this.say)&#125;//增加睡觉的方法Student.prototype.sleep = function(quertion)&#123; //解除说话的队列 Observer.remove(quertion,this.say)&#125;//教师类var Teacher = function()&#123;&#125;//发布问题Teacher.prototype.ask = function(question)&#123; Observer.fire(question)&#125;var student1 = new Student("11");var student2 = new Student("22");var student3 = new Student("33");student1.answer("who")student2.answer("who")student3.answer("who")student1.answer("where")student2.answer("where")var teacher = new Teacher();teacher.ask("who")teacher.ask("where")]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[订阅者模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 中介者对象1234567891011121314151617181920212223//订阅者var Mediator = function()&#123; //内部存储 var _msg = &#123;&#125;; return &#123; //注册消息 register : function(type,action)&#123; if(_msg[type])&#123; _msg[type].push(action) &#125;else&#123; _msg[type]=[action] &#125; &#125;, //发布消息 send : function(type)&#123; if(_msg[type])&#123; for(var i=0;i&lt;_msg[type].length;i++)&#123; _msg[type][i]&amp;&amp;_msg[type][i](); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//新建玛丽的类var MarryState = function()&#123; //内部私有变量 var _currentState = &#123;&#125;, //状态和方法的映射 states = &#123; jump : function()&#123; //跳 console.log("jump") &#125;, move : function()&#123; //移动 console.log("move") &#125;, shoot : function()&#123; //射击 console.log("shoot") &#125;, squat : function()&#123; //蹲下 console.log("squat") &#125; &#125;, //动作控制类 Action = &#123; //改变状态方法 changeState : function()&#123; var arg = arguments; //重置动作 _currentState = &#123;&#125;; //追加动作 if(arg.length)&#123; for(var i = 0,len = arg.length;i&lt;len;i++)&#123; _currentState[arg[i]] = true; &#125; &#125; return this; &#125;, //执行动作 goes : function()&#123; //遍历执行动作 for(var i in _currentState)&#123; states[i] &amp;&amp; states[i](); &#125; return this; &#125; &#125;; //返回动作类 return &#123; change : Action.changeState, goes : Action.goes &#125;&#125; 使用方法12345678910//new marry个人var marry = new MarryState();//方法的调用marry .change("jump","shoot") .goes() .change("move","shoot") .goes() .change("squat","shoot") .goes();]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 策略算法12345678910111213141516171819202122232425262728//表单验证对象var InputStrategy = function()&#123; var strategy=&#123; //是否为空 notNull : function(value)&#123; return /\s+/.test(value)?"":"请输入内容" &#125;, //是否为数字 number : function(value)&#123; return /^[0-9]+(\.[0-9]+)?$/.test(value)?"":"请输入数字" &#125;, //是否是手机号 phone : function(value)&#123; return /^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d&#123;8&#125;$/.test(value)?"":"请输入正确的电话" &#125; &#125; return &#123; //验证 check : function(type,value)&#123; value = typeof value === "string" ? value.trim() : value; return strategy[type] ? strategy[type](value):"没有该类型"; &#125;, //添加验证类型 addStrategy :function(type,fn)&#123; strategy[type] = fn &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建本地运行环境]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[如何利用http-serve搭建环境 利用http-serverhttp http-server全局安装http-servernpm install http-server -g使用httphttp-server [path] [options]具体含义123456789101112131415161718192021222324252627282930313233-p 要使用的端口（默认为8080）-a 要使用的地址（默认为0.0.0.0）-d 显示目录列表（默认为“True”）-i 显示autoIndex（默认为“True”）-g或--gzip启用时（默认为“False”），它将用于./public/some-file.js.gz代替./public/some-file.jsgzip压缩版本的文件，并且该请求接受gzip编码。-e或--ext默认文件扩展名（如果没有提供）（默认为&apos;html&apos;）-s或--silent从输出中抑制日志消息--cors通过Access-Control-Allow-Origin标题启用CORS-o 启动服务器后打开浏览器窗口-c设置缓存控制max-age头的缓存时间（以秒为单位），例如-c10 10秒（默认为&apos;3600&apos;）。要禁用缓存，请使用-c-1。-U或--utc在日志消息中使用UTC时间格式。-P或--proxy代理无法在本地解决给定网址的所有请求。例如：-P http://someurl.com-S或--ssl启用https。-C或--certssl证书文件的路径（默认值：cert.pem）。-K或--keyssl密钥文件的路径（默认值：key.pem）。-r或者--robots提供一个/robots.txt（其内容默认为&apos;User-agent：* \ nDisallow：/&apos;）-h或--help打印此列表并退出。 使用httpsopenssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem http-server -S -C cert.pem -o 安装XAMPP利用xampp搭建本地服务第一步：安装第二部：找到 C:\xampp\htdocs 将文件放置在次目录下第三部：启动 config 可以对端口号进行配置]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据管理器]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 定义类1234567891011/**本地存储类*参数 preId 本地存储数据库前缀*参数 timeSign 定义时间戳与存储数据之间的拼接符*/var BaseLocalStorage = function(preId,timeSign)&#123; //定义本地存储数据库前缀 this.preId = preId; //定义时间戳与存储数据之间的拼接符 this.timeSign = timeSign || '|-|'&#125; 定义方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114BaseLocalStorage.prototype = &#123; //状态 status : &#123; SUCCESS : 0,//成功 FAILURE : 1.//失败 OVERFLOW : 2,//溢出 TIMEOUT : 3//过期 &#125;, //window的本地存储 storage : localStorage || window.localStrorage, //获取当前的key getKey : function(key)&#123; return this.preId + key; &#125;, //设置数据 set : function(key,value,callback,time)&#123; //默认成功 var status = this.status.SUCCESS, //获得key值 key = this.getKey(key); try&#123; //获取时间戳 time = new Date(time).getTime() || time.getTime(); &#125;catch(e)&#123; //如果没有获取到，默认一个月 time = new Date(time).getTime() + 1000 * 60 * 60 * 24 * 31; &#125; try&#123; //设置 this.storage.setItem(key , time + this.timeSign + value); &#125;catch(e)&#123; //如果失败了，溢出了 status = this.syatus.OVERFLOW &#125; //执行回调函数 callback &amp;&amp; callback.call(this, status ,key ,value) &#125;, //获取数据 get : function(key,callback)&#123; //默认成功，设置key var status = this.status.SUCCESS, key = this.getKey(key), value = null, timeSignLen = this.timeSign.length, that = this, index, result; //尝试获取值 try&#123; value = that.stirage.getItem(key); &#125;catch(e)&#123; //如果没有获取到 result = &#123; //定义失败。 status : that.status.FAILURE, value : null &#125; //执行回调函数 callback &amp;&amp; callback.call(this, result.status ,result.value); //返回失败 return result; &#125; //拿到数据 if(value)&#123; //获取时间标记下标值 index = value.indexOf(that.timeSign); //获取时间 time = +value.slice(0,index); //比较时间是否过期 if(new Date(time).getTime() &gt; new Date().getTime() || 0)&#123; //没有过期获取真的value value = value.slice(index + timeSignLen); &#125;else&#123; //过期了，设置过期，并移除原来的数据 value = null, status = that.status.TIMEOUT; that.remove(key); &#125; &#125;else&#123; //获取失败 status = that.status.FAILURE; &#125; //定义结果 result = &#123; status : status, value : value &#125;; //执行回掉函数并返回值 callback &amp;&amp; callback.call(this, result.status ,result.value); return result; &#125;, //移除数据 remove : function(key,callback)&#123; //定义初始失败，并获取key var status = this.status.FAILURE, key = this.getKey(key), value = null; //尝试获取值 try&#123; //得到值了 value = that.stirage.getItem(key); &#125;catch(e)&#123;&#125; //如果获取到了值 if(value)&#123; try&#123; //移除值，并设置成功 this.storage.removeItem(key); status = this.status.SUCCESS; &#125;catch(e)&#123;&#125; &#125; //执行回掉函数 callback &amp;&amp; callback.call(this, status ,status &gt; 0 ? null : value.slice(value.indexOf(this.timeSign) + this.timeSign.length)); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 以canvas为例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//定义构造函数var CanvasCommand = function(domId)&#123; //获取当前id的dom var canvas = document.getElementById(domId), ctx = canvas.getContext("2d"), //定义一些方法 Action = &#123; //填充色 fillStyle : function(c)&#123; ctx.fillStyle = c; &#125;, //填充方块 fillRect : function(x,y,width,height)&#123; ctx.fillRect(x,y,width,height) &#125;, //描边色 strokeStyle : function(c)&#123; ctx.strokeStyle(c); &#125;, //描边方块 strokeRect : function(x,y,width,height)&#123; ctx.strokeRect(x,y,width,height); &#125;, //画文字 fillText : function(text,x,y)&#123; ctx.fillText(text,x,y) &#125;, //开始路径 beginPath : function()&#123; ctx.beginPath() &#125;, //移动到 moveTo : function(x,y)&#123; ctx.moveTo(x,y) &#125;, //画直线 lineTo : function(x,y)&#123; ctx.lineTo(x,y) &#125;, //画孤线 arc : function(x,y,r,begin,end,dir)&#123; ctx.arc(x,y,r,begin,end,dir) &#125;, //填充 fill : function()&#123; ctx.fill() &#125;, //描边 stroke : function()&#123; ctx.stroke() &#125;, &#125;; return &#123; //返回的方法 excute : function(msg)&#123; //没有指令 if(!msg) return; //多个指令，逐个遍历 if(msg.length)&#123; for(var i = 0;i&lt;msg.length;i++)&#123; arguments.callee(msg[i]); &#125; &#125;else&#123; msg.param = Object.prototype.toString.call(msg.param) === "[object Array]" ? msg.param : [msg.param]; Action[msg.command].apply(Action,msg.param); &#125; &#125; &#125;&#125; 使用方法1234567//初始化domIdvar mycanvas = new CanvasCommand("domId");//使用命令画图mycanvas.excute([ &#123;command : 'fillStyle',param : "red"&#125;, &#123;command : 'fillRect',param : [20,20,100,100]&#125;])]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[惰性模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%83%B0%E6%80%A7%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 事件绑定方法一 加载的时候重新定义 on方法12345678910111213141516171819//对事件绑定的重新定义A.on = function(dom, type,fn)&#123; //不是ie的情况下 if(document.addEventListenter)&#123; return function(dom, type,fn)&#123; dom.addEventListenter(type,fn,false); &#125; &#125;else if(document.attachEvent)&#123; //IE的情况下 return function(dom, type,fn)&#123; dom.attachEvent("on" + type,fn); &#125; &#125;else&#123; //否则 return function(dom, type,fn)&#123; dom.attachEvent("on" + type) = fn; &#125; &#125;&#125;(); 方法二 执行的时候定义方法123456789101112131415161718192021//对事件绑定的重新定义A.on = function(dom, type,fn)&#123; //不是ie的情况下 if(document.addEventListenter)&#123; A.on = function(dom, type,fn)&#123; dom.addEventListenter(type,fn,false); &#125; &#125;else if(document.attachEvent)&#123; //IE的情况下 A.on = function(dom, type,fn)&#123; dom.attachEvent("on" + type,fn); &#125; &#125;else&#123; //否则 A.on = function(dom, type,fn)&#123; dom.attachEvent("on" + type) = fn; &#125; &#125; //定义后重新执行方法 A.on(dom, type,fn);&#125;();]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节流模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%8A%82%E6%B5%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 节流函数12345678910111213141516171819202122232425262728293031//节流器var throttle = function()&#123; //获取第一个参数 var isClear = arguments[0],fn; //如果第一个参数是boolean类型，那么第一个参数则表示是否清楚计时器 if(typeof isClear === 'boolean')&#123; //第二个参数则为函数 fn = arguments[1]; //函数计时器句柄存在，则清楚函数计时器 fn._throttleID &amp;&amp; clearTimeout(fn._throttleID); //通过计时器延迟函数的执行 &#125;else&#123; //第一个参数为函数 fn = isClear; //第二个参数为函数执行时的参数 param = arguments[1]; //对执行时的参数适配默认值，这里我们用到以前学过的extend方法 var p = extend(&#123; context:null, args:[], time:300 &#125;,param); //清楚函数执行计时器句柄， arguments.callee(true,fn); //作为函数绑定延迟计时器句柄，延迟执行函数 fn._throttleID = setTimeout(function()&#123; //执行函数 fn.apply(p.context,p.args); &#125;,p.time); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 列表缓存123456789101112131415161718192021//列表var Page = function()&#123; //定义缓存 var cache=&#123;&#125;; return function(page,fn)&#123; //命中缓存 if(cache[page])&#123; showPage(page,cacge[page]); fn&amp;&amp;fn(); &#125;else&#123; //对请求回来的数据进行缓存 $.post("",&#123;&#125;,function(res)&#123; if(res)&#123; showPage(page,res.data); cache[page]=res.data; fn&amp;&amp;fn() &#125; &#125;) &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F06%2F01%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 类式继承123456789101112131415161718//声明父类function SuperClass()&#123; this.superVal = true&#125;//为父类添加方法SuperClass.prototype.getSuperVal = function()&#123; return this.superVal&#125;//声明子类function SubClass()&#123; this.subVal=false&#125;//继承父类SubClass.prototype=new SuperClass();//添加子类方法SubClass.prototype.getSubVal = function()&#123; return this.subVal&#125; 构造函数继承12345678910111213141516171819//声明父类function SuperClass(id)&#123; //值类型共有属性 this.id=id; //引用类型共有属性 this.books=["java","css"]&#125;//父类型声明原型方法SuperClass.prototype.showBooks = function()&#123; console.log(this.books)&#125;//声明子类function SubClass(id)&#123; //继承父类 SuperClass.call(this,id)&#125;//创建子类实例var instance1 = new SubClass(10);var instance2 = new SubClass(11); 组合继承12345678910111213141516171819202122232425262728//声明父类function SuperClass(id)&#123; //值类型共有属性 this.id=id; //引用类型共有属性 this.books=["java","css"]&#125;//父类型声明原型方法SuperClass.prototype.showBooks = function()&#123; console.log(this.books)&#125;//声明子类function SubClass(id,time)&#123; //继承父类 SuperClass.call(this,id) //新增共有属性 this.time=time&#125;//类式继承SubClass.prototype = new SuperClass();//子类原型方法SubClass.prototype.getTime = function()&#123; console.log(this.time)&#125;//创建子类实例var instance1 = new SubClass(10,"2017");var instance2 = new SubClass(11,"2018"); 寄生组合式继承复制一个对象的prototype Object.create(o.prototype) function object(o){ function F(){} F.prototype = o; return new F(); } 寄生组合12345678function inheritPrototype(subType,superType)&#123; //object()方法是ES5前Object.create()的非规范化实现 var prototype=object(superType.prototype); //增强对象 prototype.constructor = subType; //指定对象 subType.prototype = prototype;&#125; 使用123456789101112131415161718192021222324//声明父类function SuperClass(id)&#123; //值类型共有属性 this.id=id; //引用类型共有属性 this.books=["java","css"]&#125;//父类型声明原型方法SuperClass.prototype.showBooks = function()&#123; console.log(this.books)&#125;//声明子类function SubClass(id,time)&#123; //继承父类 SuperClass.call(this,id) //新增共有属性 this.time=time&#125;//继承inheritPrototype(SubClass,SuperClass)'//子类增加原型方法SubClass.prototype.getTime = function()&#123; console.log(this.time);&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学react]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%88%9D%E5%AD%A6react%2F</url>
    <content type="text"><![CDATA[react初步学习react+react-router+redux+fetch+babel+webpack这篇文章写得很好 react脚手架123456789101112// 安装脚手架npm install -g create-react-app// 创建自己的项目create-react-app my-app// 进入项目cd my-app// 启动项目npm start// 展开webpack配置文件，进行相关的打包优化及配置yarn eject// script文件夹中进行打包的配置// 在config中是关于webpack的配置 yarn 包工具yarn config set registry 你的npm仓库 react 生命周期getDefaultProps设置默认的props，也可以用dufaultProps设置组件的默认属性. getInitialState在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props componentWillMount组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 renderreact最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 componentDidMount组件渲染之后调用，只调用一次。 componentWillReceiveProps(nextProps)组件初始化时不调用，组件接受新的props时调用。 shouldComponentUpdate(nextProps, nextState)react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候 componentWillUpdate(nextProps, nextState)组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state，只能通过 nextState.name = ‘你想要更改的值’ 的办法来改变 componentDidUpdate组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 componentWillUnmount组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 配置// 配置proxy package.json &quot;proxy&quot;: { &quot;^apis&quot;:{ &quot;target&quot;:&quot;http://xxx.xxx&quot;, &quot;changeOrigin&quot;:true } } // 配置css预处理less/sass yarn add less-loader less --dev yarn add sass-loader node-sass --dev // webpack.config.dev.js module: { strictExportPresence: true, //... rules: [ // ... { test: /\.(css|less)$/, // 修改 use: [ require.resolve(&apos;style-loader&apos;), { loader: require.resolve(&apos;css-loader&apos;), options: { importLoaders: 1, }, }, { loader: require.resolve(&apos;postcss-loader&apos;), options: {}, }, // 增加 { loader: require.resolve(&apos;less-loader&apos;) // compiles Less to CSS } ], }, ] // webpack.config.prod.js { test: /\.(css|less)$/, // 修改 loader: ExtractTextPlugin.extract( Object.assign( { fallback: { loader: require.resolve(&apos;style-loader&apos;), options: { hmr: false, }, }, use: [ // ...code { loader: require.resolve(&apos;less-loader&apos;) // 增加 } ], }, extractTextPluginOptions ) ), } // 别名 webpack.config.prod.js webpack.config.dev.js alias: { &apos;react-native&apos;: &apos;react-native-web&apos;, // +++ 加入配置 &apos;@&apos;: resolve(&apos;src&apos;) } // webpack.config.prod.js 去掉map文件 - devtool: shouldUseSourceMap ? &apos;source-map&apos; : false // 改为 devtool: false, // 修改端口号 node_modules/react-scripts/scripts/start.js中：把3000端口修改成自己想要的端口 // 模块热替换 npm i react-hot-loader -D webpack.config.dev.js中entry第一行增加`&apos;react-hot-loader/patch&apos;， .babelrc { &quot;presets&quot;: [ [&quot;es2015&quot;, {&quot;loose&quot;: true}], &quot;react&quot; ], &quot;plugins&quot;: [&quot;react-hot-loader/babel&quot;] } // webpack.config.dev.js { test: /\.(js|jsx|mjs)$/, include: paths.appSrc, loader: require.resolve(&apos;babel-loader&apos;), options: { // This is a feature of `babel-loader` for webpack (not Babel itself). // It enables caching results in ./node_modules/.cache/babel-loader/ // directory for faster rebuilds. cacheDirectory: true, plugins: [ &apos;react-hot-loader/babel&apos; ] }, }, // index.js if (module.hot) { module.hot.accept(&apos;./App&apos;, () =&gt; { // 当我们热更新的代码出现的时候，把App重新加载 const NextApp = require(&apos;./App&apos;).default //因为在App里使用的是export default语法，这里使用的是require,默认不会加载default的，所以需要手动加上 render(NextApp) // 重新渲染到 document 里面 }) }]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包规定]]></title>
    <url>%2F2019%2F05%2F30%2Fwebpack%E6%89%93%E5%8C%85%E8%A7%84%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[文中主要讲一些优化方案 使用vuecli3 webpack兼容 IE123456789101112131415161718192021222324252627282930313233// 第一步,安装依赖npm install --save babel-polyfill安装安装依赖依赖// 第二步 然后在main.js中的最前面引入babel-polyfillimport &apos;babel-polyfill&apos;// 在config中的webpack.base.conf.js中,修改编译配置entry:&#123; app:[&apos;babel-polyfill&apos;,&apos;./src/main.js&apos;]&#125;// 在规则中加入解析的内容module:&#123; rules: [ &#123; test: /\.js$/, loader: &apos;babel-loader&apos;, include: [ resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;), resolve(&apos;/node_modules/element-ui/src&apos;), resolve(&apos;/node_modules/element-ui/pachages&apos;), resolve(&apos;/node_modules/_element-ui@2.3.4@_element-ui/src&apos;), resolve(&apos;/node_modules/_element-ui@2.3.4@_element-ui/pachages&apos;), resolve(&apos;/node_modules/easyscroll/src&apos;), resolve(&apos;/node_modules/_easyscroll@1.0.1@easyscroll/src&apos;) ] &#125; ]&#125;// 在vuecli3中chainWebpack:config=&gt;&#123; config.entry(&apos;main&apos;).add(&apos;babel-polyfill&apos;)&#125; webpack 使用按需加载elementUI按需引入官方文档1234567891011121314npm install babel-plugin-component -D// 将 .babelrc 修改为&#123; &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]], &quot;plugins&quot;: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; antdesignvue官方文档12345678910111213141516171819202122232425262728yarn add babel-plugin-import --dev// Modify babel.config.js module.exports = &#123; presets: [&quot;@vue/app&quot;],+ plugins: [+ [+ &quot;import&quot;,+ &#123; libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: true &#125;+ ]+ ]&#125;; // src/main.js import Vue from &apos;vue&apos;- import Button from &apos;ant-design-vue/lib/button&apos;;+ import &#123; Button &#125; from &apos;ant-design-vue&apos;;- import &apos;ant-design-vue/dist/antd.css&apos; import App from &apos;./App&apos; Vue.component(Button.name, Button) Vue.config.productionTip = false /* eslint-disable no-new */ new Vue(&#123; el: &apos;#app&apos;, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos; &#125;) CDN加载1234567891011121314151617181920212223242526272829// 在vue.config.js文件:module.exports = &#123; chainWebpack: config =&gt; &#123; // 压缩代码 config.optimization.minimize(true); // 分割代码 config.optimization.splitChunks(&#123; chunks: &apos;all&apos; &#125;) // 用cdn方式引入 config.externals(&#123; &apos;vue&apos;: &apos;Vue&apos;, &apos;vuex&apos;: &apos;Vuex&apos;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;axios&apos;: &apos;axios&apos; &#125;) &#125;&#125;// 在html中&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.runtime.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt;// 提取CSSmodule.exports = &#123; css: &#123; extract: true &#125;&#125; gzip的压缩123456789101112131415161718192021222324252627282930313233npm install --save-dev compression-webpack-pluginconst CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;)const compress = new CompressionWebpackPlugin( &#123; filename: info =&gt; &#123; return `$&#123;info.path&#125;.gz$&#123;info.query&#125;` &#125;, algorithm: &apos;gzip&apos;, threshold: 10240, test: new RegExp( &apos;\\.(&apos; + [&apos;js&apos;].join(&apos;|&apos;) + &apos;)$&apos; ), minRatio: 0.8, deleteOriginalAssets: false &#125;)module.exports = &#123;devServer: &#123; before(app, server) &#123; app.get(/.*.(js)$/, (req, res, next) =&gt; &#123; req.url = req.url + &apos;.gz&apos;; res.set(&apos;Content-Encoding&apos;, &apos;gzip&apos;); next(); &#125;) &#125; &#125; configureWebpack: &#123; plugins: [compress] &#125; 去除console.log123456789101112131415161718192021222324252627282930313233343536373839// 方法一const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);module.exports = &#123; configureWebpack: config =&gt; &#123; if (IS_PROD) &#123; const plugins = []; plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console: true, drop_debugger: false, pure_funcs: [&apos;console.log&apos;]//移除console &#125; &#125;, sourceMap: false, parallel: true &#125;) ); config.plugins = [ ...config.plugins, ...plugins ]; &#125; &#125;&#125;// 方法二npm i --save-dev babel-plugin-transform-remove-console// 在babel.config.js中配置const plugins = [];if([&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV)) &#123; plugins.push(&quot;transform-remove-console&quot;)&#125;module.exports = &#123; presets: [[&quot;@vue/app&quot;,&#123;&quot;useBuiltIns&quot;: &quot;entry&quot;&#125;]], plugins: plugins&#125;; 环境配置在根目录新建2个文件，分别为.env.development，.env.production，.env.test项目变量1234567891011VUE_APP_BASE_API = &apos;变量值&apos;// 取值process.env.VUE_APP_BASE_API// 更改package.json文件 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;test&quot;: &quot;vue-cli-service serve --mode test&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:test&quot;: &quot;vue-cli-service build --mode test&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, 设置别名参考下方123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123const path = require(&quot;path&quot;);const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);const isProduction = process.env.NODE_ENV === &apos;production&apos;;const cdn = &#123; css: [], js: [ &apos;https://cdn.bootcss.com/vue/2.5.17/vue.runtime.min.js&apos;, &apos;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&apos;, &apos;https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js&apos;, &apos;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&apos;, ]&#125;function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; // 基本路径 baseUrl: &apos;./&apos;, // 输出文件目录 outputDir: &apos;dist&apos;, // 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 // assetsDir: &quot;./&quot;, // 指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径 indexPath: &apos;./&apos;, // eslint-loader 是否在保存的时候检查 lintOnSave: true, // webpack配置 // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md chainWebpack: config =&gt; &#123; config .entry(&apos;index&apos;) .add(&apos;babel-polyfill&apos;) .end(); // 配置别名 config.resolve.alias .set(&quot;@&quot;, resolve(&quot;src&quot;)) .set(&quot;@img&quot;, resolve(&quot;src/assets/images&quot;)) .set(&quot;@css&quot;, resolve(&quot;src/assets/styles/css&quot;)) .set(&quot;@scss&quot;, resolve(&quot;src/assets/styles/scss&quot;)); // 生产环境配置 if (isProduction) &#123; // 删除预加载 config.plugins.delete(&apos;preload&apos;); config.plugins.delete(&apos;prefetch&apos;); // 压缩代码 config.optimization.minimize(true); // 分割代码 config.optimization.splitChunks(&#123; chunks: &apos;all&apos; &#125;) // 生产环境注入cdn config.plugin(&apos;html&apos;) .tap(args =&gt; &#123; args[0].cdn = cdn; return args; &#125;); &#125; &#125;, configureWebpack: config =&gt; &#123; if (isProduction) &#123; // 用cdn方式引入 config.externals = &#123; &apos;vue&apos;: &apos;Vue&apos;, &apos;vuex&apos;: &apos;Vuex&apos;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;axios&apos;: &apos;axios&apos; &#125; // 为生产环境修改配置... config.plugins.push( //生产环境自动删除console new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_debugger: true, drop_console: true, &#125;, &#125;, sourceMap: false, parallel: true, &#125;) ); &#125; else &#123; // 为开发环境修改配置... &#125; &#125;, // 生产环境是否生成 sourceMap 文件 productionSourceMap: false, // css相关配置 css: &#123; // 是否使用css分离插件 ExtractTextPlugin extract: true, // 开启 CSS source maps? sourceMap: false, // css预设器配置项 loaderOptions: &#123; // pass options to sass-loader sass: &#123; // 引入全局变量样式 data: ` @import &quot;@/stylePath/theme.scss; ` &#125; &#125;, // 启用 CSS modules for all css / pre-processor files. modules: false, &#125;, // use thread-loader for babel &amp; TS in production build // enabled by default if the machine has more than 1 cores parallel: require(&apos;os&apos;).cpus().length &gt; 1, devServer: &#123; port: 8888, // 端口 open: true, // 自动开启浏览器 compress: false, // 开启压缩 overlay: &#123; warnings: true, errors: true &#125; &#125;,&#125;]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>WEBPACK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作字体图标]]></title>
    <url>%2F2019%2F05%2F30%2F%E5%88%B6%E4%BD%9C%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[制作字体图标主要讲了怎么利用svg制作属于自己的字体图标，适合结合公司UI制作一套自己公司的图标 方法https://icomoon.io/app/#/select1、打开上述网站，然后选择导入图标，导入自己的SVG文件2、选择你上传的图标3、点击generatate font4、勾选选项，起名字以及一些支持IE等选项5、下载，文件中包含案列及使用方法，以及各种字体的文件6、根据Dome使用字体图标 第二种方法在icon-font 阿里字体图标库中建立团队 直接下载]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>ICON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片规范]]></title>
    <url>%2F2019%2F05%2F30%2F%E5%9B%BE%E7%89%87%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[#图片规范 图片格式 常见的图片格式有 GIF、PNG8、PNG24、JPEG、WEBP，根据图片格式的特性和场景需要选取适合的图片格式。 GIF GIF图象是基于颜色列表的（存储的数据是该点的颜色对应于颜色列表的索引值），最多只支持8位（256色）。GIF文件内部分成许多存储块，用来存储多幅图象或者是决定图象表现行为的控制块，用以实现动画和交互式应用。GIF文件还通过LZW压缩算法压缩图象数据来减少图象尺寸 特性 优秀的压缩算法使其在一定程度上保证图像质量的同时将体积变得很小。 可插入多帧，从而实现动画效果。 可设置透明色以产生对象浮现于背景之上的效果。 由于采用了8位压缩，最多只能处理256种颜色，故不宜应用于真彩色图片。 png PNG是20世纪90年代中期开始开发的图像文件存储格式，其目的是企图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。流式网络图形格式(Portable Network Graphic Format，PNG)名称来源于非官方的“PNG’s Not GIF”，是一种位图文件(bitmap file)存储格式，读成“ping”。PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的α通道数据。PNG使用从LZ77派生的无损数据压缩算法。 特性 支持256色调色板技术，文件体积小。 无损压缩 最高支持48位真彩色图像以及16位灰度图像。 支持Alpha通道的透明/半透明特性。 支持图像亮度的Gamma校准信息。 支持存储附加文本信息，以保留图像名称、作者、版权、创作时间、注释等信息。 渐近显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌。 使用CRC防止文件出错。 最新的PNG标准允许在一个文件内存储多幅图像。 JPEG JPEG是一种针对照片视频而广泛使用的一种有损压缩标准方法。这个名称代表Joint Photographic Experts Group（联合图像专家小组）。此团队创立于公元1986年，1992年发布了JPEG的标准而在1994年获得了ISO 10918-1的认定 特性 适用于储存24位元全采影像 采取的压缩方式通常为有损压缩 不支持透明或动画 压缩比越高影像耗损越大，失真越严重 压缩比在10左右肉眼无法辨出压缩图与原图的差别 WEBP WebP，是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自视频编码格式 VP8，是由Google在购买On2 Technologies后发展出来。WebP最初在2010年发布，2011年11月8日，Google开始让WebP支持无损压缩和透明色的功能，而在2012年8月16日的参考实做libwebp 0.2.0中正式支持 特性： 同时提供有损压缩和无损压缩两种图片文件格式 文件体积小，无损压缩后，比 PNG 文件少了 45％ 的文件大小；有损压缩后，比 JPEG 文件少了 25% - 34% 文件大小 浏览器兼容差，目前只支持客户端 Chrome 和 Opera 浏览器以及安卓原生浏览器(Andriod 4.0+)，WebP兼容性 团队约定内容图内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大 优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式 尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大 背景图背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片 PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式 图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式 图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式 条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式 图片大小 中国普通家庭的宽带基本能达到8Mbps，实际速率大约为500—900KB/s，全国3G/4G用户占有比超过了50%，为了保证图片能更好地加载展示给用户看，团队约定： PC平台单张的图片的大小不应大于 200KB。 移动平台单张的图片的大小不应大于 100KB。 图片质量 上线的图片都应该经过压缩处理，压缩后的图片不应该出现肉眼可感知的失真区域 60质量的JPEG格式图片与质量大于60的相比，肉眼已看不出明显的区别，因此保存 JPEG 图的时候，质量一般控制在60，若保真度要求高的图片可适量提高到 80，图片大小控制在 200KB 以内 图片引入 测试内容图应该写上表明图片尺寸的占位图，可以用线上占位图生成服务，如： http://placeholder.qiniudn.com/300x200 HTML 中图片引入不需添加 width、height 属性，alt 属性应该写上12推荐：&lt;img src="" alt="" &gt; 12不推荐：&lt;img src="" width="" height="" &gt; CSS 中图片引入不需要引号123.jdc &#123; background-image: url(icon.png);&#125; CSS Sprites VS Data URIsCSS Sprites特点 减少请求数 加速图片的显示 维护更新成本大 更多的内存消耗，特别是大体积或有过多空白的 Sprites 图 图片渗漏，相邻的不需展示的图片有可能出现在展示元素中，特别是在高清设备移动设备上 Data URIs（base64编码） 减少请求数 转换文件体积大，大约比原始的二进制大33% IE6 / IE7 不支持 图片显示相对较慢，需要更多的CPU消耗 团队约定CSS Sprites 使用建议 适合使用频率高更新频率低的小图标 尽量不留太多的空白 体积较大的图片不合并 确保要合并的小图坐标数值和合并后的 Sprites 图尺寸均为偶数 Data URIs（base64编码）使用建议 适合更新频率高的小图片，如某些具备自定义功能的标题icon等 转换成 Base64 编码的图片应小于 2KB 移动端不使用 Base64 编码 要兼容 IE6/IE7 的不使用]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM搭建]]></title>
    <url>%2F2019%2F05%2F29%2FNPM%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[NPM搭建本章会介绍 CNPM 的基础部署方法 准备 部署的宿体，如服务器、云主机、自己的电脑等； 数据库，支持 MySQL、PostgreSQL、MariaDB，如果使用 SQLite则无需准备； Git 客户端（推荐）。克隆 CNPM 123git clone https://github.com/cnpm/cnpmjs.org.git//安装依赖npm install 修改配置文件123'use strict';module.exports = &#123;&#125;; enableCluster 是否启用 cluster-worker 模式启动服务，默认 false，生产环节推荐为 true; registryPort API 专用的 registry 服务端口，默认 7001 webPort Web 服务端口，默认 7002 bindingHost 监听绑定的 Host，默认为 127.0.0.1，如果外面架了一层本地的 Nginx 反向代理或者 Apache 反向代理的话推荐不用改 sessionSecret session 用的 logdir 日志目录 uploadDir 临时上传文件目录 viewCache 视图模板缓存是否开启，默认为 false enableCompress 是否开启 gzip 压缩，默认为 false admins 管理员们，这是一个 JSON Object，对应各键名为各管理员的用户名，键值为其邮箱，默认为 { fengmk2: &#39;fengmk2@gmail.com‘, admin: &#39;admin@cnpmjs.org‘, dead_horse: &#39;dead_horse@qq.com‘ } logoURL Logo 地址 adBanner 广告 Banner 的地址 customReadmeFile 实际上我们看到的 cnpmjs.org 首页中间一大堆冗长的介绍是一个 Markdown 文件转化而成的，你可以设置该项来自行替换这个文件 customFooter 自定义页脚模板 npmClientName 默认为 cnpm，如果你有自己开发或者 fork 的 npm 客户端的话请改成自己的 CLI 命令，这个应该会在一些页面的说明处替换成你所写的 backupFilePrefix 备份目录 database 数据库相关配置，为一个对象，默认如果不配置将会是一个~/.http://cnpmjs.org/data.sqlite 的 SQLite； db 数据的库名； username 数据库用户名 password 数据库密码； dialect 数据库适配器，可选 “mysql”、”sqlite”、”postgres”、”mariadb”，默认为”sqlite”； host 数据库地址； port 数据库端口； pool 数据库连接池相关配置，为一个对象 maxConnections 最大连接数，默认为 10； minConnections 最小连接数，默认为 0； maxIdleTime 单条链接最大空闲时间，默认为 30000 毫秒； storege 仅对 SQLite 配置有效，数据库地址，默认为 ~/.cnpmjs/data.sqlite； nfs 包文件系统处理对象，为一个 Node.js 对象，默认是 fs-cnpm 这个包，并且配置在~/.cnpmjs/nfs 目录下，也就是说默认所有同步的包都会被放在这个目录下 registryHost enablePrivate 是否开启私有模式，默认为 false；如果是私有模式则只有管理员能发布包，其它人只能从源站同步包；如果是非私有模式则所有登录用户都能发布包 scopes 非管理员发布包的时候只能用以 scopes 里面列举的命名空间为前缀来发布，如果没设置则无法发布，也就是说这是一个必填项，默认为 [ ‘@cnpm’, ‘@cnpmtest’, ‘@cnpm-test’ ]， privatePackages 就如该配置项的注释所述，出于历史包袱的原因，有些已经存在的私有包（可能之前是用 Git 的方式安装的）并没有以命名空间的形式来命名，而这种包本来是无法上传到 CNPM 的，这个配置项数组就是用来加这些例外白名单的，默认为一个空数组 sourceNpmRegistry 更新源 NPM 的 registry 地址，默认为https://registry.npm.taobao.org sourceNpmRegistryIsCNpm 源 registry 是否为 CNPM，默认为 true，如果你使用的源是官方 NPM 源，请将其设为 false； syncByInstall 如果安装包的时候发现包不存在，则尝试从更新源同步，默认为 true syncModel 更新模式（不过我觉得是个 typo），有下面几种模式可以选择，默认为 “none”;”none”：永不同步，只管理私有用户上传的包，其它源包会直接从源站获取；”exist”：定时同步已经存在于数据库的包；”all”：定时同步所有源站的包 syncInterval 同步间隔，默认为 “10m” 即十分钟 syncDevDependencies 是否同步每个包里面的 devDependencies 包们，默认为 false badgeSubject 包的 badge 显示的名字，默认为 cnpm userService 用户验证接口，默认为 null，即无用户相关功能也就是无法有用户去上传包，该部分需要自己实现接口功能并配置，如与公司的 Gitlab 相对接，这也是后话了 alwaysAuth 是否始终需要用户验证，即便是 $ cnpm install 等命令 httpProxy 代理地址设置 初始化数据库如果你使用的是 SQLite 的话，数据库是自动就好了的，可以忽略该步。 其它数据库需要自行导入初始数据库结构。 初始数据库脚本在 docs/db.sql 里面，你可以用一些 GUI 工具将数据导入，也可以直接进入命令行导入。 比如你用的是 MySQL，就可以在本机操作 MySQL。 123$ mysql -u yourname -pmysql&gt; use cnpmjs;mysql&gt; source docs/db.sql 启动服务12345npm run dev：调试模式启动；npm run test：跑测试；npm run start：启动 CNPM；npm run status：查看 CNPM 启动状态；npm run stop：停止 CNPM。]]></content>
      <categories>
        <category>NPM</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS规范]]></title>
    <url>%2F2019%2F05%2F28%2FCSS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[代码规范 编码规范： @charset规则一定要在样式文件的第一行首个字符位置开始 @charset “”;一定要写上，并且用小写字母，不能出现转义符 代码风格 样式书写：紧凑型（Compact） 1.jdc&#123;display: block;width: 50px;&#125; 展开型（Expanded）推荐 1234.jdc&#123; display: block; width: 50px;&#125; 代码大小写样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写 12345678/* 推荐 */.jdc&#123; display:block;&#125;/* 不推荐 */.JDC&#123; DISPLAY:BLOCK;&#125; 选择器 尽量少用通用选择器* 不使用ID选择器 不使用无具体语义定义的标签选择器1234/* 推荐 */.jdc &#123;&#125;.jdc li &#123;&#125;.jdc li p&#123;&#125; 1234/* 不推荐 */*&#123;&#125;#jdc &#123;&#125;.jdc div&#123;&#125; 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）1234.jdc &#123; width: 100%; height: 100%;&#125; 代码易读性左括号与类名之间一个空格，冒号与属性值之间一个空格1234/*推荐*/.jdc &#123; width: 100%; &#125; 1234/*不推荐*/.jdc&#123; width:100%;&#125; 逗号分隔的取值，逗号之后一个空格1234/*推荐：*/.jdc &#123; box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;&#125; 1234/*不推荐：*/.jdc &#123; box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;&#125; 为单个css选择器或新申明开启新行：123456789/*推荐*/.jdc, .jdc_logo, .jdc_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 123456/*不推荐：*/.jdc,jdc_logo,.jdc_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 01234/*推荐：*/.jdc &#123; color: rgba(255,255,255,.5);&#125; 1234/*不推荐：*/.jdc &#123; color: rgba( 255, 255, 255, 0.5 );&#125; 属性值十六进制数值能用简写的尽量用简写1234/*推荐：*/.jdc &#123; color: #fff;&#125; 1234/*不推荐：*/.jdc &#123; color: #ffffff;&#125; 不要为 0 指明单位1234/*推荐：*/.jdc &#123; margin: 0 10px;&#125; 1234/*不推荐：*/.jdc &#123; margin: 0px 10px;&#125; 属性值引导css属性值需要用到引号时，统一使用单引号1234/* 推荐 */.jdc &#123; font-family: 'Hiragino Sans GB';&#125; 1234/* 不推荐 */.jdc &#123; font-family: "Hiragino Sans GB";&#125; 属性书写顺序建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …1234567891011121314151617.jdc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; CSS3浏览器私有前缀写法CSS3 浏览器私有前缀在前，标准前缀在后1234567.jdc &#123; -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; 注释规范 注释以字符 / 开始，以字符 / 结束 注释不能嵌套 单行注释注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行123456推荐：/* Comment Text */.jdc&#123;&#125;/* Comment Text */.jdc&#123;&#125; 12345678不推荐：/*Comment Text*/.jdc&#123; display: block;&#125;.jdc&#123; display: block;/*Comment Text*/&#125; 模块注释注释内容第一个字符和最后一个字符都是一个空格字符，/ 与 模块信息描述占一行，多个横线分隔符-与/占一行，行与行之间相隔两行1234567推荐：/* Module A---------------------------------------------------------------- */.mod_a &#123;&#125;/* Module B---------------------------------------------------------------- */.mod_b &#123;&#125; 12345不推荐：/* Module A ---------------------------------------------------- */.mod_a &#123;&#125;/* Module B ---------------------------------------------------- */.mod_b &#123;&#125; 文件信息注释在样式文件编码声明 @charset 语句下面注明页面名称、作者、创建日期等信息123456@charset "UTF-8";/** * @desc File Info * @author Author Name * @date 2015-10-10 */ SASS规范 SASS注释规范SASS支持 CSS 标准的多行注释 / /，同时也支持单行注释 //。 多行注释在使用非 Compressed 模式进行编译后的输出文件中会保留下来，单行注释 // 侧会被移除 多行注释和单行注释在 SASS 编译后输出的压缩 CSS 文件都会被移除 当多行注释内容第一个字符是感叹号 “!” 的时候，即 /! /，SASS无论用哪一种编译方式编译注释都会保留 注释内容可以加入 SASS 变量 嵌套规范选择器嵌套12345678/* CSS */.jdc &#123;&#125;body .jdc &#123;&#125;/* SCSS */.jdc &#123; body &amp; &#123;&#125;&#125; 12345678910111213/* CSS */.jdc &#123;&#125;.jdc_cover &#123;&#125;.jdc_info &#123;&#125;.jdc_info_name &#123;&#125;/* SCSS */.jdc &#123; &amp;_cover &#123;&#125; &amp;_info &#123; &amp;_name &#123;&#125; &#125;&#125; 属性嵌套1234567/* CSS */.jdc &#123; background-color: red; background-repeat: no-repeat; background-image: url(/img/icon.png); background-position: 0 0;&#125; 123456789/* SCSS */.jdc &#123; background: &#123; color: red; repeat: no-repeat; image: url(/img/icon.png); position: 0 0; &#125;&#125; 变量可复用属性尽量抽离为页面变量，易于统一维护12345// CSS.jdc &#123; color: red; border-color: red;&#125; 123456// SCSS$color: red;.jdc &#123; color: $color; border-color: $color;&#125; 混合(mixin)根据功能定义模块，然后在需要使用的地方通过 @include 调用，避免编码时重复输入代码段12345678910111213141516171819202122232425262728293031323334353637383940// CSS.jdc_1 &#123; -webkit-border-radius: 5px; border-radius: 5px;&#125;.jdc_2 &#123; -webkit-border-radius: 10px; border-radius: 10px;&#125;// SCSS@mixin radius($radius:5px) &#123; -webkit-border-radius: $radius; border-radius: $radius;&#125;.jdc_1 &#123; @include radius; //参数使用默认值&#125;.jdc_2 &#123; @include radius(10px);&#125;// CSS.jdc_1 &#123; background: url(/img/icon.png) no-repeat -10px 0;&#125;.jdc_2 &#123; background: url(/img/icon.png) no-repeat -20px 0;&#125;// SCSS@mixin icon($x:0, $y:0) &#123; background: url(/img/icon.png) no-repeat $x, $y;&#125;.jdc_1 &#123; @include icon(-10px, 0);&#125;.jdc_2 &#123; @include icon(-20px, 0);&#125; 占位选择器 %如果不调用则不会有任何多余的 css 文件，占位选择器以 % 标识定义，通过 @extend 调用12345678//scss%borderbox &#123; -webkit-box-sizing: border-box; box-sizing: border-box;&#125;.jdc &#123; @extend %borderbox;&#125; extend 继承123456789101112131415161718192021222324252627282930313233// CSS.jdc_1 &#123; font-size: 12px; color: red;&#125;.jdc_2 &#123; font-size: 12px; color: red; font-weight: bold;&#125;// SCSS.jdc_1 &#123; font-size: 12px; color: red;&#125;.jdc_2 &#123; @extend .jdc_1; font-weight: bold;&#125;// 或者%font_red &#123; font-size: 12px; color: red;&#125;.jdc_1 &#123; @extend %font_red;&#125;.jdc_2 &#123; @extend %font_red; font-weight: bold;&#125; for 循环12345678910111213注意：#&#123;&#125; 是连接符，变量连接使用时需要依赖// CSS.jdc_1 &#123;background-position: 0 -20px;&#125;.jdc_2 &#123;background-position: 0 -40px;&#125;.jdc_3 &#123;background-position: 0 -60px;&#125;// SCSS@for $i from 1 through 3 &#123; .jdc_#&#123;$i&#125; &#123; background-position: 0 (-20px) * $i; &#125;&#125; each 循环1234567891011121314151617181920212223242526272829303132// CSS.jdc_list &#123; background-image: url(/img/jdc_list.png);&#125;.jdc_detail &#123; background-image: url(/img/jdc_detail.png);&#125;// SCSS@each $name in list, detail &#123; .jdc_#&#123;$name&#125; &#123; background-image: url(/img/jdc_#&#123;$name&#125;.png); &#125;&#125;// CSS.jdc_list &#123; background-image: url(/img/jdc_list.png); background-color: red;&#125;.jdc_detail &#123; background-image: url(/img/jdc_detail.png); background-color: blue;&#125;// SCSS@each $name, $color in (list, red), (detail, blue) &#123; .jdc_#&#123;$name&#125; &#123; background-image: url(/img/jdc_#&#123;$name&#125;.png); background-color: $color; &#125;&#125; function 函数123456@function pxToRem($px) &#123; @return $px / 10px * 1rem;&#125;.jdc &#123; font-size: pxToRem(12px);&#125; 运算规范运算符之间空出一个空格1234.jdc &#123; width: 100px - 50px; height: 30px / 5;&#125; 注意运算单位，单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意1234567// 正确的运算格式.jdc &#123; width: 100px - 50px; width: 100px + 50px; width: 100px * 2; width: 100px / 2;&#125; 重置样式 移动端12345678910* &#123; -webkit-tap-highlight-color: transparent; outline: 0; margin: 0; padding: 0; vertical-align: baseline; &#125;body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin: 0; padding: 0; vertical-align: baseline; &#125;img &#123; border: 0 none; vertical-align: top; &#125;i, em &#123; font-style: normal; &#125;ol, ul &#123; list-style: none; &#125;input, select, button, h1, h2, h3, h4, h5, h6 &#123; font-size: 100%; font-family: inherit; &#125;table &#123; border-collapse: collapse; border-spacing: 0; &#125;a &#123; text-decoration: none; color: #666; &#125;body &#123; margin: 0 auto; min-width: 320px; max-width: 640px; height: 100%; font-size: 14px; font-family: -apple-system,Helvetica,sans-serif; line-height: 1.5; color: #666; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; &#125;input[type="text"], textarea &#123; -webkit-appearance: none; -moz-appearance: none; appearance: none; &#125; PC端12345678910111213141516html, body, div, h1, h2, h3, h4, h5, h6, p, dl, dt, dd, ol, ul, li, fieldset, form, label, input, legend, table, caption, tbody, tfoot, thead, tr, th, td, textarea, article, aside, audio, canvas, figure, footer, header, mark, menu, nav, section, time, video &#123; margin: 0; padding: 0; &#125;h1, h2, h3, h4, h5, h6 &#123; font-size: 100%; font-weight: normal &#125;article, aside, dialog, figure, footer, header, hgroup, nav, section, blockquote &#123; display: block; &#125;ul, ol &#123; list-style: none; &#125;img &#123; border: 0 none; vertical-align: top; &#125;blockquote, q &#123; quotes: none; &#125;blockquote:before, blockquote:after, q:before, q:after &#123; content: none; &#125;table &#123; border-collapse: collapse; border-spacing: 0; &#125;strong, em, i &#123; font-style: normal; font-weight: normal; &#125;ins &#123; text-decoration: underline; &#125;del &#123; text-decoration: line-through; &#125;mark &#123; background: none; &#125;input::-ms-clear &#123; display: none !important; &#125;body &#123; font: 12px/1.5 \5FAE\8F6F\96C5\9ED1, \5B8B\4F53, "Hiragino Sans GB", STHeiti, "WenQuanYi Micro Hei", "Droid Sans Fallback", SimSun, sans-serif; background: #fff; &#125;a &#123; text-decoration: none; color: #333; &#125;a:hover &#123; text-decoration: underline; &#125; 媒体查询 常用查询语句判断设备横竖屏123/* 横屏 */@media all and (orientation :landscape) &#123;&#125; 1234/* 竖屏 */@media all and (orientation :portrait) &#123;&#125; 判断设备宽高1234/* 设备宽度大于 320px 小于 640px */@media all and (min-width:320px) and (max-width:640px) &#123; &#125; 判断设备像素比1234567891011121314/* 设备像素比为 1 */@media only screen and (-webkit-min-device-pixel-ratio: 1), only screen and (min-device-pixel-ratio: 1) &#123; &#125;/* 设备像素比为 1.5 */@media only screen and (-webkit-min-device-pixel-ratio: 1.5), only screen and (min-device-pixel-ratio: 1.5) &#123; &#125;/* 设备像素比为 2 */@media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min-device-pixel-ratio: 2) &#123; &#125; 常用设备设置iPhones123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* ----------- iPhone 4 and 4S ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape) &#123;&#125;/* ----------- iPhone 5 and 5S ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 320px) and (max-device-width: 568px) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 320px) and (max-device-width: 568px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 320px) and (max-device-width: 568px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape) &#123;&#125;/* ----------- iPhone 6 ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 375px) and (max-device-width: 667px) and (-webkit-min-device-pixel-ratio: 2) &#123; &#125;/* Portrait */@media only screen and (min-device-width: 375px) and (max-device-width: 667px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) &#123; &#125;/* Landscape */@media only screen and (min-device-width: 375px) and (max-device-width: 667px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape) &#123; &#125;/* ----------- iPhone 6+ ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) &#123; &#125;/* Portrait */@media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) and (orientation: portrait) &#123; &#125;/* Landscape */@media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) and (orientation: landscape) &#123; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Galaxy Phones/* ----------- Galaxy S3 ----------- *//* Portrait and Landscape */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 2) &#123;&#125;/* Portrait */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait) &#123;&#125;/* Landscape */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape) &#123;&#125;/* ----------- Galaxy S4 ----------- *//* Portrait and Landscape */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* Portrait */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait) &#123;&#125;/* Landscape */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape) &#123;&#125;/* ----------- Galaxy S5 ----------- *//* Portrait and Landscape */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* Portrait */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait) &#123;&#125;/* Landscape */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape) &#123;&#125; 12345678910111213141516171819202122232425262728HTC Phones/* ----------- HTC One ----------- *//* Portrait and Landscape */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* Portrait */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait) &#123;&#125;/* Landscape */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape) &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384iPads/* ----------- iPad mini ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: portrait) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: landscape) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* ----------- iPad 1 and 2 ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: portrait) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: landscape) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* ----------- iPad 3 and 4 ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: portrait) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: landscape) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125; 移动端常用私有属性 目前两大主流移动平台为 iOS 和 Android，有不少带 -webkit- 前辍的 CSS 私有属性以及一些 iOS only 属性，当中好些属性在日常需求中经常应用到。 WebKit CSS 属性中的一部分已经被包含在 CSS 规范草案中，并且可能成为最后的推荐标准，但目前仍然是试验性的属性，还有一些属性是不规范的属性，它们没有出现在跟踪规范中。 -webkit-scrollbar-webkit-scrollbar 是-webkit-私有的伪元素，用于对拥有overflow属性的区域 自定义滚动条的样式。譬如，为了隐藏滚动条，你可以这么做：1234.scroll::-webkit-scrollbar &#123; width: 0; height: 0;&#125; 除了对整个滚动条的控制外，Webkit还提供了控制对滚动条各组成部分的表现渲染的伪元素，甚至具体到滚动条的各种状态行为的伪类。 滚动条各块组成表现渲染的伪元素一般而言，滚动条的主要组成部分包括： 滚动按钮 — 滚动按钮的夹角则被称为滚动角(corner)。 轨道 — 轨道(track)可以进一步分为轨枕(track pieces) 和滑块(thumb)。Webkit则根据滚动条各组成部分，提供了不同的伪元素来自定义样式。1234567::-webkit-scrollbar &#123; /* 1 */ &#125;::-webkit-scrollbar-button &#123; /* 2 */ &#125;::-webkit-scrollbar-track &#123; /* 3 */ &#125;::-webkit-scrollbar-track-piece &#123; /* 4 */ &#125;::-webkit-scrollbar-thumb &#123; /* 5 */ &#125;::-webkit-scrollbar-corner &#123; /* 6 */ &#125;::-webkit-resizer &#123; /* 7 */ &#125; 滚动条各块组成的伪元素下面的伪类可以应用到上面的伪元素中。:horizontal：选择水平方向的滚动条。 :vertical：选择垂直方向的滚动条。 :decrement：适用于滚动按钮和轨枕。选择能够使得视窗位置递减状态(例如，垂直滚动条向上滚动，水平滚动条向左滚动。)的滚动按钮或轨枕。 :increment：适用于滚动按钮和轨枕。选择能够使得视窗位置递增状态(例如，垂直滚动条向下滚动，水平滚动条向右滚动。)的滚动按钮或轨枕。 :start：适用于滚动按钮和轨枕。选择位于滚动滑块前边的滚动按钮和轨枕。 :end：适用于滚动按钮和轨枕。选择位于滚动滑块后边的滚动按钮和轨枕。 :double-button：适用于滚动按钮和轨枕。选中紧挨着一对按钮的轨枕以及位于滚动条某一端的一对按钮中的其中一个滚动按钮。 :single-button：适用于滚动按钮和轨枕。选中紧挨着仅一个按钮的轨枕以及位于滚动条某一端的仅它本身一个的滚动按钮。 :no-button：适用于轨枕。选中轨道结束位置没有按钮的轨枕。 :corner-present：适用于选中滚动角不存在的滚动条。 :window-inactive：适用于所有滚动条，选中焦点不在该视窗的滚动区域。 另外，:enabled、:disabled、:hover、和:active等伪类同样在滚动条中适用。为了更好地理解，以下是几个伪元素组合伪类的应用例子：123456789::-webkit-scrollbar-track-piece:start &#123; /\*滚动条上半边或左半边\*/&#125;::-webkit-scrollbar-thumb:window-inactive &#123; /\*当焦点不在当前区域滑块的状态\*/::-webkit-scrollbar-button:horizontal:decrement:hover &#123; /\*当鼠标在水平滚动条下面的按钮上的状态\*/ &#125; -webkit-touch-callout-webkit-touch-callout 是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 当你触摸并按住触摸目标时候，禁止或显示系统默认菜单。在iOS上，当你触摸并按住触摸的目标，比如一个链接，Safari浏览器将显示链接有关的系统默认菜单，这个属性可以让你禁用系统默认菜单。属性值 none：系统默认菜单被禁用 inherit：系统默认菜单不被禁用 兼容性 iOS 2.0及更高版本的 Safari 浏览器可用 Android 尚不明确 -webkit-tap-highlight-color-webkit-tap-highlight-color 是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 在 iOS Safari 上，当用户点击链接或具有 JavaScript 可点击脚本的元素，系统会为这些被点击元素加上一个默认的透明色值，该属性可以覆盖该透明值。兼容性 iOS 1.1.1及更高版本的Safari浏览器可用 大部分安卓手机 -webkit-overflow-scrolling定义在具 overflow:scroll 属性的元素内是否采用原生样式滚动行为属性值 auto:默认值，单手滚动，滚动没有惯性效果 touch：原生样式滚动，应用此属性值会产生层叠上下文（会影响定位参照物的属性，类似 opacity、masks、transforms属性，影响到 position 的效果，甚至影响到 position:fixed 的定位参照物，） 兼容性 OS 5.0 及更高版本 大部分安卓机 -webkit-line-clamp-webkit-line-clamp 是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他外来的WebKit属性。 常见结合属性： display: -webkit-box：必须结合的属性，将对象作为弹性伸缩盒子模型显示。 -webkit-box-orient：必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式。 text-overflow：可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。 属性值number:块元素显示的文本的行数 兼容性 iOS Andriod -webkit-appearance-webkit-appearance 是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 改变按钮和其他控件的外观，使其类似于原生控件。 属性值(https://developer.mozilla.org/en-US/docs/Web/CSS/appearance) none：去除系统默认 appearance 的样式，常用于 iOS 下移除原生样式 button：渲染成 button 的风格 checkbox：渲染成 input checkbox 样式的复选框按钮 radio：渲染成 radio 的风格 兼容性 iOS 2.0及更高版本的Safari浏览器可用 Android 尚不明确 -webkit-font-smoothing字体平滑，该属性定义文本的平滑属性，但要注意以下说明： 非标准属性，不建议用于网页上，这个属性不能保证所有用户都能看到相同效果，这会使网站的字体渲染造成不一致，而此属性的渲染行为日后也有可能会改变 属性值 none：去掉字体平滑效果，使字体带锯齿 antialiased：使字体在像素级别更平滑更轻细 subpixel-antialiased：在多数非 Retina 显示设备中字体将会更锐利。注意：以上属性在 Retina 设备上会有明显的效果，在非 Retina 设备上看不出差异 兼容性部分高清设备，如 Retina Mac -webkit-backface-visibilitybackface-visibility 在 W3文档 有定义描述 定义转换元素的背面是否显示属性值 visible：显示（默认值） hidden：隐藏 兼容性 iOS 2.0 及更高版本的 Safari 浏览器可用 大部分 Android]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名规范]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[(阿里BEM命名规范：https://segmentfault.com/a/1190000012705634)由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。 目录命名 项目文件夹：projectname 样式文件夹：css 脚本文件夹：js 样式类图片文件夹：img 图片顺序图片命名建议以以下顺序命名： 图片业务（可选） +（mod_）图片功能类别（必选）+ 图片模块名称（可选） + 图片精度（可选） 图片业务： pp_：拍拍 wx_：微信 sq_：手Q jd_：京东商城 图片功能类别： mod_：是否公共，可选 icon：模块类固化的图标 logo：LOGO类 spr：单页面各种元素合并集合 btn：按钮 bg：可平铺或者大背景 图片模块名称： goodslist：商品列表 goodsinfo：商品信息 userava tar：用户头像 图片精度： 普清：@1x Retina：@2x | @3x 如下面例子：123456789公共模块：wx_mod_btn_goodlist@2x.pngwx_mod_btn_goodlist.pngmod_btn_goodlist.png 非公共模块：wx_btn_goodlist@2x.pngwx_btn_goodlist.pngbtn_goodlist.png 交叉业务协作业务交叉协作的时候，为了避免图片命名冲突，建议图片名加上业务和模块前辍，如拍拍侧和手Q侧的业务交叉合作时，侧栏导航icon雪碧图命名： 12345推荐：pp_icon_mod_sidenav.png不推荐：icon_mod_sidenav.png 处理高清图片的时候，命名应该加上图片相应的精度说明1234567推荐：jdc_logo@1x.pngjdc_logo@2x.png不推荐：jdc_logo.pngjdc_logo_retina.png HTML/CSS文件命名确保文件命名总是以字母开头而不是数字，且字母一律小写，以下划线连接且不带其他标点符号，如： 123456789&lt;!-- HTML --&gt;jdc.htmljdc_list.htmljdc_detail.html&lt;!-- SASS --&gt;jdc.scssjdc_list.scssjdc_detail.scss ClassName命名ClassName的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线 “_” 连接 命名原则祖先模块不能出现下划线，除了是全站公用模块，如 mod_ 系列的命名：123456789101112131415推荐：&lt;div class="modulename"&gt; &lt;div class="modulename_info"&gt; &lt;div class="modulename_son"&gt;&lt;/div&gt; &lt;div class="modulename_son"&gt;&lt;/div&gt; ... &lt;/div&gt;&lt;/div&gt; &lt;!-- 这个是全站公用模块，祖先模块允许直接出现下划线 --&gt;&lt;div class="mod_info"&gt; &lt;div class="mod_info_son"&gt;&lt;/div&gt; &lt;div class="mod_info_son"&gt;&lt;/div&gt; ... &lt;/div&gt; 1234567不推荐：&lt;div class="modulename_info"&gt; &lt;div class="modulename_info_son"&gt;&lt;/div&gt; &lt;div class="modulename_info_son"&gt;&lt;/div&gt; ... &lt;/div&gt; 在子孙模块数量可预测的情况下，严格继承祖先模块的命名前缀1234&lt;div class="modulename"&gt; &lt;div class="modulename_cover"&gt;&lt;/div&gt; &lt;div class="modulename_info"&gt;&lt;/div&gt;&lt;/div&gt; 当子孙模块超过4级或以上的时候，可以考虑在祖先模块内具有识辨性的独立缩写作为新的子孙模块12345678910111213141516推荐：&lt;div class="modulename"&gt; &lt;div class="modulename_cover"&gt;&lt;/div&gt; &lt;div class="modulename_info"&gt; &lt;div class="modulename_info_user"&gt; &lt;div class="modulename_info_user_img"&gt; &lt;img src="" alt=""&gt; &lt;!-- 这个时候 miui 为 modulename_info_user_img 首字母缩写--&gt; &lt;div class="miui_tit"&gt;&lt;/div&gt; &lt;div class="miui_txt"&gt;&lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="modulename_info_list"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415不推荐：&lt;div class="modulename"&gt; &lt;div class="modulename_cover"&gt;&lt;/div&gt; &lt;div class="modulename_info"&gt; &lt;div class="modulename_info_user"&gt; &lt;div class="modulename_info_user_img"&gt; &lt;img src="" alt=""&gt; &lt;div class="modulename_info_user_img_tit"&gt;&lt;/div&gt; &lt;div class="modulename_info_user_img_txt"&gt;&lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="modulename_info_list"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 模块命名全站公共模块：以 mod_ 开头1&lt;div class="mod_yours"&gt;&lt;/div&gt; 业务公共模块：以 业务名mod 开头1&lt;div class="paipai_mod_yours"&gt;&lt;/div&gt; 常用命名推荐注意：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此1&lt;div class="ad"&gt;&lt;/div&gt; 这种广告的英文或拼音类名不应该出现另外，敏感不和谐字眼也不应该出现，如：123456&lt;div class="fuck"&gt;&lt;/div&gt;&lt;div class="jer"&gt;&lt;/div&gt;&lt;div class="sm"&gt;&lt;/div&gt;&lt;div class="gcd"&gt;&lt;/div&gt; &lt;div class="ass"&gt;&lt;/div&gt; &lt;div class="KMT"&gt;&lt;/div&gt; ClassName 含义 about 关于 account 账户 arrow 箭头图标 article 文章 aside 边栏 audio 音频 avatar 头像 bg,background 背景 bar 栏（工具类） branding 品牌化 crumb,breadcrumbs 面包屑 btn,button 按钮 caption 标题，说明 category 分类 chart 图表 clearfix 清除浮动 close 关闭 col,column 列 comment 评论 community 社区 container 容器 content 内容 copyright 版权 current 当前态，选中态 default 默认 description 描述 details 细节 disabled 不可用 entry 文章，博文 error 错误 even 偶数，常用于多行列表或表格中 fail 失败（提示） feature 专题 fewer 收起 field 用于表单的输入区域 figure 图 filter 筛选 first 第一个，常用于列表中]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM上传JS包]]></title>
    <url>%2F2019%2F05%2F28%2FNPM%E5%B7%A5%E5%85%B7JS%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[NPM上传包 初始化JS12345运行npm init 目录如下|---index.js // 主文件|---package.json // 包文件|---README.md // 使用说明|---test.js // 测试JS 以下方的代码为例index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159var region = require('./area.js')var parse = &#123; result:&#123; name:"", mobile:"", phone:"", province:"", city:"", area:"", detail:'', zipCode:'' &#125;, address:'', parseAddress:function(address)&#123; if( address &amp;&amp; typeof address == 'string' )&#123; this.address = address.trim() this.parseResult() &#125;else&#123; this.result = &#123; name:"", mobile:"", phone:"", province:"", city:"", area:"", detail:'', zipCode:'' &#125; &#125; return this.result &#125;, parseResult:function()&#123; this.address = this.address.replace(/\r\n/g, ' ').replace(/\n/g, ' ').replace(/\t/g, ' ') var search = ['地址', '收货地址', '收货人', '收件人', '收货', '邮编', '电话', '：', ':', '；', ';', '，', ',', '。'] search.forEach(str =&gt; &#123; this.address = this.address.replace(new RegExp(str, 'g'), ' ') &#125;); this.address = this.address.replace(/ &#123;2,&#125;/g, ' '); // 找出手机 var mobileReg = /(86-[1][0-9]&#123;10&#125;)|(86[1][0-9]&#123;10&#125;)|([1][0-9]&#123;10&#125;)/g; var mobile = mobileReg.exec(this.address); if (mobile) &#123; this.result.mobile = mobile[0]; this.address = this.address.replace(mobile[0], ' ') &#125; // 找出固话 var phoneReg = /(([0-9]&#123;3,4&#125;-)[0-9]&#123;7,8&#125;)|([0-9]&#123;12&#125;)|([0-9]&#123;11&#125;)|([0-9]&#123;10&#125;)|([0-9]&#123;9&#125;)|([0-9]&#123;8&#125;)|([0-9]&#123;7&#125;)/g; var phone = phoneReg.exec(this.address); if (phone) &#123; this.result.phone = phone[0]; this.address = this.address.replace(phone[0], ' ') &#125; // 邮政编码 const zipReg = /([0-9]&#123;6&#125;)/g; const zip = zipReg.exec(this.address); if (zip) &#123; this.result.zipCode = zip[0]; this.address = this.address.replace(zip[0], '') &#125; // 空格缩减 this.address = this.address.replace(/ &#123;2,&#125;/,' '); // 省市区的识别 var region = this.parseRegion() if(region.weights &gt;= 2)&#123; this.result.province = region.province this.result.city = region.city this.result.area = region.area this.address = this.address.replace(this.result.province, '') this.address = this.address.replace(this.result.city, '') this.address = this.address.replace(this.result.area, '') &#125; var provinceKey = ['特别行政区', '古自治区', '维吾尔自治区', '壮族自治区', '回族自治区', '自治区', '直辖', '省', '市']; var cityKey = ['布依族苗族自治州', '苗族侗族自治州', '自治州', '州', '市', '县']; for (var k in provinceKey) &#123; if (this.address.indexOf(provinceKey[k]) &gt;-1) &#123; this.address = this.address.replace(provinceKey[k], ' '); &#125; &#125; for (var key in cityKey) &#123; if (this.address.indexOf(cityKey[key]) &gt;-1) &#123; this.address = this.address.replace(cityKey[key], ' '); &#125; &#125; // 取消双空格 和 前后空格 this.address = this.address.replace(/ &#123;2,&#125;/,' ').trim(); var info = this.address.split(' ') var name = info[0] || '' info.forEach(function(item)&#123; if(item.length &lt; name.length)&#123; name = item &#125; &#125;) var detail = this.address.replace(name,' ').replace(/ /,'').trim(); this.result.name = name this.result.detail = detail &#125;, parseRegion:function()&#123; var that = this var citys = [] var result = &#123; province:'', city:'', area:'', weights:0 &#125; region.forEach(function(items)&#123; if(that.address.indexOf(items.name) &gt; -1)&#123; citys.push(&#123; province:items.name, weights:1 &#125;) items.city.forEach(function(item)&#123; if(that.address.indexOf(item.name) &gt; -1)&#123; Object.assign(citys[citys.length-1],&#123; city:item.name, weights:2 &#125;) item.area.forEach(function(name)&#123; if(that.address.indexOf(name) &gt; -1)&#123; Object.assign(citys[citys.length-1],&#123; area:name, weights:3 &#125;) &#125; &#125;) &#125; &#125;) &#125; else &#123; items.city.forEach(function(item)&#123; citys.push(&#123; province:items.name, &#125;) if(that.address.indexOf(item.name) &gt; -1)&#123; Object.assign(citys[citys.length-1],&#123; city:item.name, weights:1 &#125;) item.area.forEach(function(name)&#123; if(that.address.indexOf(name) &gt; -1)&#123; Object.assign(citys[citys.length-1],&#123; area:name, weights:2 &#125;) &#125; &#125;) &#125; &#125;) &#125; &#125;) citys.forEach(function(item)&#123; if(result.weights &lt; item.weights)&#123; Object.assign(result,item) &#125; &#125;) return result &#125;&#125;module.exports = parse package.json123456789101112131415&#123; "name": "parse-address-cn", "version": "1.0.2", "description": "解析地址姓名及电话", "main": "index.js", "scripts": &#123; "test": "node test.js" &#125;, "keywords":[ "parse", "address" ], "author": "akcedar@163.com", "license": "MIT"&#125; test.js123456789101112131415var aa = require('./index.js')console.log(aa.parseAddress('陕西省安康市汉滨区果园小区 13222222222 张三 725000'))console.log(aa.parseAddress('上海市青浦区华南路555号 张三'))console.log(aa.parseAddress('张三上海市青浦区华南路555号 12222222222'))console.log(aa.parseAddress('张北京上海市青浦区华南路555号 12222222222'))console.log(aa.parseAddress(''))console.log(aa.parseAddress([])) 编写万上述文件后npm login //输入以下命令，会提示输入用户名、密码、邮箱。继续执行12//退出当前文件夹，开始命令行发布包，命令如下：npm publish testxxxxx 验证下载npm install testxxxxx强制删除12//删除要用force强制删除。超过24小时就不能删除了。自己把握好时间。npm --force unpublish testxxxxx]]></content>
      <categories>
        <category>NPM</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD语法编写]]></title>
    <url>%2F2019%2F05%2F27%2Fmd%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题 #号标题前面带#号，后面带文字，分别表示h1-h6,h1下面会有一条横线，注意，#号后面有空格 ==标题在标题的下一行写==号 数量不限制 &gt;1 –二级标题在标题的下一行写- 数量不限制 &gt;1 列表无序列表无序列表可以用* ， + ， — 来创建 有序列表数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的 区块引用用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用可以嵌套，只需要多加一个&gt; &gt;&gt;表示二级引用 最多到6层 分割线分割线可以由 _（星号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 表示虚线 _表示实线 链接行内连接行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中 链接还可以带title属性 参数式这就好理解了，就是把链接当成参数，适合多出使用相同链接的场景，注意参数的对应关系，参数定义时，这几种写法都可以：1234567[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here)[foo]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 图片也分为行内式和参数式 用法和链接一样，区别是图片前面要写一个！ 代码框一行用单反引号包起来 多行多行用三个反引号，如果要写注释，可以在反引号后面写 表格1234name | age |sex:-:| -:| :-居中| 右对齐|左对齐zhangsan| 18| man name age sex zhangsan 18 man 强调一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗 转义和jS保持一直 \ 删除线两个~包表示删除线 如：~~ 删除线文字~~ 显示 删除线文字]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS规范]]></title>
    <url>%2F2019%2F05%2F27%2FJS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[编码规范统一团队的编码规范，有助于代码的维护。本章是传统意义上的 Style Guideline，目的是统一一些相对主观化的代码风格。 单行代码块在单行代码块中使用空格 不推荐 12function foo () &#123;return true&#125;if (foo) &#123;bar = 0&#125; 推荐 12function foo () &#123; return true &#125;if (foo) &#123; bar = 0 &#125; 大括号风格在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下： One True Brace Style 12345if (foo) &#123; bar()&#125; else &#123; baz()&#125; Stroustrup 123456if (foo) &#123; bar()&#125;else &#123; baz()&#125; Allman 12345678if (foo)&#123; bar()&#125;else&#123; baz()&#125; 我们团队约定使用 One True Brace Style 风格 变量命名当命名变量时，主流分为驼峰式命名（variableName）和下划线命名（variable_name）两大阵营。 团队约定使用驼峰式命名 拖尾逗号在 ECMAScript5 里面，对象字面量中的拖尾逗号是合法的，但在 IE8（非 IE8 文档模式）下，当出现拖尾逗号，则会抛出错误。 拖尾逗号的例子： 1234var foo = &#123; name: 'foo', age: '22',&#125; 拖尾逗号的好处是，简化了对象和数组添加或删除元素，我们只需要修改新增的行即可，并不会增加差异化的代码行数。 因为拖尾逗号有好也有不好，所以团队约定允许在最后一个元素或属性与闭括号 ] 或 } 在不同行时，可以（但不要求）使用拖尾逗号。当在同一行时，禁止使用拖尾逗号。 逗号空格逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。 不推荐 123var foo = 1,bar = 2var foo = 1 , bar = 2var foo = 1 ,bar = 2 推荐 1var foo = 1, bar = 2 逗号风格逗号分隔列表时，在 JavaScript 中主要有两种逗号风格： 标准风格，逗号放置在当前行的末尾 逗号前置风格，逗号放置在下一行的开始位置 团队约定使用标准风格 不推荐 123456789var foo = 1,bar = 2var foo = 1, bar = 2var foo = ['name' , 'age'] 推荐 12345var foo = 1, bar = 2var foo = ['name', 'age'] 计算属性的空格团队约定在对象的计算属性内，禁止使用空格 不推荐 123obj['foo' ]obj[ 'foo']obj[ 'foo' ] 推荐 1obj['foo'] 拖尾换行在非空文件中，存在拖尾换行是一个常见的 UNIX 风格，它的好处是可以方便在串联和追加文件时不会打断 Shell 的提示。在日常的项目中，保留拖尾换行的好处是，可以减少版本控制时的代码冲突。 不推荐 123function func () &#123; // do something&#125; 推荐 1234function func () &#123; // do something&#125; // 此处是新的一行 可以通过 .editorconfig 添加 EOL 函数调用为了避免语法错误，团队约定在函数调用时，禁止使用空格 不推荐 123fn ()fn() 推荐 1fn() 缩进代码保持一致的缩进，是作为工程师的职业素养。但缩进用两个空格，还是四个空格，是用 Tab 还是空格呢？这样的争论太多了，也得不出答案。本规范结合了市面上优秀的开源项目，姑且约定使用 空格 来缩进，而且缩进使用两个空格。 那是不是不能使用 Tab 进行缩进了？我们可以通过配置 .editorconfig ，将 Tab 自动转换为空格。 对象字面量的键值缩进团队约定对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格 不推荐 1var obj = &#123; 'foo' : 'haha' &#125; 推荐 1var obj = &#123; 'foo': 'haha' &#125; 构造函数首字母大写在 JavaScript 中 new 操作符用来创建某个特定类型的对象的一个实例，该类型的对象是由一个构造函数表示的。由于构造函数只是常规函数，唯一区别是使用 new 来调用。所以我们团队约定构造函数的首字母要大小，以此来区分构造函数和普通函数。 不推荐 1var fooItem = new foo() 推荐 1var fooItem = new Foo() 构造函数的参数在 JavaScript 中，通过 new 调用构造函数时，如果不带参数，可以省略后面的圆括号。但这样会造成与整体的代码风格不一致，所以团队约定使用圆括号 不推荐 1var person = new Person 推荐 1var person = new Person() 链式调用链式调用如果放在同一行，往往会造成代码的可读性差，但有些时候，短的链式调用并不会影响美观。所以本规范约定一行最多只能有四个链式调用，超过就要求换行。 空行空白行对于分离代码逻辑有帮助，但过多的空行会占据屏幕的空间，影响可读性。团队约定最大连续空行数为 2 不推荐 12345var a = 1var b = 2 推荐 1234var a = 1var b = 2 链式赋值链式赋值容易造成代码的可读性差，所以团队约定禁止使用链式赋值 不推荐 1var a = b = c = 1 推荐 123var a = 1var b = 1var c = 1 变量声明JavaScript 允许在一个声明中，声明多个变量。团队约定在声明变量时，一个声明只能有一个变量 不推荐 1var a, b, c 推荐 123var avar bvar c 分号JavaScript 在所有类 C 语言中是比较独特的，它不需要在每个语句的末尾有分号。在很多情况下，JavaScript 引擎可以确定一个分号应该在什么位置然后自动添加它。此特征被称为 自动分号插入 (ASI)，被认为是 JavaScript 中较为有争议的特征。 团队中对于是否应该使用分号，也有许多争论，本规范推荐不使用分号，因为我们认为好的工程师应该知道什么时候该加，什么时候不该加。 相关参考 ：semi 代码块空格一致性是任何风格指南的重要组成部分。虽然在哪里放置块的开括号纯属个人偏好，但在整个项目中应该保持一致。不一致的风格将会分散读者阅读代码的注意力。 团队约定代码块前要添加空格 不推荐 12345if (a)&#123; b()&#125;function a ()&#123;&#125; 推荐 12345if (a) &#123; b()&#125;function a () &#123;&#125; 函数声明的空格当格式化一个函数，函数名或 function 关键字与左括号之间允许有空白。命名函数要求函数名和 function 关键字之间有空格，但是匿名函数要求不加空格。 团队约定函数括号前要加空格 不推荐 123function func(x) &#123; // ...&#125; 推荐 123function func (x) &#123; // ...&#125; 操作符的空格团队约定操作符前后都需要添加空格 不推荐 1var sum = 1+2 推荐 1var sum = 1 + 2 BOMUnicode 字节顺序标记 (BOM) 用来指定代码单元是高字节序还是低字节序。也就是说，是高位在前还是低位在前。UTF-8 不需要 BOM 来表明字节顺序，因为单个字节并不影响字节顺序。 相信不少同学遇到过 BOM 的坑，这里不多说了，切记不要使用 windows 的记事本改代码！]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html模板]]></title>
    <url>%2F2019%2F05%2F27%2FHTML%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[HTML模版指的是团队使用的初始化HTML文件，里面会根据不同平台而采用不一样的设置，一般主要不同的设置就是 mata 标签的设置，以下是 PC 和移动端的 HTML 模版。 HTML5标准模版123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;&lt;meta HTTP-EQUIV="pragma" CONTENT="no-cache"&gt; &lt;meta HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="0"&gt;&lt;title&gt;HTML5标准模版&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 团队约定移动端123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta HTTP-EQUIV="pragma" CONTENT="no-cache"&gt; &lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;&lt;meta HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="0"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" &gt;&lt;meta name="format-detection" content="telephone=no" &gt;&lt;title&gt;移动端HTML模版&lt;/title&gt; &lt;!-- DNS预解析 --&gt;&lt;link rel="dns-prefetch" href=""&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; PC端123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;&lt;meta name="keywords" content="your keywords"&gt;&lt;meta name="description" content="your description"&gt;&lt;meta name="author" content="author,email address"&gt;&lt;meta HTTP-EQUIV="pragma" CONTENT="no-cache"&gt; &lt;meta HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="0"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt;&lt;meta name="renderer" content="ie-stand"&gt;&lt;title&gt;PC端HTML模版&lt;/title&gt;&lt;!-- DNS预解析 --&gt; &lt;link rel="dns-prefetch" href=""&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>模板代码</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语法规范]]></title>
    <url>%2F2019%2F05%2F27%2FJS%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[语言规范JavaScript 是一种客户端脚本语言，这里列出了编写 JavaScript 时需要遵守的规则。 类型 基本类型 字符串 数值 布尔类型 null undefined 123456const foo = 1let bar = foobar = 9console.log(foo, bar) // 1, 9 复杂类型 object array function 123456const foo = [1, 2, 3]const bar = foobar[0] = 9console.log(foo[0], bar[0]) // 9, 9 引用const 和 let 都是块级作用域，var 是函数级作用域 对所有引用都使用 const，不要使用 var 1234567// badvar a = 1var b = 2// goodconst a = 1const b = 2 如果引用是可变动的，则使用 let 1234567891011// badvar count = 1if (count &lt; 10) &#123; count += 1&#125;// goodlet count = 1if (count &lt; 10) &#123; count += 1&#125; 对象 请使用字面量值创建对象 12345// badconst a = new Object&#123;&#125;// goodconst a = &#123;&#125; 别使用保留字作为对象的键值，这样在 IE8 下不会运行 1234567891011// badconst a = &#123; default: &#123;&#125;, // default 是保留字 common: &#123;&#125;&#125;// goodconst a = &#123; defaults: &#123;&#125;, common: &#123;&#125;&#125; 请使用对象方法的简写方式 1234567891011121314151617// badconst item = &#123; value: 1, addValue: function (val) &#123; return item.value + val &#125;&#125;// goodconst item = &#123; value: 1, addValue(val) &#123; return item.value + val &#125;&#125; 请使用对象属性值的简写方式 1234567891011const job = 'FrontEnd'// badconst item = &#123; job: job&#125;// goodconst item = &#123; job&#125; 对象属性值的简写方式要和声明式的方式分组 123456789101112131415161718const job = 'FrontEnd'const department = 'JDC'// badconst item = &#123; sex: 'male', job, age: 25, department&#125;// goodconst item = &#123; job, department, sex: 'male', age: 25&#125; 数组 请使用字面量值创建数组 12345// badconst items = new Array()// goodconst items = [] 向数组中添加元素时，请使用 push 方法 1234567const items = []// baditems[items.length] = 'test'// gooditems.push('test') 使用拓展运算符 ... 复制数组 12345678910111213// badconst items = []const itemsCopy = []const len = items.lengthlet i// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]&#125;// gooditemsCopy = [...items] 使用数组的 map 等方法时，请使用 return 声明，如果是单一声明语句的情况，可省略 return 12345678910111213141516171819202122232425262728293031323334353637383940414243// good[1, 2, 3].map(x =&gt; &#123; const y = x + 1 return x * y&#125;)// good[1, 2, 3].map(x =&gt; x + 1)// badconst flat = &#123;&#125;[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123; const flatten = memo.concat(item) flat[index] = flatten&#125;)// goodconst flat = &#123;&#125;[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123; const flatten = memo.concat(item) flat[index] = flatten return flatten&#125;)// badinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg if (subject === 'Mockingbird') &#123; return author === 'Harper Lee' &#125; else &#123; return false &#125;&#125;)// goodinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg if (subject === 'Mockingbird') &#123; return author === 'Harper Lee' &#125; return false&#125;) 解构赋值 当需要使用对象的多个属性时，请使用解构赋值 12345678910111213141516171819// badfunction getFullName (user) &#123; const firstName = user.firstName const lastName = user.lastName return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125;// goodfunction getFullName (user) &#123; const &#123; firstName, lastName &#125; = user return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125;// betterfunction getFullName (&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125; 当需要使用数组的多个值时，请同样使用解构赋值 12345678const arr = [1, 2, 3, 4]// badconst first = arr[0]const second = arr[1]// goodconst [first, second] = arr 函数需要回传多个值时，请使用对象的解构，而不是数组的解构 123456789101112131415// badfunction doSomething () &#123; return [top, right, bottom, left]&#125;// 如果是数组解构，那么在调用时就需要考虑数据的顺序const [top, xx, xxx, left] = doSomething()// goodfunction doSomething () &#123; return &#123; top, right, bottom, left &#125;&#125;// 此时不需要考虑数据的顺序const &#123; top, left &#125; = doSomething() 字符串 字符串统一使用单引号的形式 &#39;&#39; 12345// badconst department = "JDC"// goodconst department = 'JDC' 字符串太长的时候，请不要使用字符串连接符换行 \，而是使用 + 123const str = '凹凸实验室 凹凸实验室 凹凸实验室' + '凹凸实验室 凹凸实验室 凹凸实验室' + '凹凸实验室 凹凸实验室' 程序化生成字符串时，请使用模板字符串 12345678910const test = 'test'// badconst str = ['a', 'b', test].join()// badconst str = 'a' + 'b' + test// goodconst str = `ab$&#123;test&#125;` 函数 请使用函数声明，而不是函数表达式 123456789// badconst foo = function () &#123; // do something&#125;// goodfunction foo () &#123; // do something&#125; 不要在非函数代码块中声明函数 1234567891011121314// badif (isUse) &#123; function test () &#123; // do something &#125;&#125;// goodlet testif (isUse) &#123; test = () =&gt; &#123; // do something &#125;&#125; 不要使用 arguments，可以选择使用 ... arguments 只是一个类数组，而 ... 是一个真正的数组 12345678910// badfunction test () &#123; const args = Array.prototype.slice.call(arguments) return args.join('')&#125;// goodfunction test (...args) &#123; return args.join('')&#125; 不要更改函数参数的值 123456789// badfunction test (opts) &#123; opts = opts || &#123;&#125;&#125;// goodfunction test (opts = &#123;&#125;) &#123; // ...&#125; 原型 使用 class，避免直接操作 prototype 12345678910111213141516171819202122// badfunction Queue (contents = []) &#123; this._queue = [..contents]&#125;Queue.prototype.pop = function () &#123; const value = this._queue[0] this._queue.splice(0, 1) return value&#125;// goodclass Queue &#123; constructor (contents = []) &#123; this._queue = [...contents] &#125; pop () &#123; const value = this._queue[0] this._queue.splice(0, 1) return value &#125;&#125; 模块 使用标准的 ES6 模块语法 import 和 export 1234567891011// badconst util = require('./util')module.exports = util// goodimport Util from './util'export default Util// betterimport &#123; Util &#125; from './util'export default Util 不要使用 import 的通配符 *，这样可以确保你只有一个默认的 export 12345// badimport * as Util from './util'// goodimport Util from './util' 迭代器 不要使用 iterators 1234567891011121314const numbers = [1, 2, 3, 4, 5]// badlet sum = 0for (let num of numbers) &#123; sum += num&#125;// goodlet sum = 0numbers.forEach(num =&gt; sum += num)// betterconst sum = numbers.reduce((total, num) =&gt; total + num, 0) 对象属性 使用 . 来访问对象属性 12345678910const joke = &#123; name: 'haha', age: 28&#125;// badconst name = joke['name']// goodconst name = joke.name 变量声明 声明变量时，请使用 const、let 关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能会和现有变量冲突，另外，也很难明确该变量的作用域是什么。这里推荐使用 const 来声明变量，我们需要避免全局命名空间的污染。 12345// baddemo = new Demo()// goodconst demo = new Demo() 将所有的 const 和 let 分组 12345678910111213// badlet aconst blet cconst dlet e// goodconst bconst dlet alet clet e Hoisting var 存在变量提升的情况，即 var 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 const 和 let 并不存在这种情况，他们被赋予了 Temporal Dead Zones, TDZ 1234567891011121314151617181920function example () &#123; console.log(notDefined) // =&gt; throws a ReferenceError&#125;function example () &#123; console.log(declareButNotAssigned) // =&gt; undefined var declaredButNotAssigned = true&#125;function example () &#123; let declaredButNotAssigned console.log(declaredButNotAssigned) // =&gt; undefined declaredButNotAssigned = true&#125;function example () &#123; console.log(declaredButNotAssigned) // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned) // =&gt; throws a ReferenceError const declaredButNotAssigned = true&#125; 匿名函数的变量名会提升，但函数内容不会 123456789function example () &#123; console.log(anonymous) // =&gt; undefined anonymous() var anonymous = function () &#123; console.log('test') &#125;&#125; 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会 123456789101112131415161718192021function example() &#123; console.log(named) // =&gt; undefined named() // =&gt; TypeError named is not a function superPower() // =&gt; ReferenceError superPower is not defined var named = function superPower () &#123; console.log('Flying') &#125;&#125;function example() &#123; console.log(named) // =&gt; undefined named() // =&gt; TypeError named is not a function var named = function named () &#123; console.log('named') &#125;&#125; 分号 我们遵循 Standard 的规范，不使用分号。 关于应不应该使用分号的讨论有很多，本规范认为非必要的时候，应该不使用分号，好的 JS 程序员应该清楚场景下是一定要加分号的，相信你也是名好的开发者。 1234567891011// badconst test = 'good';(function () &#123; const str = 'hahaha';&#125;)()// goodconst test = 'good';(() =&gt; &#123; const str = 'hahaha'&#125;)(); 标准特性为了代码的可移植性和兼容性，我们应该最大化的使用标准方法，例如优先使用 string.charAt(3) 而不是 string[3] eval()由于 eval 方法比较 evil，所以我们约定禁止使用该方法 with() {}由于 with 方法会产生神奇的作用域，所以我们也是禁止使用该方法的 for-in 循环推荐使用 for in 语法，但是在对对象进行操作时，容易忘了检测 hasOwnProperty(key)，所以我们启用了 ESLint 的 guard-for-in 选项 对数组进行 for in 的时候，顺序是不固定的 修改内置对象的原型不要修改内置对象，如 Object 和 Array]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注释规范]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[遵循标准HTML注释规范写法应该遵循以下标准： Comments must start with the four character sequence U+003C LESS-THAN SIGN, U+0021 EXCLAMATION MARK, U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS (&lt;!–). Following this sequence, the comment may have text, with the additional restriction that the text must not start with a single “&gt;” (U+003E) character, nor start with a U+002D HYPHEN-MINUS character (-) followed by a “&gt;” (U+003E) character, nor contain two consecutive U+002D HYPHEN-MINUS characters (–), nor end with a U+002D HYPHEN-MINUS character (-). Finally, the comment must be ended by the three character sequence U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN (–&gt;). 必须以4个有序字符开始：编码为 U+003C LESS-THAN SIGN 的小于号, 编码为 U+0021 EXCLAMATION MARK 的感叹号, 编码为 U+002D HYPHEN-MINUS 横线, 编码为 U+002D HYPHEN-MINUS横线 ，即 “&lt;!–” 在此之后是注释内容，注释的内容有以下限制： 不能以单个 “&gt;” (U+003E) 字符开始 不能以由 “-“（U+002D HYPHEN-MINUS）和 ”&gt;” (U+003E) 组合的字符开始，即 “-&gt;” 不能包含两个连续的 U+002D HYPHEN-MINUS 字符，即 “–” 不能以一个 U+002D HYPHEN-MINUS 字符结束，即 “-” 必须以3个有序字符结束：U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN，即 “–&gt;” 标准写法： 1&lt;!--Comment Text--&gt; 错误的写法： 1234567&lt;!--&gt;The Wrong Comment Text--&gt;&lt;!---&gt;The Wrong Comment Text--&gt;&lt;!--The--Wrong--Comment Text--&gt;&lt;!--The Wrong Comment Text---&gt; 参考 www.w3.org #Comments 团队约定单行注释一般用于简单的描述，如某些状态描述、属性描述等 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行 推荐： 12&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt; 不推荐： 12345&lt;div&gt;...&lt;/div&gt;&lt;!-- Comment Text --&gt; &lt;div&gt;&lt;!-- Comment Text --&gt; ...&lt;/div&gt; 模块注释一般用于描述模块的名称以及模块开始与结束的位置 注释内容前后各一个空格字符，&lt;!-- S Comment Text --&gt; 表示模块开始，&lt;!-- E Comment Text --&gt; 表示模块结束，模块与模块之间相隔一行 推荐写法： 1234567891011&lt;!-- S Comment Text A --&gt; &lt;div class="mod_a"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text A --&gt; &lt;!-- S Comment Text B --&gt; &lt;div class="mod_b"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text B --&gt; 不推荐写法： 12345678910&lt;!-- S Comment Text A --&gt;&lt;div class="mod_a"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text A --&gt;&lt;!-- S Comment Text B --&gt; &lt;div class="mod_b"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text B --&gt; 嵌套模块注释当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用 12&lt;!-- S Comment Text --&gt;&lt;!-- E Comment Text --&gt; 而改用 1&lt;!-- /Comment Text --&gt; 注释写在模块结尾标签底部，单独一行。 123456789101112131415&lt;!-- S Comment Text A --&gt;&lt;div class="mod_a"&gt; &lt;div class="mod_b"&gt; ... &lt;/div&gt; &lt;!-- /mod_b --&gt; &lt;div class="mod_c"&gt; ... &lt;/div&gt; &lt;!-- /mod_c --&gt; &lt;/div&gt;&lt;!-- E Comment Text A --&gt;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件]]></title>
    <url>%2F2019%2F05%2F27%2Fvue%E7%BB%84%E4%BB%B6npm%2F</url>
    <content type="text"><![CDATA[使用vue-cli3 创建项目 12vue create my-project目录 有 public src package.json readme.md 等文件 首先需要创建一个 packages 目录，用来存放组件然后将 src 目录改为 examples 用作示例 修改配置启动项目的时候，默认入口文件是 src/main.js将 src 目录改为 examples 之后，就需要重新配置入口文件在根目录下创建一个 vue.config.js 文件1234567891011121314// vue.config.jsmodule.exports = &#123; // 将 examples 目录添加为新的页面 pages: &#123; index: &#123; // page 的入口 entry: 'examples/main.js', // 模板来源 template: 'public/index.html', // 输出文件名 filename: 'index.html' &#125; &#125;&#125; 开发组件之前已经创建了一个 packages 目录，用来存放组件该目录下存放每个组件单独的开发目录，和一个 index.js 整合所有组件，并对外导出每个组件都应该归类于单独的目录下，包含其组件源码目录 src，和 index.js 便于外部引用123456789// packages/textarea/index.js// 导入组件，组件必须声明 nameimport Textarea from './main.vue'// 为组件添加 install 方法，用于按需引入Textarea.install = function (Vue) &#123; Vue.component(Textarea.name, Textarea)&#125;export default Textarea 打包组件vue-cli 3.x 提供了一个库文件打包命令主要需要四个参数： target: 默认为构建应用，改为 lib 即可启用构建库模式 name: 输出文件名 dest: 输出目录，默认为 dist，这里我们改为 lib entry: 入口文件路径，默认为 src/App.vue，这里改为 packages/index.js123456// pageage.json&#123; "scripts": &#123; "lib": "vue-cli-service build --target lib --name tag-textarea --dest lib packages/index.js" &#125;&#125; 然后执行 npm run lib 命令，编译组件 准备发布123456789首先需要在 package.json 添加组件信息name: 包名，该名不能和已有的名称冲突；version: 版本号，不能和历史版本号相同；description: 简介；main: 入口文件，应指向编译后的包文件；keyword：关键字，以空格分割；author：作者；private：是否私有，需要修改为 false 才能发布到 npm；license：开源协议。 然后创建 .npmignore 文件，设置忽略文件该文件的语法和 .gitignore 的语法一样，设置发布到 npm 时忽略哪些目录或文件123456789101112131415161718192021222324.DS_Storenode_modules/examples/packages/public/vue.config.jsbabel.config.js*.map*.html# local env files.env.local.env.*.local# Log filesnpm-debug.log*yarn-debug.log*yarn-error.log*# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln*.sw* 发布方法同普通的发布]]></content>
      <categories>
        <category>NPM</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML规范]]></title>
    <url>%2F2019%2F05%2F27%2Fhtml%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[DOCTYPE 声明一个DOCTYPE必须包含以下部分，并严格按照顺序出现： A string that is an ASCII case-insensitive match for the string “&lt;!DOCTYPE”. One or more space characters. A string that is an ASCII case-insensitive match for the string “html”. Optionally, a DOCTYPE legacy string or an obsolete permitted DOCTYPE string (defined below). Zero or more space characters. A “&gt;” (U+003E) character. 一个ASCII字符串 “&lt;!DOCTYPE” ，大小写不敏感 一个或多个空白字符 一个ASCII字符串”html”，大小写不敏感 一个可选的历史遗留的DOCTYPE字符串 （DOCTYPE legacy string），或者一个可选的已过时但被允许的DOCTYPE字符串 （obsolete permitted DOCTYPE string） 字符串 一个或多个空白字符 一个编码为 U+003E 的字符 “&gt;” 团队约定HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明： 1&lt;!DOCTYPE html&gt; 更多关于 DOCTYPE声明#The DOCTYPE 页面语言LANGLang属性的取值应该遵循互联网工程任务组–IETF（The Internet Engineering Task Force）制定的关于语言标签的文档 BCP 47 - Tags for Identifying Languages 团队约定推荐使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值1&lt;html lang="zh-CN"&gt; 更多地区语言参考： zh-SG 中文 (简体, 新加坡) 对应 cmn-Hans-SG 普通话 (简体, 新加坡) zh-HK 中文 (繁体, 香港) 对应 cmn-Hant-HK 普通话 (繁体, 香港) zh-MO 中文 (繁体, 澳门) 对应 cmn-Hant-MO 普通话 (繁体, 澳门) zh-TW 中文 (繁体, 台湾) 对应 cmn-Hant-TW 普通话 (繁体, 台湾) 已废弃不推荐使用的 Languages Tags以下写法已于 2009 年废弃，请勿使用（cmn、wuu、yue、gan 等已由 2005 年的 extlang 升级到 2009 年的 language）： zh-cmn, zh-cmn-Hans, zh-cmn-Hant, zh-wuu, zh-yue, zh-gan 以下写法已于 2009 年废弃，不推荐使用： zh-Hans, zh-Hans-CN, zh-Hans-SG, zh-Hans-HK, zh-Hans-MO, zh-Hans-TW, zh-Hant, zh-Hant-CN, zh-Hant-SG, zh-Hant-HK, zh-Hant-MO, zh-Hant-TW 更多已废弃 Languages Tags 参考 IANA Language Subtag Registry 里面的 “Type: redundant“” 更多关于 Languages Tags ：W3C Language tags in HTML and XML 网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？ CHARSET Because the character sets in ISO-8859 was limited in size, and not compatible in multilingual environments, the Unicode Consortium developed the Unicode Standard. The Unicode Standard covers (almost) all the characters, punctuations, and symbols in the world. Unicode enables processing, storage, and transport of text independent of platform and language. The default character encoding in HTML-5 is UTF-8. 因为 ISO-8859 中字符集大小是有限的，且在多语言环境中不兼容，所以 Unicode 联盟开发了 Unicode 标准。 Unicode 标准覆盖了（几乎）所有的字符、标点符号和符号。 Unicode 使文本的处理、存储和运输，独立于平台和语言。 HTML-5 中默认的字符编码是 UTF-8 参阅 HTML Unicode (UTF-8) Reference 团队约定一般情况下统一使用 “UTF-8” 编码1&lt;meta charset="UTF-8"&gt; 由于历史原因，有些业务可能会使用 “GBK” 编码 1&lt;meta charset="GBK"&gt; 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 IETF对UTF-8的定义，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。 更多关于UTF-8写法: UTF8 or UTF-8? GBK：Application of IANA Charset Registration for GBK Charset ：character-encoding-declaration 元素及标签闭合HTML元素共有以下5种： 空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr 原始文本元素：script、style RCDATA元素：textarea、title 外来元素：来自MathML命名空间和SVG命名空间的元素。 常规元素：其他HTML允许的元素都称为常规元素。 元素标签的闭合应遵循以下原则： Tags are used to delimit the start and end of elements in the markup. Raw text, escapable raw text, and normal elements have a start tag to indicate where they begin, and an end tag to indicate where they end. The start and end tags of certain normal elements can be omitted, as described below in the section on optional tags. Those that cannot be omitted must not be omitted. Void elements only have a start tag; end tags must not be specified for void elements. Foreign elements must either have a start tag and an end tag, or a start tag that is marked as self-closing, in which case they must not have an end tag. 原始文本元素、RCDATA元素以及常规元素都有一个开始标签来表示开始，一个结束标签来表示结束。 某些元素的开始和结束标签是可以省略的，如果规定标签不能被省略，那么就绝对不能省略它。 空元素只有一个开始标签，且不能为空元素设置结束标签。 外来元素可以有一个开始标签和配对的结束标签，或者只有一个自闭合的开始标签，且后者情况下该元素不能有结束标签。 团队约定为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定： 所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。 空元素标签都不加 “/” 字符 推荐： 123456&lt;div&gt; &lt;h1&gt;我是h1标题&lt;/h1&gt; &lt;p&gt;我是一段文字，我有始有终，浏览器能正确解析&lt;/p&gt;&lt;/div&gt; &lt;br&gt; 不推荐： 123456&lt;div&gt; &lt;h1&gt;我是h1标题&lt;/h1&gt; &lt;p&gt;我是一段文字，我有始无终，浏览器亦能正确解析&lt;/div&gt;&lt;br/&gt; 更多关于元素及标签关闭：#Elements 书写风格HTML代码大小写HTML标签名、类名、标签属性和大部分属性值统一用小写 推荐： 1&lt;div class="demo"&gt;&lt;/div&gt; 不推荐： 123&lt;div class="DEMO"&gt;&lt;/div&gt; &lt;DIV CLASS="DEMO"&gt;&lt;/DIV&gt; HTML文本、CDATA、JavaScript、meta标签某些属性等内容可大小写混合 12345678910111213141516&lt;!-- 优先使用 IE 最新版本和 Chrome Frame --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt;&lt;!-- HTML文本内容 --&gt;&lt;h1&gt;I AM WHAT I AM &lt;/h1&gt;&lt;!-- JavaScript 内容 --&gt;&lt;script type="text/javascript"&gt; var demoName = 'demoName'; ...&lt;/script&gt; &lt;!-- CDATA 内容 --&gt;&lt;script type="text/javascript"&gt;&lt;![CDATA[...]]&gt;&lt;/script&gt; 类型属性不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含 推荐： 12&lt;link rel="stylesheet" href="" &gt;&lt;script src=""&gt;&lt;/script&gt; 不推荐： 12&lt;link rel="stylesheet" type="text/css" href="" &gt;&lt;script type="text/javascript" src="" &gt;&lt;/script&gt; 元素属性 元素属性值使用双引号语法 元素属性值可以写上的都写上 推荐： 123&lt;input type="text"&gt; &lt;input type="radio" name="name" checked="checked" &gt; 不推荐： 1234&lt;input type=text&gt; &lt;input type='text'&gt; &lt;input type="radio" name="name" checked &gt; 更多关于元素属性：#Attributes 特殊字符引用 In certain cases described in other sections, text may be mixed with character references. These can be used to escape characters that couldn’t otherwise legally be included in text. 文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。 在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 推荐： 1&lt;a href="#"&gt;more&amp;gt;&amp;gt;&lt;/a&gt; 不推荐： 1&lt;a href="#"&gt;more&gt;&gt;&lt;/a&gt; 更多关于符号引用：#Character references 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 123&lt;div class="jdc"&gt; &lt;a href="#"&gt;&lt;/a&gt;&lt;/div&gt; 纯数字输入框使用 type=&quot;tel&quot; 而不是 type=&quot;number&quot; 1&lt;input type="tel"&gt; 代码嵌套元素嵌套规范，每个块状元素独立一行，内联元素可选 推荐： 12345&lt;div&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 不推荐： 1234567&lt;div&gt; &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/p&gt; 段落元素与标题元素只能嵌套内联元素 推荐： 12&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 不推荐： 12&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO的使用]]></title>
    <url>%2F2019%2F05%2F26%2FHEXO%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1234$ hexo deployhexo clean hexo g hexo d More info: Deployment 编辑要求必须包含title、date、categories、tags]]></content>
      <categories>
        <category>使用说明</category>
      </categories>
      <tags>
        <tag>user</tag>
      </tags>
  </entry>
</search>
