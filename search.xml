<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[typescript对象]]></title>
    <url>%2F2019%2F07%2F30%2Ftypescript%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[记下TS对象的属性及方法 Numbervar num = new Number(value)对象属性MAX_VALUE 可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 “Infinity”。MIN_VALUE 可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0。NaN 非数字NEGATIVE_INFINITY 负无穷大，溢出时返回该值。该值小于 MIN_VALUE。POSITIVE_INFINITY 正无穷大，溢出时返回该值。该值大于 MAX_VALUE。prototype Number 对象的静态属性。使您有能力向对象添加属性和方法。constructor 返回对创建此对象的 Number 函数的引用对象方法toExponential() 把对象的值转换为指数计数法。toFixed() 把数字转换为字符串，并对小数点指定位数。toLocaleString() 把数字转换为字符串，使用本地数字格式顺序。toPrecision() 把数字格式化为指定的长度。toString() 把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。valueOf() 返回一个 Number 对象的原始数字值。 Stringvar txt = new String(&quot;string&quot;);对象属性constructor 对创建该对象的函数的引用。length 长度prototype 同上对象方法charAt() 指定位置的字符 从0开始charCodeAt() 指定位置字符的编码 从0 开始concat() 拼接字符串indexOf() 查找字符的位置。没找到返回-1lastIndexOf() 一个一个向下找localeCompare()123var str1 = new String( &quot;This is beautiful string&quot; );var index = str1.localeCompare( &quot;This is beautiful string&quot;); console.log(&quot;localeCompare first :&quot; + index ); // 0 match() 查找找到一个或多个正则表达式的匹配。replace() 替换与正则表达式匹配的子串search() 检索与正则表达式相匹配的值slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。split() 分割成数组substr() 从起始索引号提取字符串中指定数目的字符。substring() 提取字符串中两个指定的索引号之间的字符。toLocaleLowerCase() 根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射。toLocaleUpperCase() 据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射。toLowerCase() 小写toString() 字符toUpperCase() 大写valueOf() 指定位置的值 从0开始 Arrayvar array_name[:datatype];var arr_names:number[] = new Array(4)数组解构123456var arr:number[] = [12,13] var[x,y] = arr // 将数组的两个元素赋值给变量 x 和 yconsole.log(x) console.log(y)// 12// 13 数组迭代12345678910var j:any; var nums:number[] = [1001,1002,1003,1004] for(j in nums) &#123; console.log(nums[j]) &#125;// 1001// 1002// 1003// 1004 多维数组1234567var multi:number[][] = [[1,2,3],[23,24,25]] console.log(multi[0][0]) console.log(multi[0][1]) console.log(multi[0][2]) console.log(multi[1][0]) console.log(multi[1][1]) console.log(multi[1][2]) 数组方法 concat() 连接两个或更多的数组，并返回结果。 every(element, index, array) 检测数值元素的每个元素是否都符合条件。 filter(element, index, array) 检测数值元素，并返回符合条件所有元素的数组。 forEach(value) 数组每个元素都执行一次回调函数。 indexOf() 搜索数组中的元素，并返回它所在的位置。没找到返回-1 join() 把数组的所有元素放入一个字符串。 lastIndexOf() 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。元组var mytuple = [10,&quot;Runoob&quot;]访问元组 元组中元素使用索引来访问，第一个元素的索引值为 0，第二个为 1，以此类推第 n 个为 n-1push() 向元组添加元素，添加在最后面。pop() 从元组中移除元素（最后一个），并返回移除的元素。更新元组12345var mytuple = [10, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Google&quot;]; // 创建一个元组console.log(&quot;元组的第一个元素为：&quot; + mytuple[0]) // 更新元组元素mytuple[0] = 121 console.log(&quot;元组中的第一个元素更新为：&quot;+ mytuple[0]) 解构元组123456var a =[10,&quot;Runoob&quot;] var [b,c] = a console.log( b ) console.log( c )// 10// Runoob 联合类型Type1|Type2|Type312345var val:string|number val = 12 console.log(&quot;数字为 &quot;+ val) val = &quot;Runoob&quot; console.log(&quot;字符串为 &quot; + val) 数组声明为联合类型123456789101112131415var arr:number[]|string[]; var i:number; arr = [1,2,4] console.log(&quot;**数字数组**&quot;) for(i = 0;i&lt;arr.length;i++) &#123; console.log(arr[i]) &#125; arr = [&quot;Runoob&quot;,&quot;Google&quot;,&quot;Taobao&quot;] console.log(&quot;**字符串数字**&quot;) for(i = 0;i&lt;arr.length;i++) &#123; console.log(arr[i]) &#125; 接口interface interface_name { }12345678910111213141516171819202122232425262728293031323334interface IPerson &#123; firstName:string, lastName:string, sayHi: ()=&gt;string &#125; var customer:IPerson = &#123; firstName:&quot;Tom&quot;, lastName:&quot;Hanks&quot;, sayHi: ():string =&gt;&#123;return &quot;Hi there&quot;&#125; &#125; console.log(&quot;Customer 对象 &quot;) console.log(customer.firstName) console.log(customer.lastName) console.log(customer.sayHi()) var employee:IPerson = &#123; firstName:&quot;Jim&quot;, lastName:&quot;Blakes&quot;, sayHi: ():string =&gt;&#123;return &quot;Hello!!!&quot;&#125; &#125; console.log(&quot;Employee 对象 &quot;) console.log(employee.firstName) console.log(employee.lastName)// Customer 对象// Tom// Hanks// Hi there// Employee 对象// Jim// Blakes 接口和数组123456789101112interface namelist &#123; [index:number]:string &#125; var list2:namelist = [&quot;John&quot;,1,&quot;Bran&quot;] / 错误元素 1 不是 string 类型interface ages &#123; [index:string]:number &#125; var agelist:ages; agelist[&quot;John&quot;] = 15 // 正确 agelist[2] = &quot;nine&quot; // 错误 接口继承Child_interface_name extends super_interface_name // 单个Child_interface_name extends super_interface1_name, super_interface2_name,…,super_interfaceN_name // 多个1234567891011interface IParent1 &#123; v1:number &#125; interface IParent2 &#123; v2:number &#125; interface Child extends IParent1, IParent2 &#123; &#125; var Iobj:Child = &#123; v1:12, v2:23&#125; console.log(&quot;value 1: &quot;+Iobj.v1+&quot; value 2: &quot;+Iobj.v2) 类class class_name { // 类作用域}1234567891011121314class Car &#123; // 字段 engine:string; // 构造函数 constructor(engine:string) &#123; this.engine = engine &#125; // 方法 disp():void &#123; console.log(&quot;发动机为 : &quot;+this.engine) &#125; &#125; 创建实例化对象1234567var object_name = new class_name([ arguments ])var obj = new Car(&quot;Engine 1&quot;)// 访问属性obj.field_name // 访问方法obj.function_name() 类的继承12345678910111213141516class Shape &#123; Area:number constructor(a:number) &#123; this.Area = a &#125; &#125; class Circle extends Shape &#123; disp():void &#123; console.log(&quot;圆的面积: &quot;+this.Area) &#125; &#125; var obj = new Circle(223); obj.disp() 需要注意的是子类只能继承一个父类，TypeScript 不支持继承多个类，但支持多重继承，如下实例：12345678910class Root &#123; str:string; &#125; class Child extends Root &#123;&#125; class Leaf extends Child &#123;&#125; // 多重继承，继承了 Child 和 Root 类 var obj = new Leaf(); obj.str =&quot;hello&quot; console.log(obj.str) 继承类的方法重写123456789101112class PrinterClass &#123; doPrint():void &#123; console.log(&quot;父类的 doPrint() 方法。&quot;) &#125; &#125; class StringPrinter extends PrinterClass &#123; doPrint():void &#123; super.doPrint() // 调用父类的函数 console.log(&quot;子类的 doPrint()方法。&quot;) &#125; &#125; static 关键字static 关键字用于定义类的数据成员（属性和方法）为静态的，静态成员可以直接通过类名调用。12345678910class StaticMem &#123; static num:number; static disp():void &#123; console.log(&quot;num 值为 &quot;+ StaticMem.num) &#125; &#125; StaticMem.num = 12 // 初始化静态变量StaticMem.disp() // 调用静态方法 instanceof 运算符1234class Person&#123; &#125; var obj = new Person() var isPerson = obj instanceof Person; console.log(&quot;obj 对象是 Person 类实例化来的吗？ &quot; + isPerson); 访问控制修饰符 public（默认） : 公有，可以在任何地方被访问。 protected : 受保护，可以被其自身以及其子类和父类访问。 private : 私有，只能被其定义所在的类访问。类和接口:类可以实现接口，使用关键字 implements，并将 interest 字段作为类的属性使用。12345678910111213141516interface ILoan &#123; interest:number &#125; class AgriLoan implements ILoan &#123; interest:number rebate:number constructor(interest:number,rebate:number) &#123; this.interest = interest this.rebate = rebate &#125; &#125; var obj = new AgriLoan(10,1) console.log(&quot;利润为 : &quot;+obj.interest+&quot;，抽成为 : &quot;+obj.rebate ) 对象12345678var object_name = &#123; key1: &quot;value1&quot;, // 标量 key2: &quot;value&quot;, key3: function() &#123; // 函数 &#125;, key4:[&quot;content1&quot;, &quot;content2&quot;] //集合&#125; 命名空间1234namespace SomeNameSpaceName &#123; export interface ISomeInterfaceName &#123; &#125; export class SomeClassName &#123; &#125; &#125; 以上定义了一个命名空间 SomeNameSpaceName，如果我们需要在外部可以调用 SomeNameSpaceName 中的类类和接口，则需要在类和接口添加 export 关键字。要在另外一个命名空间调用语法格式为：SomeNameSpaceName.SomeClassName;如果一个命名空间在一个单独的 TypeScript 文件中，则应使用三斜杠 /// 引用它，语法格式如下：/// &lt;reference path = &quot;SomeFileName.ts&quot; /&gt;嵌套命名空间1234567namespace namespace_name1 &#123; export namespace namespace_name2 &#123; export class class_name &#123; &#125; &#125; &#125;// 嵌套使用namespace_name1.namespace_name2.class_name 模块和JS一致模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的JavaScript模块加载器是服务于 Node.js 的 CommonJS 和服务于 Web 应用的 Require.js。 声明文件引入第三方js文件时，declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对12declare var jQuery: (selector: string) =&gt; any;jQuery(&apos;#foo&apos;); 声明文件以 .d.ts 为后缀TypeScript 引入声明文件语法格式：/// &lt;reference path = &quot; runoob.d.ts&quot; /&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学typeScript]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%88%9D%E5%AD%A6typeScript%2F</url>
    <content type="text"><![CDATA[初学typeScript 基础类型 any 声明为 any 的变量可以赋予任意类型的值 number 双精度 64 位浮点值。它可以用来表示整数和分数。 boolean 数组 12345// 在元素类型后面加上[]let arr: number[] = [1, 2];// 或者使用数组泛型let arr: Array&lt;number&gt; = [1, 2]; 元组 1234let x: [string, number];x = [&apos;Runoob&apos;, 1]; // 运行正常x = [1, &apos;Runoob&apos;]; // 报错console.log(x[0]); // 输出 Runoob 枚举 123enum Color &#123;Red, Green, Blue&#125;;let c: Color = Color.Blue;console.log(c); // 输出 2 void 123function hello(): void &#123; alert(&quot;Hello Runoob&quot;);&#125; null undefined never never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。意味着声明为 never 类型的变量只能被 never 类型所赋值123456789101112131415161718192021let x: never;let y: number;// 运行错误，数字类型不能转为 never 类型x = 123;// 运行正确，never 类型可以赋值给 never类型x = (()=&gt;&#123; throw new Error(&apos;exception&apos;)&#125;)();// 运行正确，never 类型可以赋值给 数字类型y = (()=&gt;&#123; throw new Error(&apos;exception&apos;)&#125;)();// 返回值为 never 的函数可以是抛出异常的情况function error(message: string): never &#123; throw new Error(message);&#125;// 返回值为 never 的函数可以是无法被执行到的终止点的情况function loop(): never &#123; while (true) &#123;&#125;&#125; 变量的命名规则命名变量名称可以包含数字和字母。除了下划线 _ 和美元 $ 符号外，不能包含其他特殊字符，包括空格。变量名不能以数字开头。四种方式来声明变量var [变量名] : [类型] = 值; 声明变量的类型及初始值：var [变量名] : [类型]; 声明变量的类型及但没有初始值，变量值会设置为 undefined：var [变量名] = 值; 声明变量并初始值，但不设置类型类型，该变量可以是任意类型：var [变量名]; 声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为 undefined： 类型断言类型断言可以用来手动指定一个值的类型，即允许变量从一种类型更改为另一种类型。&lt;类型&gt;值值 as 类型12var str = &apos;1&apos; var str2:number = &lt;number&gt; &lt;any&gt; str 类型推断当类型没有给出时，TypeScript 编译器利用类型推断来推断类型。如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 any 类型。1234var num = 2; // 类型推断为 numberconsole.log(&quot;num 变量的值为 &quot;+num); num = &quot;12&quot;; // 编译错误console.log(num); 变量作用域 全局作用域 − 全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。 类作用域 − 这个变量也可以称为 字段。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。 局部作用域 − 局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。12345678910111213141516var global_num = 12 // 全局变量class Numbers &#123; num_val = 13; // 类变量 static sval = 10; // 静态变量 storeNum():void &#123; var local_num = 14; // 局部变量 &#125; &#125; console.log(&quot;全局变量为: &quot;+global_num) console.log(Numbers.sval) // 静态变量var obj = new Numbers(); console.log(&quot;类变量: &quot;+obj.num_val)// 全局变量为: 12// 10// 类变量: 13 类型运算符typeof 运算符 函数在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？123456789101112131415161718function buildName(firstName: string, lastName: string) &#123; return firstName + &quot; &quot; + lastName;&#125; let result1 = buildName(&quot;Bob&quot;); // 错误，缺少参数let result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // 错误，参数太多了let result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // 正确function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + &quot; &quot; + lastName; else return firstName;&#125; let result1 = buildName(&quot;Bob&quot;); // 正确let result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // 错误，参数太多了let result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // 正确 我们也可以设置参数的默认值，这样在调用函数的时候，如果不传入该参数的值，则使用默认参数，语法格式为：12function function_name(param1[:type],param2[:type] = default_value) &#123; &#125; 注意：参数不能同时设置为可选和默认。有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。剩余参数语法允许我们将一个不确定数量的参数作为一个数组传入。12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125; let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;); TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：123var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;); var x = myFunction(4, 3); console.log(x); 重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。123456789// 参数类型不同：function disp(string):void; function disp(number):void;// 参数数量不同：function disp(n1:number):void; function disp(x:number,y:number):void;// 参数类型顺序不同：function disp(n1:number,s1:string):void; function disp(s:string,n:number):void;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户认证]]></title>
    <url>%2F2019%2F07%2F27%2F%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[主要讲讲JWT 和 session session与cookie优缺点优点 服务器可以主动清除sessionsession保存在服务器端结合cookie使用，较为灵活，兼容性较好缺点cookie + session在跨域场景表现并不好如果是分布式部署，需要做多机共享session机制，实现方法可将session存储到数据库中或者redis中基于 cookie 的机制很容易被 CSRF查询session信息可能会有数据库查询操作cookie存储大小约为4kb JWT认证JWT基本上由.分隔的三部分组成，分别是头部，有效载荷和签名优点可以实现多台服务的信息共享缺点JWT时效性比较差JWT TOKEN一般数据比较长解决办法将JWT token 存入redis中，用户传入是，先在redis中通过简单的token获取全部的token。然后在进行操作，同时退出登录，权限操作的时候也可快捷的更改用户的当前状态。 总结对于用户的认证，使用JWT TOKEN更加方便。但是不要把太多的用户信息存储在JWT-TOKEN中去，我们可以采用结合的方法，对于用户的一些常用信息可以存储在cookie中去，采用互相结合的办法。但是重要的是，用户的关键信息都需要做加密处理。这样才能保证用户的信息安。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>用户认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全]]></title>
    <url>%2F2019%2F07%2F27%2Fweb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[主要讲述如何预防非法获取资源（用户信息，数据库资料）等 XSS攻击 （Cross site script）现象 DOM节点显示内容（script）。 利用DOM属性加载脚本。 js中会产生JS攻击 富文本保存产生标签 解决方法 将显示到DOM中的数据进行转义； 将显示在属性中的字符串进行转义 将JS中需要的进行JSON.stringfy 使用白名单来保留部分标签和属性 CSP () 一些库 xss cheerio CSRF 跨站请求伪造(Cross site Request Forggy)方法 sameSize (strict Lax) 不允许第三方网站携带cookie httpOnly 只允许http读取cookie。 验证码 （ccap） token referer 禁止第三方网站 加密库crypto 点击劫持原理将目标网站通过iframe 设置透明度为0，覆盖在当前网站上。用户看到的为外层的点击按钮。点击以后 实际点击为iframe中的按钮。 方法 禁止内嵌（JS办法以及X-FRAME_OPTIONS） sandbox （iframe属性） 验证信息等 HTTP传输窃听传输链路窃听篡改traceroute www.baidu.com (查看所有节点 ) 途径 插入广告 重定向网站 无法防御的XSS和CSRF攻击 防范 https防止 加密关键信息 文件上传通过读取文件内容类型设置文件读写权限防止文件执行 系统安全规范覆盖安全测试内容代码安全代码及配置文件中不能存在明文用户名及口令秘钥；代码及配置文件中不能存在个人敏感数据（如电话号码、身份证号等）；加密至少采用强度AES256；HASH算法: 至少采用强度HMAC-SHA512；密钥信息不能存储在一个地方，应分别存储在三个部分：数据库、配置文件、代码中；数据库连接 用户名、密码 需要使用加密数据（druid 自带，参考： 数据库链接加密）；敏感信息不能以GET方式提交； 代码注释源码和注释中不存在数据库版本信息； 源码和注释中不存在项目版本编号； 源码和注释中不存在文件或者项目的绝对路径； 错误请求返回不包含敏感信息（如：服务器版本）； 源码和注释中不存在服务器路径信息； 源码和注释中不存在打印程序的详细堆栈信息（e.printStackTrace()）； 源码和注释中不存在定义范围的敏感数据（如password:123456）； 日志/抛异常 日志不能打印明文的个人敏感信息（如：用户名密码、个人电话、个人邮箱、token等）；不能打印堆栈信息； 数据库存储加密数据库存储的敏感字段必须加密；敏感信息包括：订单/运单类：电话，地址，月结卡号；客户类：电话，地址，证件号；员工类：证件号，银行卡，薪资福利，绩效；海外数据：证件号，邮箱，电话，地址；权限类：密码、密钥； 密码复杂度必须由大小、小写、数字等组成； 不能与用户名相似（如，不能包含用户名正反写大小等）； 密码长度要求，最小8位；登录业务系统必须要有验证码机制； 敏感数据脱敏保护非客户需要将敏感信息脱敏；可以采用点击小眼睛开关的方式显示脱敏信息；点击脱敏开关查看敏感信息，需要记录日志；小眼睛操作需记录相关日志（操作人，操作对象，操作时间）； 客户看到自己的数据可以不脱敏，可以根据业务要求设定；敏感信息包括：订单/运单类：电话，地址，月结卡号；客户类：电话，地址，证件号；员工类：证件号，银行卡，薪资福利，绩效；海外数据：证件号，邮箱，电话，地址；权限类：密码、密钥； 接口安全要求应用系统接口调用，需进行访问控制； 信息系统接口调用，必须在信息系统接口上进行认证； 对于部署在公司内网信息系统之间的接口调用，必须设置IP地址级别的访问控制；对于部署在公司内网的信息系统和部署在外部的信息系统之间的接口调用，在我司信息系统接口上必须使用数字签名、Oauth认证等方式对调用的信息系统进行认证，确保对接口调用的鉴权，鉴权信息的保密，以及数据防篡改；接口调用信息数据流必须经过过滤，过滤多余的字段，仅传递业务必须的字段；接口调用必须做权限控制，仅允许操作和本业务相关的数据，不允许传递多余的字段；对于部署在公司内网的信息系统和部署在外部的信息系统之间的接口调用传递的涉密数据，必须经过加密传递，对于涉及与金钱有关的涉密数据必须采用加密算法确保数据的完整性；接口调用中使用密码进行认证的，必须使用强密码，且每半年修改一次密码；接口调用需要设置最高频率，防止调用频率过高对信息系统的性能影响，降低拒绝服务攻击的风险；公司内网信息系统和外网信息系统之间传递数据必须经过信息系统之间的接口调用，禁止通过后台数据库直接进行数据传递； 系统部署使用SSL证书，使用https替换掉http请求；]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loading]]></title>
    <url>%2F2019%2F07%2F20%2Floading%2F</url>
    <content type="text"><![CDATA[自己封装的loading。 LOADING自己实现的一个全局LOADING动画。可以用来加载等。 属性 start 百分比 正整数 默认为0 speed 速度 ’slow，littleSlow，normal，fast‘ 默认为normal autoClose 自动关闭 布尔值 true或者false 默认为false方法 start 开启动画 set 设置参数 支持传入（start、speed、autoClose）对象传入 end 结束 restart 重启 设置初始 0% pause 暂停代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 (function(root, factory) &#123; if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; define(factory); &#125; else if (typeof exports === &apos;object&apos;) &#123; module.exports = factory(); &#125; else &#123; root.cwsProgress = factory(); &#125;&#125;)(window, function() &#123; var cwsProgress = &#123; // 版本号 version:&apos;0.0.0&apos;, // 保存DOM元素，用来使用 dom:null, // 保存计时器 timeId:null, // 设置，speed：速度，start：起始的百分比 settings:&#123; speed:&quot;normal&quot;, start:0, antoClose:false &#125;, level:&#123; slow:2, littleSlow:5, normal:10, fast:25 &#125;, // 开启loading start:function()&#123; if(this.hasDom())&#123; this.dom = document.getElementById(&apos;cwsprogress&apos;) this.dom.style.display = &apos;block&apos; &#125;else&#123; var dom=document.createElement(&quot;div&quot;) dom.id = &quot;cwsprogress&quot; dom.innerHTML = this.tempalte(this.settings.start) dom.setAttribute(&quot;style&quot;,&quot;position: fixed;width: 100%;height: 100%;top:0;left:0;background-color: rgba(0,0,0,0.2)&quot;) dom.innerHTML = this.tempalte(this.settings.start) document.body.appendChild(dom) this.dom = dom &#125; // 调用计时器 if(this.timeId)&#123; clearTimeout(this.timeId) &#125; this.stepFun() return this &#125;, // 继续调用 reStart()&#123; this.settings.start = 0 this.start() return this &#125;, // 使用计时器 stepFun()&#123; this.settings.start += parseInt(Math.random() * this.level[this.settings.speed]) if(this.settings.start &gt;= 100)&#123; if(this.settings.antoClose)&#123; this.end() &#125; &#125;else&#123; this.changePecent() this.timeId = setTimeout(this.stepFun.bind(this),200) &#125; &#125;, // 改变百分比进度 changePecent()&#123; if(this.hasDom())&#123; document.getElementById(&apos;processDiv&apos;).style.width = this.settings.start + &quot;%&quot; document.getElementById(&apos;processSpan&apos;).innerHTML = &apos;努力中...&apos; + this.settings.start + &apos;%&apos; &#125;else&#123; console.log(&quot;DOM已经被移除了&quot;) &#125; &#125;, // 结束loading end:function()&#123; clearTimeout(this.timeId) if(this.hasDom())&#123; this.dom.style.display = &apos;none&apos; &#125; return this &#125;, // 暂停定时器 pause()&#123; clearTimeout(this.timeId) &#125;, // 设置参数 set:function(config)&#123; if(Object.prototype.toString.call(config) == &quot;[object Object]&quot;)&#123; this.settings.start = parseInt(config.start) || 0 this.settings.speed = config.speed || &apos;normal&apos; this.settings.antoClose = !!config.antoClose if(this.settings.start &gt;= 100 || this.settings.start &lt;= 0)&#123; console.log(&quot;请传入0-100的数字&quot;) return this &#125; this.changePecent() if(!this.level[this.settings.speed])&#123; console.log(&quot;速度等级:slow、littleSlow、normal、fast&quot;) return this &#125; &#125;else&#123; console.log(&apos;请传入一个对象&apos;) &#125; return this &#125;, // 组装模板 tempalte:function(percent)&#123; var pre = parseInt(percent) || 0 var str = &apos;&apos; str += &apos;&lt;div style=&quot;width: 40%;min-width: 200px;max-width: 600px;position: absolute;top: 50%;left: 50%;transform: translate(-50%,-50%);&quot;&gt;&apos; str += &apos;&lt;img src=&quot;http://hd-file01-ms.sf-express.com/uploads/f/f/e/ffeef69ebcacf3a50636f6f56c86761b.gif&quot; style=&quot;width: 100%&quot;&gt;&apos; str += &apos;&lt;div style=&quot;margin-top: 25px;position: relative;&quot;&gt;&apos; str += &apos;&lt;div style=&quot;width: 100%;height: 30px;background-color: #eee;border-radius: 30px;overflow: hidden;&quot;&gt;&apos; str += &apos;&lt;div id=&quot;processDiv&quot; style=&quot;width:&apos;+percent+&apos;%;height:100%;background-color: #231815&quot;&gt;&lt;/div&gt;&lt;/div&gt;&apos; str += &apos;&lt;span style=&quot;position: absolute;top: -10px;left: 50%;transform: translate(-50%,-100%); font-size: 16px;color: #050505;&quot; id=&quot;processSpan&quot;&gt;加载中...&apos;+percent+&apos;%&lt;/span&gt;&apos; str += &apos;&lt;/div&gt;&lt;/div&gt;&apos; return str &#125;, // 判断是否包含DOM hasDom:function()&#123; return !!document.getElementById(&apos;cwsprogress&apos;) &#125; &#125; return cwsProgress&#125;)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS队列]]></title>
    <url>%2F2019%2F07%2F16%2FJS%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[讲的基本的JS队列（事件循环） JS运行Javascript 是单线程，所有同步任务都在主线程上执行，形成一个执行栈(Execution Context Stack)。而执行同步任务的时候，会发出一些异步操作，这些异步操作并不会影响主进程的执行，一旦执行栈中的所有同步任务执行完毕，引擎就会读取任务队列，按照时间顺序执行. 任务宏任务：script(整体代码)、setTimeout、setInterval、I/O、事件、postMessage、 MessageChannel、setImmediate (Node.js)微任务：Promise.then、 MutaionObserver、process.nextTick (Node.js)12345678910111213141516171819const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve(5) console.log(2)&#125;).then(val =&gt; &#123; console.log(val)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4)setTimeout(function() &#123; console.log(6)&#125;)// 执行结果124536 执行顺序 全局队列（script）执行完毕后，开始循环从 微队列-&gt;宏队列-&gt;微队列-&gt;宏队列…这种执行顺序执行下去 当一个宏观队列执行完毕，立刻执行最近添加的微观队列。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节流和防抖]]></title>
    <url>%2F2019%2F07%2F11%2F%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[节流与防抖 总结 如果是业务中需要实现的节流与防抖等需求，最好还是根据业务需求自己编写定时器，简洁方便。 如果是复杂的计算，最好结合webworker，启用多线程的方式。也能优化体验lodash节流与防抖定义节流：在一定时间多次触发函数，保证一段时间仅执行一次。如页面resize，重绘大小的时候，间隔一段时间重绘一次。防抖：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时流程 第一次进入 timerId为空 执行leadingEdge（设置定时器，时间为等待时间，执行函数为timerExpired） 如果设置了leading为true，则立刻执行invokeFunc（执行一遍任务函数） 期间用户未操作，定时器时间到了，执行timerExpired（如果可以立刻执行，执行trailingEdge，否则重置定时器：时间为等待时间，执行函数timerExpired） 执行trailingEdge，清空定时器ID，判断是否周期结束后是否执行（如果是的，执行函数，不是，清空变量及参数） 期间用户又操作了，判断是否应该执行（如果不应该且定时器是空的，则执行timerExpired[有定时器，不操作]；如果应该且设置最大等待时间，重新设置定时器并立刻执行一次；如果不能，则不做任何事）lodash防抖 @param {Function} 实现的业务函数. @param {number} [wait=0] 延迟执行的时间，默认值是0，如果不传，使用requestAnimationFrame来更新页面； @param {Object} [options={}] The options object. @param {boolean} [options.leading=false] Specify invoking on the leading edge of the timeout. @param {number} [options.maxWait] The maximum time func is allowed to be delayed before it’s invoked. @param {boolean} [options.trailing=true] Specify invoking on the trailing edge of the timeout. @returns {Function} Returns the new debounced function.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181function debounce(func, wait, options) &#123; let lastArgs, // debounced 被调用后被赋值,表示至少调用 debounced一次 lastThis, // 保存 this maxWait, // 最大等待时间 result, // 返回执行的函数 timerId, // 定时器句柄 lastCallTime // 上一次调用 debounced 的时间 let lastInvokeTime = 0 // 上一次执行 func 的时间 let leading = false // 是否第一次触发时立即执行 let maxing = false // 是否有最长等待时间 let trailing = true // 是否在等待周期结束后执行用户传入的函数 // window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof root.requestAnimationFrame === &apos;function&apos;) // 以上代码被我注释，可以先不关注 // 这个很好理解，如果传入的 func 不是函数，抛出错误，老子干不了这样的活 if (typeof func != &apos;function&apos;) &#123; throw new TypeError(&apos;Expected a function&apos;) &#125; // 如果不存在 默认为0 wait = +wait || 0 if (isObject(options)) &#123; leading = !!options.leading maxing = &apos;maxWait&apos; in options maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait trailing = &apos;trailing&apos; in options ? !!options.trailing : trailing &#125;// 执行 用户传入的 func// lastInvokeTime 在此时被赋值，记录上一次调用 func的时间 function invokeFunc(time) &#123; const args = lastArgs const thisArg = lastThis// 重置 lastArgs，lastThis lastArgs = lastThis = undefined lastInvokeTime = time result = func.apply(thisArg, args) return result &#125;// setTimeout 一个定时器 function startTimer(pendingFunc, wait) &#123; // 如果没有传wait 默认使用浏览器的requestAnimationFrame if (useRAF) &#123; return root.requestAnimationFrame(pendingFunc) &#125; return setTimeout(pendingFunc, wait) &#125;// 清除定时器 function cancelTimer(id) &#123; if (useRAF) &#123; return root.cancelAnimationFrame(id) &#125; clearTimeout(id) &#125;// 防抖开始时执行的操作// lastInvokeTime 在此时被赋值，记录上一次调用 func的时间// 设置了立即执行func，则执行func， 否则设置定时器 function leadingEdge(time) &#123; // Reset any `maxWait` timer. lastInvokeTime = time // Start the timer for the trailing edge. timerId = startTimer(timerExpired, wait) // Invoke the leading edge. return leading ? invokeFunc(time) : result &#125;// 计算还需要等待多久// 没设置最大等待时间，结果为 wait - (当前时间 - 上一次触发(scroll) ) 时间，也就是 wait - 已经等候时间// 设置了最长等待时间，结果为 最长等待时间 和 按照wait 计算还需要等待时间 的最小值 function remainingWait(time) &#123; const timeSinceLastCall = time - lastCallTime const timeSinceLastInvoke = time - lastInvokeTime const timeWaiting = wait - timeSinceLastCall return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting &#125;// 此时是否应该设置定时器/执行用户传入的函数，有四种情况应该执行// 1, 第一次触发// 2. 距离上次触发超过 wait// 3. 当前时间小于 上次触发时间// 4. 设置了最长等待时间，并且等待时长不小于最长等待时间了 function shouldInvoke(time) &#123; const timeSinceLastCall = time - lastCallTime const timeSinceLastInvoke = time - lastInvokeTime return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)) &#125;// 执行函数呢 还是继续设置定时器呢？ 防抖的核心// 时间满足条件，执行// 否则 重新设置定时器 function timerExpired() &#123; const time = Date.now() if (shouldInvoke(time)) &#123; return trailingEdge(time) &#125; // Restart the timer. timerId = startTimer(timerExpired, remainingWait(time)) &#125;// 执行用户传入的 func 之前的最后一道屏障// 重置 定时器// 执行 func// 重置 lastArgs = lastThis 为 undefined function trailingEdge(time) &#123; timerId = undefined // Only invoke if we have `lastArgs` which means `func` has been // debounced at least once. if (trailing &amp;&amp; lastArgs) &#123; return invokeFunc(time) &#125; lastArgs = lastThis = undefined return result &#125;// 取消防抖// 重置所有变量 清除定时器 function cancel() &#123; if (timerId !== undefined) &#123; cancelTimer(timerId) &#125; lastInvokeTime = 0 lastArgs = lastCallTime = lastThis = timerId = undefined &#125;// 定时器已存在，去执行 嗯，我就是这么强势 function flush() &#123; return timerId === undefined ? result : trailingEdge(Date.now()) &#125;// 是否正在 等待中 function pending() &#123; return timerId !== undefined &#125;// 正房来了！ 这是入口函数，在这里运筹帷幄，根据敌情调配各个函数，势必骗过用户那个傻子，我没有一直在执行但你以为我一直在响应你哦 function debounced(...args) &#123; const time = Date.now() // 是否立刻执行 const isInvoking = shouldInvoke(time) // 保存当前的参数 lastArgs = args lastThis = this lastCallTime = time // 判断如果不应该执行 if (isInvoking) &#123; // 定时器未执行（第一次进入） if (timerId === undefined) &#123; return leadingEdge(lastCallTime) &#125; if (maxing) &#123; // Handle invocations in a tight loop. timerId = startTimer(timerExpired, wait) return invokeFunc(lastCallTime) &#125; &#125; // 保证最后执行一次 if (timerId === undefined) &#123; timerId = startTimer(timerExpired, wait) &#125; return result &#125; debounced.cancel = cancel debounced.flush = flush debounced.pending = pending // 下面这句话证明 debounced 我是入口函数，是正宫娘娘！ return debounced&#125;export default debounce lodash节流1234567891011121314151617function throttle(func, wait, options) &#123; let leading = true let trailing = true if (typeof func !== &apos;function&apos;) &#123; throw new TypeError(&apos;Expected a function&apos;) &#125; if (isObject(options)) &#123; leading = &apos;leading&apos; in options ? !!options.leading : leading trailing = &apos;trailing&apos; in options ? !!options.trailing : trailing &#125; return debounce(func, wait, &#123; leading, trailing, &apos;maxWait&apos;: wait, &#125;)&#125; 参考这个还有这个]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cedar]]></title>
    <url>%2F2019%2F07%2F07%2Fcedar%2F</url>
    <content type="text"><![CDATA[对自己现状的总结 基本信息 描述 描述信息 描述 描述信息 姓名 曹文松 性别 男 籍贯 陕西安康 电话 13167119769 生日 1992.01.20 邮箱 akcedar@163.com 学校 湖南大学 专业 热能与动力工程 基本技能html 熟练掌握各种标签 熟练掌握HTML5新增的属性及标签CSS 熟练掌握css属性 熟练运用CSS3特性实现各种动画 掌握flex及rem布局 掌握字体图标的制作及使用js 熟练掌握基本js知识 熟练运用DOM、BOM操作 熟练运用ES6基本语法框架 熟练运用jquery及相关插件、echats，了解three.js、go.js等js插件 掌握boostrap、layui、easyUI等 熟练运用vue，了解raect、react-native。微信 熟练开发微信小程序 微信公众号、微信机器人工具 熟练掌握git进行代码管理 会运用eslint规范代码编写 掌握webpack打包 掌握NPM，会编写NPM包并发布 搭建过公司私有的NPM仓库优化 了解网页渲染流程，会进行相关的性能优化 会对webpack打包进行优化 会对项目进行业务划分，抽离组件，实现组件开发 web安全 HTTP了解及优化后台+数据库 使用node.js（express）编写过后台应用 使用ssh框架写过简单的java 会写简单sql 项目 小程序+活动页面 数据可视化大屏开发 后台管理系统 H5页面app web开发小程序已上线小程序6个（最大的一个日活跃用户量2000+，腾讯评测性能优秀）自己开发两个（为点餐商城类，因为审核原因未上线）数据可视化大屏主要使用echarts、three.js、go.js等插件实现图表及数据的展示，并使用canvas、svg、css3绘制炫酷的动画效果，灵活多变的展现各种数据，将数据语言转化为图形语言，让用户更快更好的获取信息。后台管理系统技术：利用vue-cli搭建vue框架，并优化webpack打包优化项，使用vue、vue-router、vuex、axios、elementUI(ant-design-vue)编写中台管理页面。模块：主要包含菜单权限模块、用户模块、基础服务设置模块、订单模块、打印模块。特点：主要是后台用户操作，包含表单查询、数据报表增删改查、下单、详情页展示等主要功能，一般使用菜单、导航加主页面的页面结构，主页面为百分比宽度，自适应大小分辨率，追求统一的页面风格。H5页面APP技术：使用混合开发的方式，后台安卓以及ios提供壳子，利用技术bridge实现与NA的交互。主要使用vue全家桶+mint编写相应界面及交互。特点：利用原生嵌套h5页面的方式实现快速迭代开发，采用rem+flex布局方式，兼容大小屏，使用keepalive保持页面数据缓存，减少用户数据加载。web开发技术：利用vue全家桶，或者jquery实现快速开发，追求与UI的完美展现举例：以做过的人力招聘系统，为外部及内部人员提供岗位应聘的全流程服务，主要流程为信息发布、报名、笔试、面试（多轮）、最终是否聘用。此外还有应聘规则设置等页面为主流程提供服务。特点：追求好看的界面，一般采用定宽的页面结构，自定义编写各种页面组件效果，追求个性化，看中web安全。 自我总结对现有的前端技术有一定的了解，有一颗不停学习的心，阅读过一些书籍及代码文章，有合作进取的能力，希望以后能在某一方面有更加深入的研究。]]></content>
      <categories>
        <category>自己</category>
      </categories>
      <tags>
        <tag>cedar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[学习小程序而不仅仅是学会用 小程序发展 微信webview（微信浏览器的广泛使用） 微信SDK（提供开发者在调用微信原生能力）（会出现加载延迟） 增强版JS-SDK，“微信 Web 资源离线存储” （解决的部分加载的问题，但是网页切换补流程，复杂的也会出现白屏） 微信小程序 小程序和web的区别 普通网页开发可以使用各种浏览器提供的 DOM API，进行 DOM 操作，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。 普通网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。 网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。 小程序的执行环境 环境 逻辑 视图 IOS javascriptcore wkwebview 安卓 V8 chromium 开发者工具 nwjs chrome webview 开发思路Hybrid 技术来渲染小程序小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。 逻辑层：创建一个单独的线程去执行 JavaScript，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程JSBridge 起到架起上层开发与Native（系统层）的桥梁，使得小程序可通过API使用原生的功能，且部分组件为原生组件实现，从而有良好体验 在渲染层把 WXML 转化成对应的 JS 对象。 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。 小程序基础库小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库 在视图层，提供各类组件来组建界面的元素 在逻辑层，提供各类 API 来处理各种逻辑 处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑Exparser 框架Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。 基于ShadowDOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。 可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。 高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。 基于Exparser框架，小程序内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。有了这么丰富的组件，再配合WXSS，可以搭建出任何效果的界面。在功能层面上，也满足绝大部分需求。 运行小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。 小程序没有重启的概念 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁 当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁更新小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。性能优化 精简代码，降低WXML结构和JS代码的复杂性； 合理使用setData调用，减少setData次数和数据量； 必要时使用分包优化。视图及逻辑小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。错误的做法频繁的去 setData在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；每次 setData 都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程， 后台态页面进行setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。 参考这个这个还有这个]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[埋点]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%9F%8B%E7%82%B9%2F</url>
    <content type="text"><![CDATA[本文主要讲了对埋点的一些学习。 埋点sdk 自主研发（大公司的必经之路） 百度统计（免费） TalkingData（收费） GrowingIo（全埋点） Google Analytics（免费） Mixpanel（可视化埋点） 友盟（收费） 神策（收费）埋点统计内容 who：行为背后的人，具有哪些属性、IP，账号 when：什么时候触发的这个行为？ where：事件发生的地点，城市地区甚至GPS what：描述用户所做的事件的具体内容 How：用户进行事件的方式埋点使用场景 页面浏览 用户点击交互 页面加载性能 JS报错 接口出错上报 自定义测速埋点方式 前端埋点（监控页面加载、浏览习惯、页面停留时长、点击交互、表单提交，接口报错、JS报错、用户设备、IP）（ 用户行为数据 + 前端健康度分析） 后台埋点 （IP、接口调用、用户信息、设备信息）SDK埋点分类 Web 移动端（IOS/Android） 小程序（微信、支付宝、百度） App第三方框架（RN,Flutter,Weex)埋点平台化 埋点规范埋点规范代码生成平台 埋点管理 注册埋点，添加、删除埋点 埋点可视化 埋点验证 测试埋点平台，可生成报告 埋点发布 独立的埋点发布平台 埋点监控 埋点数据回流 埋点错误上报埋点前端方式JS埋点1、提供全局的方法，让JS进行调用2、监控浏览器的事件，添加标识（自动上传，后期进行数据整合）（如添加click事件的监控）3、JS业务代码中添加JS代码。4、对需要进程埋点的DOM声明 data属性，遍历绑定事件。5、vue中可以利用路由钩子函数以及组件声明周期进行页面的监控。CSS埋点1、加载页面的时候，利用background、url等属性，直接调用接口上报数据。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsBridge]]></title>
    <url>%2F2019%2F06%2F28%2FjsBridge%2F</url>
    <content type="text"><![CDATA[本文主要记下自己看过一下jsBridege的知识 参照网站 移动混合开发中的 JSBridge JSBridge实战 时下app分以下几种技术选型 UIWebView代码注入时机与姿势 JSSDK当前的技术选型 Webapp，框架有cordova，ionic等 Hybrid，即Native+h5方式 React Native, weex方向 纯Native，这个没啥好说的 flutter，明日之星bridge原理为了解决 H5和Native的双向通信的问题。主旨思想是在H5和NA之间搭建一个桥梁（Bridge），给两端留好更友好、更合理的接口。 H5调用NA方法梳理 平台 方法 备注 Android shouldOverrideUrlLoading scheme拦截方法 Android addJavascriptInterface API Android onJsAlert()、onJsConfirm()、onJsPrompt（） 无 IOS 拦截URL 无 IOS(UIwebview) JavaScriptCore API方法，IOS7+ 支持 IOS(WKwebview) window.webkit.messageHandlers APi方法，IOS8+支持 NA调用H5方法梳理 平台 方法 备注 Android loadurl() Android evaluateJavascript() Android 4.4 + IOS(UIwebview) stringByEvaluatingJavaScriptFromString IOS(UIwebview) JavaScriptCore IOS7.0+ IOS(Wkwebview) evaluateJavaScript:javaScriptString iOS8.0+ 用法拦截urlH5和NA通信方面，最简单直接的思路是：NA拦截H5的URL获取消息（一般是通过修改iframe的src来实现 ①），经过业务处理，NA执行JS（在H5侧提前注册好的全局方法）回调通知H5。 H5代码实现如下：1234567891011121314151617181920212223242526&lt;html&gt;...&lt;body&gt; &lt;div class=&quot;content&quot;&gt;XXXXX&lt;/div&gt;&lt;/body&gt; &lt;script&gt; // ① 注册全局函数,以便端调用 window.setAllContent = function()&#123; &#125; // ② 通用方法函数 var sendschema = function(action,param)&#123; let tempnode = document.createElement(&apos;iframe&apos;); tempnode.src = &quot;bdnews://&quot;+action+param; &#125; // ③ H5逻辑开始 运行函数 document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123; sendschema(&apos;load_finish&apos;); &#125;,false);&lt;/script&gt; ...&lt;/html&gt; Android原理大致如下：1234567891011121314151617181920webView.setWebViewClient(new WebViewClient() &#123; public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; // 场景一： 拦截请求、接收schema if (url.equals(&quot;load_url&quot;)) &#123; // 处理逻辑 dosomething // 回掉 view.loadUrl(&quot;javascript:setAllContent(&quot; + json + &quot;);&quot;) &#125; // 场景二：端自己调用H5，没有请求发起 clickbutton()&#123; view.loadUrl(&quot;javascript:setAllContent(&quot; + json + &quot;);&quot;) &#125; &#125;&#125;); IOS大概逻辑如下:1234567891011121314151617181920212223242526// 初始化webviewUIWebView * view = [[UIWebView alloc]initWithFrame:self.view.frame];[view loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.xx.com&quot;]]];[self.view addSubview:view];&amp;nbsp;&amp;nbsp;/*webView协议中的方法shouldStartLoadWithRequest //准备加载内容时调用的方法，通过返回值来进行是否加载的设置webViewDidStartLoad //开始加载时调用的方法webViewDidFinishLoad //结束加载时调用的方法didFailLoadWithError //加载失败时调用的方法*/&amp;nbsp;- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; if ([urlString hasPrefix:@&quot;scheme://hybrid?info=&quot;]) &#123; if([name isEqualToString:@&quot;load_finish&quot;])&#123; // [self.webView setContent]; [self.webView stringByEvaluatingJavaScriptFromString:strFormat]; &#125; &#125;&#125; - clickbutton()&#123; [self.webView setContent];&#125; 函数名关联123456789101112131415161718192021222324252627let BDAPPnode = &#123; callbacks: &#123;&#125;, // 调用函数注册 invoke(action, params, successfnname, successfn) &#123; this.callbacks[successfnname] = &#123; success: successfn &#125;; sendschema(action, params); &#125;, // NA调用 callbackSuccess(callbackname, params) &#123; try &#123; BDAPPnode.callbackFromNative(callbackname, params, true); &#125; catch (e) &#123; console.log(&apos;Error in error callback: &apos; + callbackname + &apos; = &apos; + e); &#125; &#125;, callbackFromNative(callbackname, params, isSuccess) &#123; let callback = this.callbacks[callbackname]; if (callback) &#123; if (isSuccess) &#123; callback.success &amp;&amp; callback.success(params); &#125; &#125;; &#125;&#125;; ID关联12345678910111213141516171819202122232425262728293031323334353637let BDAPPnode = &#123; callbackId: Math.floor(Math.random() * 2000000000), callbacks: &#123;&#125;, invoke(action, params, onSuccess, onFail) &#123; this.callbackId++; this.callbacks[self.callbackId] = &#123; success: onSuccess, fail: onFail &#125;; sendschema(action, params, this.callbackId); &#125;, callbackSuccess(callbackId, params) &#123; try &#123; BDAPPnode.callbackFromNative(callbackId, params, true); &#125; catch (e) &#123; console.log(&apos;Error in error callback: &apos; + callbackId + &apos; = &apos; + e); &#125; &#125;, callbackError(callbackId, params) &#123; try &#123; BDAPPnode.callbackFromNative(callbackId, params, false); &#125; catch (e) &#123; console.log(&apos;Error in error callback: &apos; + callbackId + &apos; = &apos; + e); &#125; &#125;, callbackFromNative(callbackId, params, isSuccess) &#123; let callback = this.callbacks[callbackId]; if (callback) &#123; if (isSuccess) &#123; callback.success &amp;&amp; callback.success(callbackId, params); &#125; else &#123; callback.fail &amp;&amp; callback.fail(callbackId, params); &#125; delete BDAPPnode.callbacks[callbackId]; &#125;; &#125;&#125;; 注入API JavaScript 调用 Native 推荐使用 注入 API 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。 Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。 注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。在javascripte中 直接可以使用 利用window.method来使用注入的api唯一标识 id 是这个回调逻辑的关键。 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。一个案列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758(function () &#123; // 保存id var id = 0, // 将回调函数用键值对的模式保存下来 callbacks = &#123;&#125;, // NA注册进来的方法 registerFuncs = &#123;&#125;; window.JSBridge = &#123; // 调用 Native invoke: function(bridgeName, callback, data) &#123; // 判断环境，获取不同的 nativeBridge var thisId = id ++; // 获取唯一 id callbacks[thisId] = callback; // 存储 Callback nativeBridge.postMessage(&#123; bridgeName: bridgeName, data: data || &#123;&#125;, callbackId: thisId // 传到 Native 端 &#125;); &#125;, receiveMessage: function(msg) &#123; var bridgeName = msg.bridgeName, data = msg.data || &#123;&#125;, callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回 responstId = msg.responstId; // 具体逻辑 // bridgeName 和 callbackId 不会同时存在 if (callbackId) &#123; if (callbacks[callbackId]) &#123; // 找到相应句柄 callbacks[callbackId](msg.data); // 执行调用 &#125; &#125; else if (bridgeName) &#123; if (registerFuncs[bridgeName]) &#123; // 通过 bridgeName 找到句柄 var ret = &#123;&#125;, flag = false; registerFuncs[bridgeName].forEach(function(callback) =&gt; &#123; callback(data, function(r) &#123; flag = true; ret = Object.assign(ret, r); &#125;); &#125;); if (flag) &#123; nativeBridge.postMessage(&#123; // 回调 Native responstId: responstId, ret: ret &#125;); &#125; &#125; &#125; &#125;, register: function(bridgeName, callback) &#123; if (!registerFuncs[bridgeName]) &#123; registerFuncs[bridgeName] = []; &#125; registerFuncs[bridgeName].push(callback); // 存储回调 &#125; &#125;;&#125;)(); 注入方式native注入注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。 js注入直接与 JavaScript 一起执行。与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>webAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[commander]]></title>
    <url>%2F2019%2F06%2F24%2Fcommander%2F</url>
    <content type="text"><![CDATA[本文主要讲了命令行的输入参数解析功能 安装npm install commander 使用123456789101112131415161718192021222324252627282930const commander = require(&apos;commander&apos;);const program = new commander.Command();program.version(&apos;0.0.1&apos;);program .option(&apos;-d, --debug&apos;, &apos;output extra debugging&apos;) .option(&apos;-s, --small&apos;, &apos;small pizza size&apos;) .option(&apos;-p, --pizza-type &lt;type&gt;&apos;, &apos;flavour of pizza&apos;);program.parse(process.argv);if (program.debug) console.log(program.opts());console.log(&apos;pizza details:&apos;);if (program.small) console.log(&apos;- small pizza size&apos;);if (program.pizzaType) console.log(`- $&#123;program.pizzaType&#125;`);// 命令输出内容$ pizza-options -d&#123; debug: true, small: undefined, pizzaType: undefined &#125;pizza details:$ pizza-options -perror: option `-p, --pizza-type &lt;type&gt;&apos; argument missing$ pizza-options -ds -p vegetarian&#123; debug: true, small: true, pizzaType: &apos;vegetarian&apos; &#125;pizza details:- small pizza size- vegetarian$ pizza-options --pizza-type=cheesepizza details:- cheese 官方案例12345678910111213141516171819202122232425262728293031323334353637383940var program = require(&apos;commander&apos;);program .version(&apos;0.1.0&apos;) .option(&apos;-C, --chdir &lt;path&gt;&apos;, &apos;change the working directory&apos;) .option(&apos;-c, --config &lt;path&gt;&apos;, &apos;set config path. defaults to ./deploy.conf&apos;) .option(&apos;-T, --no-tests&apos;, &apos;ignore test hook&apos;);program .command(&apos;setup [env]&apos;) .description(&apos;run setup commands for all envs&apos;) .option(&quot;-s, --setup_mode [mode]&quot;, &quot;Which setup mode to use&quot;) .action(function(env, options)&#123; var mode = options.setup_mode || &quot;normal&quot;; env = env || &apos;all&apos;; console.log(&apos;setup for %s env(s) with %s mode&apos;, env, mode); &#125;);program .command(&apos;exec &lt;cmd&gt;&apos;) .alias(&apos;ex&apos;) .description(&apos;execute the given remote cmd&apos;) .option(&quot;-e, --exec_mode &lt;mode&gt;&quot;, &quot;Which exec mode to use&quot;) .action(function(cmd, options)&#123; console.log(&apos;exec &quot;%s&quot; using %s mode&apos;, cmd, options.exec_mode); &#125;).on(&apos;--help&apos;, function() &#123; console.log(&apos;&apos;); console.log(&apos;Examples:&apos;); console.log(&apos;&apos;); console.log(&apos; $ deploy exec sequential&apos;); console.log(&apos; $ deploy exec async&apos;); &#125;);program .command(&apos;*&apos;) .action(function(env)&#123; console.log(&apos;deploying &quot;%s&quot;&apos;, env); &#125;);program.parse(process.argv);]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>commander</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inquirer]]></title>
    <url>%2F2019%2F06%2F24%2FInquirer%2F</url>
    <content type="text"><![CDATA[主要讲了命令行交互工具 inquirer 安装github地址npm install inquirer apiinquirer.prompt(questions) -&gt; promiseQuestiontype：input, number, confirm, list, rawlist, expand, checkbox, password, editorname：（String）将答案存储在answers散列中时使用的名称。如果名称包含句点，则它将在答案哈希中定义路径。message：（String | Function）要打印的问题。如果定义为函数，则第一个参数将是当前查询者会话的答案。默认为name的值（后跟冒号）。default：（String | Number | Boolean | Array | Function）如果未输入任何内容，则使用默认值，或返回默认值的函数。如果定义为函数，则第一个参数将是当前查询者会话的答案。choices：（Array | Function）选择数组或返回选择数组的函数。如果定义为函数，则第一个参数将是当前查询者会话的答案。数组值可以是简单的数字，字符串或包含名称（在列表中显示）的对象，值（保存在答案哈希中）和短（在选择后显示）属性。 choices数组还可以包含Separator。validate :( Function）接收用户输入并回答hash。如果值有效则应返回true，否则返回错误消息（String）。如果返回false，则提供默认错误消息。filter :( Function）接收用户输入并返回要在程序中使用的过滤值。返回的值将添加到Answers哈希。transformer :( Function）接收用户输入，回答散列和选项标志，并返回转换后的值以显示给用户。转换仅影响编辑时显示的内容。它不会修改答案哈希。when :( Function，Boolean）接收当前用户的答案哈希，并且应该返回true或false，具体取决于是否应该询问此问题。该值也可以是一个简单的布尔值。pageSize：（Number）更改使用list，rawList，expand或checkbox时将呈现的行数。prefix：（String）更改默认前缀消息。suffix：（String）更改默认后缀消息。1234567891011121314151617181920212223&#123; /* Preferred way: with promise */ filter() &#123; return new Promise(/* etc... */); &#125;, /* Legacy way: with this.async */ validate: function (input) &#123; // Declare function as asynchronous, and save the done callback var done = this.async(); // Do async stuff setTimeout(function() &#123; if (typeof input !== &apos;number&apos;) &#123; // Pass the return value in the done callback done(&apos;You need to provide a number&apos;); return; &#125; // Pass the return value in the done callback done(null, true); &#125;, 3000); &#125;&#125; AnswersKey: The name property of the question objectValue: (Depends on the prompt) + confirm: (Boolean) + input : User input (filtered if filter is defined) (String) + number: User input (filtered if filter is defined) (Number) + rawlist, list : Selected choice value (or name if no value specified) (String) Separator分割线12345// In the question objectchoices: [ &quot;Choice A&quot;, new inquirer.Separator(), &quot;choice B&quot; ] &gt; Choice A -------- Choice B inquirer.registerPrompt(name, prompt) name (string) name of the this new prompt. (used for question type) prompt (object) the prompt object itself (the plugin)autocomplete1234567891011121314151617inquirer.registerPrompt(&apos;autocomplete&apos;, require(&apos;inquirer-autocomplete-prompt&apos;));inquirer.prompt(&#123; type: &apos;autocomplete&apos;, ...&#125;)// 例子inquirer.registerPrompt(&apos;autocomplete&apos;, require(&apos;inquirer-autocomplete-prompt&apos;));inquirer.prompt([&#123; type: &apos;autocomplete&apos;, name: &apos;from&apos;, message: &apos;Select a state to travel from&apos;, source: function(answersSoFar, input) &#123; return myApi.searchStates(input); &#125;&#125;]).then(function(answers) &#123; //etc&#125;); checkbox-plus具有自动填充和其他添加功能的复选框列表 datetime使用数字键盘和箭头键可自定义日期/时间选择器 inquirer-select-line在一行的后边 或者前边插入 获得索引值 command命令历史记录和动态自动完成功能的简单提示 inquirer-emoji表情 inquirer-chalk-pipe可以对输出的文字进行chalk1234567891011121314inquirer.registerPrompt(&apos;chalk-pipe&apos;, require(&apos;inquirer-chalk-pipe&apos;));const inquirer = require(&apos;inquirer&apos;)const chalkPipe = require(&apos;chalk-pipe&apos;)inquirer.prompt([ &#123; type: &apos;input&apos;, name: &apos;fav_color&apos;, message: &quot;What&apos;s your favorite color&quot;, transformer: function(color) &#123; return chalkPipe(color)(color); &#125; &#125;]) inquirer-search-checkbox可搜索的查询者复选框 inquirer-prompt-suggest一些常用输入的建议 inquirer-file-tree-selection-prompt树状结构的目录 inquirer-fuzzy-path提示 模糊 文件/目录选择。 inquirer.createPromptModule() -&gt; prompt functionCreate a self contained inquirer module. If you don’t want to affect other libraries that also rely on inquirer when you overwrite or add new prompt types.12var prompt = inquirer.createPromptModule();prompt(questions).then(/* ... */);]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>inquirer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode]]></title>
    <url>%2F2019%2F06%2F24%2Fvscode%2F</url>
    <content type="text"><![CDATA[记一些vscode的快捷键，方便自己看 F1 或 Cmd+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令在Cmd+P下输入 &gt; 可以进入 Cmd+Shift+P 模式在 Cmd+P 窗口下还可以: 直接输入文件名，跳转到文件? 列出当前可执行的动作: 跳转到行数，也可以 Cmd+G 直接进入打开一个新窗口： Cmd+Shift+N关闭窗口： Cmd+Shift+W关闭标签页：Cmd+W新建文件 Cmd+N文件之间切换 Cmd+~切出一个新的编辑器（最多 3 个） Cmd+\左中右 3 个编辑器的快捷键 Cmd+1 Cmd+2 Cmd+3关闭打开资源管理器 Cmd+B切换同一编辑器不同的标签页：control+tab格式化代码：shift+Option+F上下移动一行： Option+Up 或 option+Down向上向下复制一行： Shift+Option+Up 或 Shift+Option+Down在当前行下边插入一行： Cmd+Enter在当前行上方插入一行： Cmd+Shift+Enter删除当前行：Cmd+Shift+K跳到当前行的头部，尾部：Fn+←，Fn+→插入多光标：Option+click或Cmd+Option+up/Cmd+Option+down查找：Cmd+F将选择添加到下一个查找匹配: Cmd+D显示搜索：Shift+Cmd+F全局替换：Shift+Cmd+H放到/缩小：Cmd+=/Cmd+-修改语言：组合键Cmd+K M设置：Cmd+]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chalk]]></title>
    <url>%2F2019%2F06%2F24%2Fchalk%2F</url>
    <content type="text"><![CDATA[本文主要讲控制台输出工具chalk,控制输出样式和颜色以及背景色 介绍github//安装 npm install chalk util.format ％s：String将用于转换除BigInt，Object和-0之外的所有值。 BigInt值将用n表示，而没有用户定义toString函数的Objects使用带有+++ options {depth：0，colors：false，compact：3}的util.inspect（）进行检查。 ％d：Number将用于转换除BigInt和Symbol之外的所有值。 ％i：parseInt（value，10）用于除BigInt和Symbol之外的所有值。 ％f：parseFloat（value）用于所有期望符号的值。 ％j：JSON。如果参数包含循环引用，则替换为字符串’[Circular]’。 ％o：对象。具有通用JavaScript对象格式的对象的字符串表示形式。类似于带有选项{showHidden：true，showProxy：true}的util.inspect（）。这将显示完整对象，包括非可枚举属性和代理。 ％O：对象。具有通用JavaScript对象格式的对象的字符串表示形式。类似于util.inspect（）没有选项。这将显示完整对象，不包括非可枚举属性和代理。 %%：单个百分号（’％’） 返回：格式化的字符串123const name = &apos;cws&apos;;console.log(&apos;Hello %s&apos;), chalk.green(name);// hello cws API样式 reset : 重置样式 bold 加粗 dim 置灰 italic 斜体 underline 下划线 inverse 交换背景色 和文字颜色 hidden 隐藏 strikethrough 删除线 但是 支持不是很好 有的不显示 visible 显示颜色 black red green yellow blue (On Windows the bright version is used since normal blue is illegible) magenta cyan white gray (“bright black”) redBright greenBright yellowBright blueBright magentaBright cyanBright whiteBright背景色 bgBlack bgRed bgGreen bgYellow bgBlue bgMagenta bgCyan bgWhite bgBlackBright bgRedBright bgGreenBright bgYellowBright bgBlueBright bgMagentaBright bgCyanBright bgWhiteBright特殊123456chalk.hex(&apos;#DEADED&apos;).underline(&apos;Hello, world!&apos;)chalk.keyword(&apos;orange&apos;)(&apos;Some orange text&apos;)chalk.rgb(15, 100, 204).inverse(&apos;Hello!&apos;)chalk.bgHex(&apos;#DEADED&apos;).underline(&apos;Hello, world!&apos;)chalk.bgKeyword(&apos;orange&apos;)(&apos;Some orange text&apos;)chalk.bgRgb(15, 100, 204).inverse(&apos;Hello!&apos;)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>chalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历生成树的两种方式]]></title>
    <url>%2F2019%2F06%2F18%2F%E9%81%8D%E5%8E%86%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[主要讲了生成树状结构的两种方式 参考 数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let dataList = [ &#123; name: &apos;f0&apos;, id: &apos;s1&apos;, pid: &apos;s0&apos;, &#125;, &#123; name: &apos;f01&apos;, id: &apos;s2&apos;, pid: &apos;s1&apos;, &#125;, &#123; name: &apos;f02&apos;, id: &apos;s3&apos;, pid: &apos;s1&apos;, &#125;, &#123; name: &apos;f021&apos;, id: &apos;s6&apos;, pid: &apos;s3&apos;, &#125;, &#123; name: &apos;f021&apos;, id: &apos;s7&apos;, pid: &apos;s6&apos;, &#125;, &#123; name: &apos;f40&apos;, id: &apos;s4&apos;, pid: &apos;s0&apos;, &#125;, &#123; name: &apos;f41&apos;, id: &apos;s5&apos;, pid: &apos;s4&apos;, &#125;, &#123; name: &apos;f41&apos;, id: &apos;s8&apos;, pid: &apos;s5&apos;, &#125;, &#123; name: &apos;f41&apos;, id: &apos;s9&apos;, pid: &apos;s5&apos;, &#125;, &#123; name: &apos;f41&apos;, id: &apos;s10&apos;, pid: &apos;s9&apos;, &#125; ]; forEach生成123456789101112131415161718console.time(&apos;start&apos;)let rootMenus = [];let map = &#123;&#125;;dataList.sort((a, b) =&gt; a.pid - b.pid);dataList.forEach(resource =&gt; &#123;resource.children = [];map[resource.id] = resource;if (resource.pid == &apos;s0&apos;) &#123; rootMenus.push(resource);&#125; else &#123; if (map[resource.pid]) &#123; map[resource.pid].children.push(resource) &#125; else &#123; throw new Error(`当前循环的数据pid=$&#123;resource.pid&#125;有错误`); &#125;&#125;&#125;)console.timeEnd(&apos;start&apos;) 利用reduce生成12345678910111213141516console.time(&apos;start&apos;)// 第一次是将全部的permissionId作为对象的key重组成一个对象let formatObj = dataList.reduce((pre, cur) =&gt; &#123; return &#123;...pre, [cur[&apos;id&apos;]]: cur&#125;&#125;, &#123;&#125;);let formatArray = dataList.reduce((arr, cur) =&gt; &#123; let pid = cur.pid ? cur.pid : 0; let parent = formatObj[pid]; if (parent) &#123; parent.children ? parent.children.push(cur) : parent.children=[cur]; &#125; else &#123; arr.push(cur) &#125; return arr;&#125;, []);console.timeEnd(&apos;start&apos;)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tree命令]]></title>
    <url>%2F2019%2F06%2F16%2Ftree%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[主要讲解利用tree查看和生成目录结构 mac使用tree12brew install treetree -I node_modules //常用 命令说明 -a 显示所有文件和目录。 -A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。 -C 在文件和目录清单加上色彩，便于区分各种类型。 -d 显示目录名称而非内容。 -D 列出文件或目录的更改时间。 -f 在每个文件或目录之前，显示完整的相对路径名称。 -F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。 -g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。 -i 不以阶梯状列出文件或目录名称。 -I 不显示符合范本样式的文件或目录名称。 -l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。 -n 不在文件和目录清单加上色彩。 -N 直接列出文件和目录名称，包括控制字符。 -p 列出权限标示。 -P 只显示符合范本样式的文件或目录名称。 -q 用”?”号取代控制字符，列出文件和目录名称。 -s 列出文件或目录大小。 -t 用文件和目录的更改时间排序。 -u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。 -x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 示例├── README.md├── babel.config.js├── package.json├── public│ ├── favicon.ico│ └── index.html├── src│ ├── App.vue│ ├── assets│ │ └── logo.png│ ├── components│ │ └── HelloWorld.vue│ ├── main.js│ └── test.js└── yarn.lock]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue指令]]></title>
    <url>%2F2019%2F06%2F14%2Fvue%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本文主要讲vue指令的一些用法，并写一个倒计时的案例 基础知识钩子函数12345678910111213141516171819202122Vue.directive(&apos;time&apos;, &#123; // 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 bind:function(el,binding)&#123; &#125;, // 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 inserted: function (el,binding) &#123; &#125;, // 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。 update:function(el,binding)&#123; &#125;, // 指令所在组件的 VNode 及其子 VNode 全部更新后调用 componentUpdated:function(el,binding)&#123; &#125;, // 只调用一次，指令与元素解绑时调用。 unbind:function(el,binding)&#123; &#125;,&#125;) 钩子函数参数指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:123Vue.directive(&apos;color-swatch&apos;, function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 多个值传递12345&lt;div v-demo=&quot;&#123; color: &apos;white&apos;, text: &apos;hello!&apos; &#125;&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, function (el, binding) &#123; console.log(binding.value.color) // =&gt; &quot;white&quot; console.log(binding.value.text) // =&gt; &quot;hello!&quot;&#125;) 倒计时时间1234567891011121314151617181920212223242526272829303132333435363738import Vue from &quot;vue&quot;// 注册一个全局自定义指令 `v-time`Vue.directive(&apos;time&apos;, &#123; // 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 bind:function(el,binding)&#123; console.log(el,binding) let aa = new Date() el.innerHTML = &apos;&lt;span&gt;&apos; + aa + &apos;&lt;/span&gt;&apos; &#125;, // 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 inserted: function (el,binding) &#123; el.__time__ = setInterval(function()&#123; let aa = new Date() el.innerHTML = &apos;&lt;span style=&quot;color:red&quot;&gt;&apos; + aa + &apos;&lt;/span&gt;&apos; &#125;.bind(this),1000) &#125;, // 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。 update:function(el,binding)&#123; console.log(el,binding) &#125;, // 指令所在组件的 VNode 及其子 VNode 全部更新后调用 componentUpdated:function(el,binding)&#123; console.log(el,binding) &#125;, // 只调用一次，指令与元素解绑时调用。 unbind:function(el,binding)&#123; clearInterval(el.__time__) &#125;,&#125;)// 打印 bindingdef: &#123;bind: ƒ, inserted: ƒ, update: ƒ, componentUpdated: ƒ, unbind: ƒ&#125;expression: &quot;nowDate&quot;modifiers: &#123;&#125;name: &quot;time&quot;oldArg: undefinedoldValue: Thu Jun 13 2019 20:42:29 GMT+0800 (中国标准时间) &#123;&#125;rawName: &quot;v-time&quot;value: Thu Jun 13 2019 20:42:32 GMT+0800 (中国标准时间) &#123;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[console.log]]></title>
    <url>%2F2019%2F06%2F11%2Fconsole-log%2F</url>
    <content type="text"><![CDATA[一些好玩的控制台输出 figlet1234567891011npm install figletvar figlet = require(&apos;figlet&apos;); figlet(&apos;想要展现的文字&apos;, function(err, data) &#123; if (err) &#123; console.log(&apos;Something went wrong...&apos;); console.dir(err); return; &#125; console.log(data)&#125;); 佛像保佑12345678910111213141516171819202122console.log([ &quot; _ooOoo_&quot;, &quot; o8888888o&quot;, &quot; 88\&quot; . \&quot;88&quot;, &quot; (| -_- |)&quot;, &quot; O\\ = /O&quot;, &quot; ____/`---&apos;\\____&quot;, &quot; .&apos; \\\\| |// `.&quot;, &quot; / \\\\||| : |||// \\&quot;, &quot; / _||||| -:- |||||- \\&quot;, &quot; | | \\\\\\ - /// | |&quot;, &quot; | \\_| &apos;&apos;\\---/&apos;&apos; | |&quot;, &quot; \\ .-\\__ `-` ___/-. /&quot;, &quot; ___`. .&apos; /--.--\\ `. . __&quot;, &quot; .\&quot;\&quot; &apos;&lt; `.___\\_&lt;|&gt;_/___.&apos; &gt;&apos;\&quot;\&quot;.&quot;, &quot; | | : `- \\`.;`\\ _ /`;.`/ - ` : | |&quot;, &quot; \\ \\ `-. \\_ __\\ /__ _/ .-` / /&quot;, &quot;======`-.____`-.___\\_____/___.-`____.-&apos;======&quot;, &quot; `=---=&apos;&quot;, &quot;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&quot;, &quot; 佛祖保佑 永无BUG&quot;].join(&apos;\n&apos;))]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回流和重绘]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[本文主要讲CSS的回流和重绘，从CSS提升页面性能 图层的形成 获取DOM后分割为多个图层 对每个图层的节点计算央视结果（recalculate style —样式重新计算） 为每个节点生成图形和位置（layout -回流和重布局） 为每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘） 图层作为纹理上传至CPU 符合多个图层到页面上生成最终屏幕图像（图层重组）以下属性会导致生成一个图层CSS 动画3Dvideocanvaswebglflashcss过滤器opacity本身页面为一个图层Z-index属性节点（gif不会生成图层）chrome创建图层的条件 3D或透视变换CSS属性 使用加速视频解码的vidoe节点 拥有3D webGL 或者2D CANVAS 或者插件（如flash） 对一个元素做opacity或者webkit变换 拥有css过滤器的元素（filter、 blur等） 元素有一个包含复合层的后代节点 元素在复合层上渲染触发页面重布局的属性 盒子模型相关属性 定位属性及浮动属性 改变节点内部文字结构1234width height padding margin padding display border min-heightborder-width top bottom left right position float clear text-align overflow-y font-wight overflow font-family line-height vertical-align white-space font-size 触发页面重绘的属性123color border-style border-radius visibolytext-decoration background background-img background-positionbackground-repeat background-size outline-style outline-width boxshadow]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-with]]></title>
    <url>%2F2019%2F06%2F05%2FJS-with%2F</url>
    <content type="text"><![CDATA[主要讲了js的with字段的一些用法及理解。with语句可以在不造成性能损失的情況下，减少变量的长度。其造成的附加计算量很少。使用’with’可以减少不必要的指针路径解析运算。需要注意的是，很多情況下，也可以不使用with语句，而是使用一个临时变量来保存指针，来达到同样的效果。12345678910111213var b = &#123;a:2&#125;;function sayA(obj)&#123; var a = 1; with(b)&#123;a=5;c = 6;&#125; console.log(c);&#125;sayA();console.log(b.c);console.log(b.a);// 输出结果6 undefined 5 在with语句块中，只是改变了对变量的遍历顺序，由原本的从执行环境开始变为从with语句的对象开始。当尝试在with语句块中修改变量时，会搜索with语句的对象是否有该变量，有就改变对象的值，没有就创建，但是创建的变量依然属于with语句块所在的执行环境，并不属于with对象。 离开with语句块后，遍历顺序就会再次变成从执行环境开始。 with 会把没有存在的变量赋值 挂载在当前作用域下，生命伴随当前作用域。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习vue-cli准备]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%AD%A6%E4%B9%A0vue-cli%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[主要学习一些vuecli的处理JS工具 学习网站vuecli源码分析命令行框架，提供了用户命令行输入和参数解析强大功能Inquirer为交互式命令行工具execa 是可以调用 shell 和本地外部程序的 javascript 封装handlebars 是一个 javascript 语义模版库metalsmith 一个静态网站生成器chalk 是用于修改控制台字符串的样式，包括字体样式（加粗），颜色以及背景颜色等。download-git-repo 是用于 从 GitHub, GitLab, Bitbucket 下载一个 git 仓库consolidate 是一个模版引擎整合库，它的作用是把一些著名的模板引擎适配成 Express 兼容的接口 ###]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VUE-CLI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise实现]]></title>
    <url>%2F2019%2F06%2F02%2Fpromise%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文主要写promise自己的实现方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198// 判断变量否为function const isFunction = variable =&gt; typeof variable === &apos;function&apos; // 定义Promise的三种状态常量 const PENDING = &apos;PENDING&apos; const FULFILLED = &apos;FULFILLED&apos; const REJECTED = &apos;REJECTED&apos; class MyPromise &#123; constructor (handle) &#123; if (!isFunction(handle)) &#123; throw new Error(&apos;MyPromise must accept a function as a parameter&apos;) &#125; // 添加状态 this._status = PENDING // 添加状态 this._value = undefined // 添加成功回调函数队列 this._fulfilledQueues = [] // 添加失败回调函数队列 this._rejectedQueues = [] // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (err) &#123; this._reject(err) &#125; &#125; // 添加resovle时执行的函数 _resolve (val) &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return this._status = FULFILLED // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; &#123; let cb; while (cb = this._fulfilledQueues.shift()) &#123; cb(value) &#125; &#125; // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; &#123; let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(error) &#125; &#125; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then(value =&gt; &#123; this._value = value runFulfilled(value) &#125;, err =&gt; &#123; this._value = err runRejected(err) &#125;) &#125; else &#123; this._value = val runFulfilled(val) &#125; &#125; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0) &#125; // 添加reject时执行的函数 _reject (err) &#123; if (this._status !== PENDING) return // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED this._value = err let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(err) &#125; &#125; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0) &#125; // 添加then方法 then (onFulfilled, onRejected) &#123; const &#123; _value, _status &#125; = this // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 let fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value) &#125; else &#123; let res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res) &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err) &#125; &#125; // 封装一个失败时执行的函数 let rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error) &#125; else &#123; let res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext) &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res) &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err) &#125; &#125; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled) this._rejectedQueues.push(rejected) break // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value) break case REJECTED: rejected(_value) break &#125; &#125;) &#125; // 添加catch方法 catch (onRejected) &#123; return this.then(undefined, onRejected) &#125; // 添加静态resolve方法 static resolve (value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value return new MyPromise(resolve =&gt; resolve(value)) &#125; // 添加静态reject方法 static reject (value) &#123; return new MyPromise((resolve ,reject) =&gt; reject(value)) &#125; // 添加静态all方法 static all (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; /** * 返回值的集合 */ let values = [] let count = 0 for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then(res =&gt; &#123; values[i] = res count++ // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values) &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err) &#125;) &#125; &#125;) &#125; // 添加静态race方法 static race (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; reject(err) &#125;) &#125; &#125;) &#125; finally (cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason &#125;) ); &#125; &#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST]]></title>
    <url>%2F2019%2F06%2F02%2FAST%2F</url>
    <content type="text"><![CDATA[本文主要讲一种js语法树 ASTAST有很多解析的JS 如：Babylon、esprima、acorn、UglifyJS2、AST explorer。在这个网址可以看到解析结果 解析结果下方的的js123var a = 42;var b = 5;var c = a + b; 展示结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&#123; "type": "Program", "start": 0, "end": 37, "body": [ &#123; "type": "VariableDeclaration", "start": 0, "end": 11, "declarations": [ &#123; "type": "VariableDeclarator", "start": 4, "end": 10, "id": &#123; "type": "Identifier", "start": 4, "end": 5, "name": "a" &#125;, "init": &#123; "type": "Literal", "start": 8, "end": 10, "value": 42, "raw": "42" &#125; &#125; ], "kind": "var" &#125;, &#123; "type": "VariableDeclaration", "start": 12, "end": 22, "declarations": [ &#123; "type": "VariableDeclarator", "start": 16, "end": 21, "id": &#123; "type": "Identifier", "start": 16, "end": 17, "name": "b" &#125;, "init": &#123; "type": "Literal", "start": 20, "end": 21, "value": 5, "raw": "5" &#125; &#125; ], "kind": "var" &#125;, &#123; "type": "VariableDeclaration", "start": 23, "end": 37, "declarations": [ &#123; "type": "VariableDeclarator", "start": 27, "end": 36, "id": &#123; "type": "Identifier", "start": 27, "end": 28, "name": "c" &#125;, "init": &#123; "type": "BinaryExpression", "start": 31, "end": 36, "left": &#123; "type": "Identifier", "start": 31, "end": 32, "name": "a" &#125;, "operator": "+", "right": &#123; "type": "Identifier", "start": 35, "end": 36, "name": "b" &#125; &#125; &#125; ], "kind": "var" &#125; ],&#125; 使用方法esprima estraverse escodegen babel esprima 解析 JS 生成 AST123456789101112131415161718192021const esprima = require('esprima');let code = 'function fn() &#123;&#125;';// 结果let tree = esprima.parseScript(code);console.log(tree);// Script &#123;// type: 'Program',// body:// [ FunctionDeclaration &#123;// type: 'FunctionDeclaration',// id: [Identifier],// params: [],// body: [BlockStatement],// generator: false,// expression: false,// async: false &#125; ],// sourceType: 'script' &#125; estraverse 遍历 AST1234567891011121314151617181920212223const esprima = require('esprima');const estraverse = require('estraverse');let code = 'function fn() &#123;&#125;';// 遍历路径estraverse.traverse(esprima.parseScript(code), &#123; enter(node) &#123; console.log('enter', node.type); &#125;, leave() &#123; console.log('leave', node.type); &#125;&#125;);// enter Program// enter FunctionDeclaration// enter Identifier// leave Identifier// enter BlockStatement// leave BlockStatement// leave FunctionDeclaration// leave Program escodegen 将AST重新生成为源码：1234567891011121314151617181920212223242526const esprima = require('esprima');const estraverse = require('estraverse');const escodegen = require('escodegen');let code = 'function fn() &#123;&#125;';// 解析let tree = esprima.parseScript(code);// 遍历estraverse.traverse(tree, &#123; enter(node) &#123; // 判断类型，改变函数名称 if (node.type === 'FunctionDeclaration') &#123; node.id.name = 'ast'; &#125; &#125;&#125;);// 重新生成JS源码let result = escodegen.generate(tree);console.log(result);// function ast() &#123;// &#125; AST三板斧： 通过 esprima 把源码转化为AST 通过 estraverse 遍历并更新AST 通过 escodegen 将AST重新生成源码 UglifyJS2进行代码混淆压缩]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QRCode]]></title>
    <url>%2F2019%2F06%2F02%2FQRCODE%20%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[QRCode.js 是一个用于生成二维码的 JavaScript 库。主要是通过获取 DOM 的标签,再通过 HTML5 Canvas 绘制而成,不依赖任何库QRCode.js ：https://www.jianshu.com/p/b53eae520de4 案例12345678910111213&lt;div id='qrcode'&gt;&lt;/div&gt;&lt;button onclick='createQrcode();'&gt;生成二维码&lt;button&gt;var qrcode = new QRCode('qrcode', &#123; width: 150, height: 150,&#125;)qrcode.clear();function createQrcode()&#123; qrcode.clear(); var QRCodeStr = "https://www.baidu.com" qrcode.makeCode(QRCodeStr);&#125; 小程序里面生成二维码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;view&gt; &lt;!-- 存放二维码的图片--&gt; &lt;view class='container'&gt; &lt;image style='width:310rpx;height:310rpx;margin-top:30rpx;' src="&#123;&#123;imagePath&#125;&#125;"&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 画布，用来画二维码，只用来站位，不用来显示 --&gt; &lt;view class="canvas-box"&gt; &lt;canvas hidden="&#123;&#123;canvasHidden&#125;&#125;" style="width: 170px;height: 170px;background:#f1f1f1;" canvas-id="mycanvas" /&gt; &lt;/view&gt;&lt;/view&gt;//小程序js的配置var QR = require("../../utils/qrcode.js");/*** 页面的初始数据*/data: &#123; canvasHidden: false, //默认不让canvas二维码隐藏，否则不能生成二维码 imagePath: "" //弹出框二维码显示图片地址&#125;,/*** 生命周期函数--监听页面加载*/onLoad: function(options) &#123; var that = this; var initUrl = 'https://www.baidu.com?id='+id; //创建二维码 that.createQrCode(initUrl, "mycanvas", 170, 170);&#125;/*** 绘制二维码图片*/createQrCode: function(url, canvasId, cavW, cavH) &#123; //调用插件中的draw方法，绘制二维码图片 QR.api.draw(url, canvasId, cavW, cavH); setTimeout(() =&gt; &#123; this.canvasToTempImage(); &#125;, 500); &#125;,/*** 获取临时缓存照片路径，存入data中*/canvasToTempImage: function() &#123; var that = this; //把当前画布指定区域的内容导出生成指定大小的图片，并返回文件路径。 wx.canvasToTempFilePath(&#123; canvasId: 'mycanvas', success: function(res) &#123; var tempFilePath = res.tempFilePath; that.setData(&#123; imagePath: tempFilePath, // canvasHidden:true &#125;); &#125;, fail: function(res) &#123; console.log(res); &#125; &#125;);&#125;,]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE-G]]></title>
    <url>%2F2019%2F06%2F02%2Fvueg%2F</url>
    <content type="text"><![CDATA[本章会介绍 vue-g的用法参考网址为vue-router添加转场效果，只需要Vue.use(vueg)，即可获得转场效果，并能够根据url级别(/)和历史记录判断是前进和后退。 使用方法 / Usage安装 / Installationnpm i vueg -G引入插件12345678import Vue from 'vue' import App from './App' import router from './router'// ↓↓↓↓↓↓↓↓↓↓↓↓import vueg from 'vueg' import 'vueg/css/transition-min.css'Vue.use(vueg, router) //←注意这一句应该在router实例化(router = new VueRouter(&#123;&#125;)之后 禁用动画123456// &lt;router-view&gt;上添加v-transition="false"，可以禁用动画&lt;template&gt; &lt;div id="app"&gt; &lt;router-view v-transition="false"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 配置项 / Config12345678910111213141516const options=&#123; duration: '0.3', //转场动画时长，默认为0.3，单位秒 firstEntryDisable: false, //值为true时禁用首次进入应用时的渐现动画，默认为false firstEntryDuration: '.6', //首次进入应用时的渐现动画时长，默认为.6 forwardAnim: 'fadeInRight', //前进动画，默认为fadeInRight backAnim: 'fadeInLeft', //后退动画，默认为fedeInLeft sameDepthDisable: false, //url深度相同时禁用动画，默认为false tabs: [&#123; name:'home' &#125;,&#123; name:'my' &#125;], //默认为[]，name对应路由的name,以实现类似app中点击tab页面水平转场效果，如tab[1]到tab[0]，会使用backAnim动画，tab[1]到tab[2]，会使用forwardAnim动画 tabsDisable: false, //值为true时，tabs间的转场没有动画，默认为false disable: false, //禁用转场动画，默认为false，嵌套路由默认为true &#125; Vue.use(vueg, router,options) 全部的动画效果见这里组件中配置12345678data()&#123; return &#123; vuegConfig:&#123; forwardAnim:'bounceInUp',//options所有配置可以写在这个对象里，会覆盖全局的配置 disable:false //对于嵌套路由，默认为关闭动画，需要在组件的data.vuegConfig中配置disable为false启用 &#125; &#125;&#125; 注意点 基于vue v2.3.4版本开发、调试 非新项目使用这个插件后，因为css问题，可能造成原本元素在转场动画时有些地方排版错乱，那就需要调整css； 每个路由匹配的组件模板高度最好大于等于屏幕高度，否则转场不好看，可以为 添加class，设置min-height:100%; 插件60Kb左右大小，其中css 57Kb，如果想减小，可以编辑vueg/css/transition-min.css ，将不需要的动画样式删除；]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tapable]]></title>
    <url>%2F2019%2F06%2F02%2Ftapable%2F</url>
    <content type="text"><![CDATA[本文主要讲webpack核心工作流 tapable的一些用法 apply 方法12345Tapable.prototype.apply = function apply() &#123; for(var i = 0; i &lt; arguments.length; i++) &#123; arguments[i].apply(this); &#125;&#125;; 毫无悬念，就是 挨个顺序 执行传入到该函数方法中对象的 apply 方法；通常传入该函数的对象也是 Tapable 插件 对象，因此必然也存在 apply 方法；（Webpack 的插件就是Tapable对象，因此必须要提供 apply 方法 ） 只是更改上下文为当前 this 因此当前这里最大的作用就是传入当前 Tapable 的上下文 tap注册函数 call触发同步方法 SyncHock依次执行所有的注册函数 syncBailHock依次执行所有的注册函数，但是可以判断当返回undefined 停止执行 syncWaterfallHock依次执行所有的注册函数，前一个函数的返回值为后一个的参数 syncLoopHock循环执行注册函数 只有返回undefined 才会继续向下执行 tapAsync注册异步方法 多一个参数回调函数 callAsync触发异步方法 tapPromise注册一个promise函数，返回一个promise对象 promise最后执行注册函数 promise.then()来进行所有完成后的回调 AsyncParallelHook并发执行当所有的注册函数执行完毕 执行最后的方法 比同步多一个回调函数 AsyncParallelBailHook并发执行当所有的注册函数执行完毕 执行最后的方法 比同步多一个回调函数 如果出错了 将不再执行]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE懒加载]]></title>
    <url>%2F2019%2F06%2F02%2Fvue%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[本章会介绍 vue如何进行懒加载 什么是懒加载懒加载也叫延迟加载，即在需要的时候进行加载，随用随载。 如何与webpack配合实现组件懒加载 在webpack配置文件中的output路径配置chunkFilename属性123456output: &#123; path: resolve(__dirname, 'dist'), filename: options.dev ? '[name].js' : '[name].js?[chunkhash]', chunkFilename: 'chunk[id].js?[chunkhash]', publicPath: options.dev ? '/assets/' : publicPath&#125;, chunkFilename路径将会作为组件懒加载的路径 配合webpack支持的异步加载方法 resolve =&gt; require([URL], resolve), 支持性好 () =&gt; import(URL), webpack2官网推荐使用, 属于es7范畴, 需要配合babel的syntax-dynamic-import插件使用, 具体使用方法如下npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es20151234567use: [&#123; loader: 'babel-loader', options: &#123; presets: [['es2015', &#123;modules: false&#125;]], plugins: ['syntax-dynamic-import'] &#125; &#125;] 具体实例中实现懒加载 路由中配置异步组件 12345678910export default new Router(&#123; routes: [ &#123; mode: 'history', path: '/my', name: 'my', component: resolve =&gt; require(['../page/my/my.vue'], resolve),//懒加载 &#125;, ]&#125;) 实例中配置异步组件 1234components: &#123; historyTab: resolve =&gt; &#123;require(['../../component/historyTab/historyTab.vue'], resolve)&#125;,//懒加载 //historyTab: () =&gt; import('../../component/historyTab/historyTab.vue') &#125;, 全局注册异步组件 123Vue.component('mideaHeader', () =&gt; &#123; System.import('./component/header/header.vue')&#125;) 避免问题同时使用懒加载和正常引入1234567891011import historyTab from '../../component/historyTab/historyTab.vue';export default &#123; components: &#123; historyTab &#125;,&#125;export default &#123; components: &#123; historyTab: resolve =&gt; &#123;require(['../../component/historyTab/historyTab.vue'], resolve)&#125;,//懒加载 &#125;,&#125; 异步加载页面中载嵌入异步加载的组件因为在首次加载组件的时候会有加载时间，出现页面滞后，所以需要合理的进行页面结构设计，避免首次出现跳闪现象； 建议最终实现方案 路由页面全都使用懒加载 路由页面中的组件何磊安排 当一个页面中嵌套多个组件时将发送多次的http请求，可能会造成网页显示过慢且渲染参差不齐的问题，所以针对这种特殊情况需要合理安排 结合vuex 动态路由加载页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); export default new Vuex.Store(&#123; state: &#123; //路由组件存储器 routers: &#123;&#125; &#125;, getters: &#123; routers: state =&gt; &#123; return state.data; &#125; &#125;, mutations: &#123; //动态增加路由 addRouter: (state, data) =&gt; &#123; state.routers = Object.assign(&#123;&#125;, state.routers, &#123;[data.name]: data.component&#125;);&#125; &#125;, actions: &#123; acMethods(&#123;commit&#125;) &#123; &#125; &#125;,&#125;)//根目录中注册路由组件window.midea = &#123; registerRouter(name, component) &#123; Store.commit('addRouter', &#123; name: name, component: component &#125;) &#125;&#125;;//页面使用路由导航openAnyPage() &#123; midea.registerRouter('module', resolve =&gt; &#123;require(['../module/module.vue'], resolve)&#125;);//懒加载 this.$router.push(&#123;path: '/home/module', query: &#123;title: this.title&#125;&#125;);&#125;//页面中使用动态组件 &lt;template&gt;&lt;component :is="currentRouter" :moduleName="title"&gt;&lt;/component&gt; &lt;/template&gt;&lt;br&gt;&lt;script src="./any.js"&gt;export default &#123; data () &#123; return &#123; routeName: '', currentRouter: '', title: '', &#125; &#125;, created() &#123; this.routeName = this.$route.params.name; this.title = this.$route.query.title; this.currentRouter = this.$store.state.routers[this.routeName]; &#125;, methods: &#123; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFF]]></title>
    <url>%2F2019%2F06%2F02%2FBFF%2F</url>
    <content type="text"><![CDATA[本文主要讲一种前端设计思想参照这个网站 什么是BFFBFF，即 Backend For Frontend（服务于前端的后端），也就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理，又称为用户体验适配器。 什么时候用BFF 多端运用 我们在设计 API 时会考虑到不同设备的需求，也就是为不同的设备提供不同的 API，虽然它们可能是实现相同的功能，但因为不同设备的特殊性，它们对服务端的 API 访问也各有其特点，需要区别处理。 服务聚合 随着微服务的兴起，原本在同一个进程内运行的业务流程被拆分到了不同的服务中。这在增加业务灵活性的同时，也让前端的调用变得更复杂。BFF 的出现为前端应用提供了一个对业务服务调用的聚合点，它屏蔽了复杂的服务调用链，让前端可以聚焦在所需要的数据上，而不用关注底层提供这些数据的服务。 非必要，莫新增 我们在看到 BFF 带来的各种好处的同时，也要注意到它所带来的代码重复和工作量增加方面的问题。如果与已有 BFF 功能类似，且展现数据的要求也相近的话，一定要谨慎对待新增 BFF 的行为。因此，建议非必要，莫新增。 用法 访问控制 例如，服务中的权限控制，将所有服务中的权限控制集中在 BFF 层，使下层服务更加纯粹和独立。 应用缓存 项目中时常存在一些需要缓存的临时数据，此时 BFF 作为业务的汇聚点，距离用户请求最近，遂将该缓存操作放在 BFF 层。 第三方入口 在业务中需要与第三交互时，将该交互放在 BFF 层，这样可以只暴露必要信息给第三方，从而便于控制第三方的访问。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据管理器]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 定义类1234567891011/**本地存储类*参数 preId 本地存储数据库前缀*参数 timeSign 定义时间戳与存储数据之间的拼接符*/var BaseLocalStorage = function(preId,timeSign)&#123; //定义本地存储数据库前缀 this.preId = preId; //定义时间戳与存储数据之间的拼接符 this.timeSign = timeSign || '|-|'&#125; 定义方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114BaseLocalStorage.prototype = &#123; //状态 status : &#123; SUCCESS : 0,//成功 FAILURE : 1.//失败 OVERFLOW : 2,//溢出 TIMEOUT : 3//过期 &#125;, //window的本地存储 storage : localStorage || window.localStrorage, //获取当前的key getKey : function(key)&#123; return this.preId + key; &#125;, //设置数据 set : function(key,value,callback,time)&#123; //默认成功 var status = this.status.SUCCESS, //获得key值 key = this.getKey(key); try&#123; //获取时间戳 time = new Date(time).getTime() || time.getTime(); &#125;catch(e)&#123; //如果没有获取到，默认一个月 time = new Date(time).getTime() + 1000 * 60 * 60 * 24 * 31; &#125; try&#123; //设置 this.storage.setItem(key , time + this.timeSign + value); &#125;catch(e)&#123; //如果失败了，溢出了 status = this.syatus.OVERFLOW &#125; //执行回调函数 callback &amp;&amp; callback.call(this, status ,key ,value) &#125;, //获取数据 get : function(key,callback)&#123; //默认成功，设置key var status = this.status.SUCCESS, key = this.getKey(key), value = null, timeSignLen = this.timeSign.length, that = this, index, result; //尝试获取值 try&#123; value = that.stirage.getItem(key); &#125;catch(e)&#123; //如果没有获取到 result = &#123; //定义失败。 status : that.status.FAILURE, value : null &#125; //执行回调函数 callback &amp;&amp; callback.call(this, result.status ,result.value); //返回失败 return result; &#125; //拿到数据 if(value)&#123; //获取时间标记下标值 index = value.indexOf(that.timeSign); //获取时间 time = +value.slice(0,index); //比较时间是否过期 if(new Date(time).getTime() &gt; new Date().getTime() || 0)&#123; //没有过期获取真的value value = value.slice(index + timeSignLen); &#125;else&#123; //过期了，设置过期，并移除原来的数据 value = null, status = that.status.TIMEOUT; that.remove(key); &#125; &#125;else&#123; //获取失败 status = that.status.FAILURE; &#125; //定义结果 result = &#123; status : status, value : value &#125;; //执行回掉函数并返回值 callback &amp;&amp; callback.call(this, result.status ,result.value); return result; &#125;, //移除数据 remove : function(key,callback)&#123; //定义初始失败，并获取key var status = this.status.FAILURE, key = this.getKey(key), value = null; //尝试获取值 try&#123; //得到值了 value = that.stirage.getItem(key); &#125;catch(e)&#123;&#125; //如果获取到了值 if(value)&#123; try&#123; //移除值，并设置成功 this.storage.removeItem(key); status = this.status.SUCCESS; &#125;catch(e)&#123;&#125; &#125; //执行回掉函数 callback &amp;&amp; callback.call(this, status ,status &gt; 0 ? null : value.slice(value.indexOf(this.timeSign) + this.timeSign.length)); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F06%2F01%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 类式继承123456789101112131415161718//声明父类function SuperClass()&#123; this.superVal = true&#125;//为父类添加方法SuperClass.prototype.getSuperVal = function()&#123; return this.superVal&#125;//声明子类function SubClass()&#123; this.subVal=false&#125;//继承父类SubClass.prototype=new SuperClass();//添加子类方法SubClass.prototype.getSubVal = function()&#123; return this.subVal&#125; 构造函数继承12345678910111213141516171819//声明父类function SuperClass(id)&#123; //值类型共有属性 this.id=id; //引用类型共有属性 this.books=["java","css"]&#125;//父类型声明原型方法SuperClass.prototype.showBooks = function()&#123; console.log(this.books)&#125;//声明子类function SubClass(id)&#123; //继承父类 SuperClass.call(this,id)&#125;//创建子类实例var instance1 = new SubClass(10);var instance2 = new SubClass(11); 组合继承12345678910111213141516171819202122232425262728//声明父类function SuperClass(id)&#123; //值类型共有属性 this.id=id; //引用类型共有属性 this.books=["java","css"]&#125;//父类型声明原型方法SuperClass.prototype.showBooks = function()&#123; console.log(this.books)&#125;//声明子类function SubClass(id,time)&#123; //继承父类 SuperClass.call(this,id) //新增共有属性 this.time=time&#125;//类式继承SubClass.prototype = new SuperClass();//子类原型方法SubClass.prototype.getTime = function()&#123; console.log(this.time)&#125;//创建子类实例var instance1 = new SubClass(10,"2017");var instance2 = new SubClass(11,"2018"); 寄生组合式继承复制一个对象的prototype Object.create(o.prototype) function object(o){ function F(){} F.prototype = o; return new F(); } 寄生组合12345678function inheritPrototype(subType,superType)&#123; //object()方法是ES5前Object.create()的非规范化实现 var prototype=object(superType.prototype); //增强对象 prototype.constructor = subType; //指定对象 subType.prototype = prototype;&#125; 使用123456789101112131415161718192021222324//声明父类function SuperClass(id)&#123; //值类型共有属性 this.id=id; //引用类型共有属性 this.books=["java","css"]&#125;//父类型声明原型方法SuperClass.prototype.showBooks = function()&#123; console.log(this.books)&#125;//声明子类function SubClass(id,time)&#123; //继承父类 SuperClass.call(this,id) //新增共有属性 this.time=time&#125;//继承inheritPrototype(SubClass,SuperClass)'//子类增加原型方法SubClass.prototype.getTime = function()&#123; console.log(this.time);&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%A7%82%E5%AF%9F%E8%80%85%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 创建一个观察者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var Observer=(function()&#123; //建立闭包保存消息 var _messages=&#123;&#125;; return&#123; //注册接口 regist : function(type,fn)&#123; //如果不存在这个消息类型，创建一个，否则推入对应的执行队列中去 if(typeof _messages[type] === "undefined")&#123; //将消息推入动作执行队列中 _messages[type] = [fn]; &#125;else&#123; //将消息推入动作执行队列中 _messages[type].push(fn); &#125; &#125; , //发布信息接口 fire : function(type,args)&#123; //如果不存在，直接退出 if(!_messages[type]) return; //定义消息的信息及参数 var events = &#123; type:type,//消息类型 args :args || &#123;&#125;//消息参数 &#125;,i = 0,len = _messages[type].length; //便利消息队列 for(;i&lt; len;i++)&#123; //依次执行对应的动作 _messages[type][i].call(this,events) &#125; &#125;, //移出信息接口 remove : function(type,fn)&#123; debugger; //判断消息队列存在 if(_messages[type] instanceof Array)&#123; //遍历消息队列 var i = _messages[type].length - 1; for(;i&gt;=0;i--)&#123; //移除相应的动作函数 _messages[type][i] === fn &amp;&amp; _messages[type].splice(i,1); &#125; &#125; &#125;, getMessages:function()&#123; return _messages; &#125; &#125;&#125;)() 对象间解耦1234567891011121314151617181920212223242526272829303132333435363738//学生类var Student = function(result)&#123; var that=this; //回答结果； that.result = result; //回答问题 that.say = function()&#123; console.log(that.result) &#125;&#125;//回答问题的方法Student.prototype.answer = function(quertion)&#123; Observer.regist(quertion,this.say)&#125;//增加睡觉的方法Student.prototype.sleep = function(quertion)&#123; //解除说话的队列 Observer.remove(quertion,this.say)&#125;//教师类var Teacher = function()&#123;&#125;//发布问题Teacher.prototype.ask = function(question)&#123; Observer.fire(question)&#125;var student1 = new Student("11");var student2 = new Student("22");var student3 = new Student("33");student1.answer("who")student2.answer("who")student3.answer("who")student1.answer("where")student2.answer("where")var teacher = new Teacher();teacher.ask("who")teacher.ask("where")]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 列表缓存123456789101112131415161718192021//列表var Page = function()&#123; //定义缓存 var cache=&#123;&#125;; return function(page,fn)&#123; //命中缓存 if(cache[page])&#123; showPage(page,cacge[page]); fn&amp;&amp;fn(); &#125;else&#123; //对请求回来的数据进行缓存 $.post("",&#123;&#125;,function(res)&#123; if(res)&#123; showPage(page,res.data); cache[page]=res.data; fn&amp;&amp;fn() &#125; &#125;) &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 以canvas为例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//定义构造函数var CanvasCommand = function(domId)&#123; //获取当前id的dom var canvas = document.getElementById(domId), ctx = canvas.getContext("2d"), //定义一些方法 Action = &#123; //填充色 fillStyle : function(c)&#123; ctx.fillStyle = c; &#125;, //填充方块 fillRect : function(x,y,width,height)&#123; ctx.fillRect(x,y,width,height) &#125;, //描边色 strokeStyle : function(c)&#123; ctx.strokeStyle(c); &#125;, //描边方块 strokeRect : function(x,y,width,height)&#123; ctx.strokeRect(x,y,width,height); &#125;, //画文字 fillText : function(text,x,y)&#123; ctx.fillText(text,x,y) &#125;, //开始路径 beginPath : function()&#123; ctx.beginPath() &#125;, //移动到 moveTo : function(x,y)&#123; ctx.moveTo(x,y) &#125;, //画直线 lineTo : function(x,y)&#123; ctx.lineTo(x,y) &#125;, //画孤线 arc : function(x,y,r,begin,end,dir)&#123; ctx.arc(x,y,r,begin,end,dir) &#125;, //填充 fill : function()&#123; ctx.fill() &#125;, //描边 stroke : function()&#123; ctx.stroke() &#125;, &#125;; return &#123; //返回的方法 excute : function(msg)&#123; //没有指令 if(!msg) return; //多个指令，逐个遍历 if(msg.length)&#123; for(var i = 0;i&lt;msg.length;i++)&#123; arguments.callee(msg[i]); &#125; &#125;else&#123; msg.param = Object.prototype.toString.call(msg.param) === "[object Array]" ? msg.param : [msg.param]; Action[msg.command].apply(Action,msg.param); &#125; &#125; &#125;&#125; 使用方法1234567//初始化domIdvar mycanvas = new CanvasCommand("domId");//使用命令画图mycanvas.excute([ &#123;command : 'fillStyle',param : "red"&#125;, &#123;command : 'fillRect',param : [20,20,100,100]&#125;])]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节流模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%8A%82%E6%B5%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 节流函数12345678910111213141516171819202122232425262728293031//节流器var throttle = function()&#123; //获取第一个参数 var isClear = arguments[0],fn; //如果第一个参数是boolean类型，那么第一个参数则表示是否清楚计时器 if(typeof isClear === 'boolean')&#123; //第二个参数则为函数 fn = arguments[1]; //函数计时器句柄存在，则清楚函数计时器 fn._throttleID &amp;&amp; clearTimeout(fn._throttleID); //通过计时器延迟函数的执行 &#125;else&#123; //第一个参数为函数 fn = isClear; //第二个参数为函数执行时的参数 param = arguments[1]; //对执行时的参数适配默认值，这里我们用到以前学过的extend方法 var p = extend(&#123; context:null, args:[], time:300 &#125;,param); //清楚函数执行计时器句柄， arguments.callee(true,fn); //作为函数绑定延迟计时器句柄，延迟执行函数 fn._throttleID = setTimeout(function()&#123; //执行函数 fn.apply(p.context,p.args); &#125;,p.time); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 实现迭代器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//迭代器var Iterator = function(items)&#123; //获取长度，下标 var length = items.length, index = 0, splice = [].splice; return &#123; //第一个元素 first : function()&#123; index = 0; return items[index]; &#125;, //最后一个元素 last : function()&#123; index = length-1; return items[index]; &#125;, //前一个元素 pre : function()&#123; if(--index &gt; 0)&#123; return items[index] &#125;else&#123; index = 0; return null; &#125; &#125;, //下一个元素 next : function()&#123; if(++index &lt; length)&#123; return items[index] &#125;else&#123; index = length-1; return null; &#125; &#125;, //获取某一个 num 的元素 get : function(num)&#123; index = num&gt;=0 ? num % length : num % length + length; return items[index]; &#125;, //进行 fn 的全量处理 dealEach : function(fn)&#123; var args = splice.call(arguments,1); for(var i=0;i&lt;length;i++)&#123; fn.apply(items[i],args); &#125; &#125;, //对某一个 num 的元素进行 fn 的处理 dealItem : function(num,fn)&#123; fn.apply(this.get(num),splice.call(arguments,2)) &#125;, //对 mem 中的元素 进行 numFn 的处理 allFn 针对所有的处理 exclusive : function(mem,allFn,numFn)&#123; this.dealEach(allFn); if(Array.isArray(mem))&#123; for(var i=0;i&lt;mem.length;i++)&#123; this.dealItem(mem[i],numFn) &#125; &#125;else&#123; this.dealItem(mem,numFn) &#125; &#125; &#125;&#125; 数组迭代器123456789var eachArray = function(arr,fn)&#123; var i = 0, len = arr.length; for(;i &lt; len;i++)&#123; if(fn.call(arr[i],i,arr[i]) === false)&#123; break; &#125; &#125;&#125; 对象迭代器1234567var eachObj = function(obj,fn)&#123; for(var i in obj)&#123; if(fn.call(obj[i],i,obj[i]) === false)&#123; break; &#125; &#125;&#125; 分支循环嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 绘制特效图片*param t 类型*param x x坐标*param y y坐标*param w 宽度*param h 高度*param a 透明度*/function dealImage(t,x,y,w,h,a)&#123; var canvasData = ctx.getImageData(x,y,w,h), data = canvasData.data, //封装算法 Deal = function ()&#123; var method = &#123; default : function(i)&#123; return method["gray"](i) &#125;, red : function()&#123; data[i + 1] = 0; data[i + 2] = 0; data[i + 3] = a; &#125;, green : function()&#123; data[i + 0] = 0; data[i + 2] = 0; data[i + 3] = a; &#125; blue : function()&#123; data[i + 1] = 0; data[i + 0] = 0; data[i + 3] = a; &#125;, grey : function()&#123; data[i] = data[i + 1]=parseInt(data[i + 2] = (data[i + 0] + data[i + 1] +data[i + 2])/3); data[i + 3] = a; &#125; &#125; return function(type)&#123; return method[type] || method["default"] &#125; &#125;(); //迭代器处理数据 function eachData(fn)&#123; for(var i = 0,len = data.length;i &lt; len;i += 4)&#123; fn(i); &#125; &#125;; //处理数据 eachData(Deal(t)); ctx.putImageData(canvasData,width+x,y);&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[惰性模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%83%B0%E6%80%A7%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 事件绑定方法一 加载的时候重新定义 on方法12345678910111213141516171819//对事件绑定的重新定义A.on = function(dom, type,fn)&#123; //不是ie的情况下 if(document.addEventListenter)&#123; return function(dom, type,fn)&#123; dom.addEventListenter(type,fn,false); &#125; &#125;else if(document.attachEvent)&#123; //IE的情况下 return function(dom, type,fn)&#123; dom.attachEvent("on" + type,fn); &#125; &#125;else&#123; //否则 return function(dom, type,fn)&#123; dom.attachEvent("on" + type) = fn; &#125; &#125;&#125;(); 方法二 执行的时候定义方法123456789101112131415161718192021//对事件绑定的重新定义A.on = function(dom, type,fn)&#123; //不是ie的情况下 if(document.addEventListenter)&#123; A.on = function(dom, type,fn)&#123; dom.addEventListenter(type,fn,false); &#125; &#125;else if(document.attachEvent)&#123; //IE的情况下 A.on = function(dom, type,fn)&#123; dom.attachEvent("on" + type,fn); &#125; &#125;else&#123; //否则 A.on = function(dom, type,fn)&#123; dom.attachEvent("on" + type) = fn; &#125; &#125; //定义后重新执行方法 A.on(dom, type,fn);&#125;();]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建本地运行环境]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[如何利用http-serve搭建环境 利用http-serverhttp http-server全局安装http-servernpm install http-server -g使用httphttp-server [path] [options]具体含义123456789101112131415161718192021222324252627282930313233-p 要使用的端口（默认为8080）-a 要使用的地址（默认为0.0.0.0）-d 显示目录列表（默认为“True”）-i 显示autoIndex（默认为“True”）-g或--gzip启用时（默认为“False”），它将用于./public/some-file.js.gz代替./public/some-file.jsgzip压缩版本的文件，并且该请求接受gzip编码。-e或--ext默认文件扩展名（如果没有提供）（默认为&apos;html&apos;）-s或--silent从输出中抑制日志消息--cors通过Access-Control-Allow-Origin标题启用CORS-o 启动服务器后打开浏览器窗口-c设置缓存控制max-age头的缓存时间（以秒为单位），例如-c10 10秒（默认为&apos;3600&apos;）。要禁用缓存，请使用-c-1。-U或--utc在日志消息中使用UTC时间格式。-P或--proxy代理无法在本地解决给定网址的所有请求。例如：-P http://someurl.com-S或--ssl启用https。-C或--certssl证书文件的路径（默认值：cert.pem）。-K或--keyssl密钥文件的路径（默认值：key.pem）。-r或者--robots提供一个/robots.txt（其内容默认为&apos;User-agent：* \ nDisallow：/&apos;）-h或--help打印此列表并退出。 使用httpsopenssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem http-server -S -C cert.pem -o 安装XAMPP利用xampp搭建本地服务第一步：安装第二部：找到 C:\xampp\htdocs 将文件放置在次目录下第三部：启动 config 可以对端口号进行配置]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 策略算法12345678910111213141516171819202122232425262728//表单验证对象var InputStrategy = function()&#123; var strategy=&#123; //是否为空 notNull : function(value)&#123; return /\s+/.test(value)?"":"请输入内容" &#125;, //是否为数字 number : function(value)&#123; return /^[0-9]+(\.[0-9]+)?$/.test(value)?"":"请输入数字" &#125;, //是否是手机号 phone : function(value)&#123; return /^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d&#123;8&#125;$/.test(value)?"":"请输入正确的电话" &#125; &#125; return &#123; //验证 check : function(type,value)&#123; value = typeof value === "string" ? value.trim() : value; return strategy[type] ? strategy[type](value):"没有该类型"; &#125;, //添加验证类型 addStrategy :function(type,fn)&#123; strategy[type] = fn &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//新建玛丽的类var MarryState = function()&#123; //内部私有变量 var _currentState = &#123;&#125;, //状态和方法的映射 states = &#123; jump : function()&#123; //跳 console.log("jump") &#125;, move : function()&#123; //移动 console.log("move") &#125;, shoot : function()&#123; //射击 console.log("shoot") &#125;, squat : function()&#123; //蹲下 console.log("squat") &#125; &#125;, //动作控制类 Action = &#123; //改变状态方法 changeState : function()&#123; var arg = arguments; //重置动作 _currentState = &#123;&#125;; //追加动作 if(arg.length)&#123; for(var i = 0,len = arg.length;i&lt;len;i++)&#123; _currentState[arg[i]] = true; &#125; &#125; return this; &#125;, //执行动作 goes : function()&#123; //遍历执行动作 for(var i in _currentState)&#123; states[i] &amp;&amp; states[i](); &#125; return this; &#125; &#125;; //返回动作类 return &#123; change : Action.changeState, goes : Action.goes &#125;&#125; 使用方法12345678910//new marry个人var marry = new MarryState();//方法的调用marry .change("jump","shoot") .goes() .change("move","shoot") .goes() .change("squat","shoot") .goes();]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 闭包实现构造函数var Book=(function(){ //静态私有变量 var bookNum=100; //静态私有方法 function checkBook(name){} //创建类 function _book(newId, newName, newPrice){ //私有变量 //var name,price; //私有方法 function checkId(id){} //特权方法 this.getName=function(){} this.getPrice=function(){} this.setName=function(){} this.setPrice=function(){} //公有属性 this.id=newId; //公有方法 this.copy=function(){}; bookNum++; if(bookNum&gt;100) throw new Error(&quot;只有100本书可以被创建&quot;) //构造器 this.setName(name); this.setPrice(price); } //构建原型 _book.prototype = { //静态公有变量 isJsBook : false, //静态公有方法 display : function(){} }; //返回类 return _book; })() 安全模式12345678910//构造函数，防止未new直接var mybook = Book();var Book=function(title,time,type)&#123; if(this instanceof Book)&#123; this.title = title; this.time = time; this.type = type; &#125;else&#123; return new Book(title,time,type); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[订阅者模式]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式在JS应用 中介者对象1234567891011121314151617181920212223//订阅者var Mediator = function()&#123; //内部存储 var _msg = &#123;&#125;; return &#123; //注册消息 register : function(type,action)&#123; if(_msg[type])&#123; _msg[type].push(action) &#125;else&#123; _msg[type]=[action] &#125; &#125;, //发布消息 send : function(type)&#123; if(_msg[type])&#123; for(var i=0;i&lt;_msg[type].length;i++)&#123; _msg[type][i]&amp;&amp;_msg[type][i](); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JS设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学react]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%88%9D%E5%AD%A6react%2F</url>
    <content type="text"><![CDATA[react初步学习react+react-router+redux+fetch+babel+webpack这篇文章写得很好 react脚手架123456789101112// 安装脚手架npm install -g create-react-app// 创建自己的项目create-react-app my-app// 进入项目cd my-app// 启动项目npm start// 展开webpack配置文件，进行相关的打包优化及配置yarn eject// script文件夹中进行打包的配置// 在config中是关于webpack的配置 yarn 包工具yarn config set registry 你的npm仓库 react 生命周期getDefaultProps设置默认的props，也可以用dufaultProps设置组件的默认属性. getInitialState在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props componentWillMount组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 renderreact最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 componentDidMount组件渲染之后调用，只调用一次。 componentWillReceiveProps(nextProps)组件初始化时不调用，组件接受新的props时调用。 shouldComponentUpdate(nextProps, nextState)react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候 componentWillUpdate(nextProps, nextState)组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state，只能通过 nextState.name = ‘你想要更改的值’ 的办法来改变 componentDidUpdate组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 componentWillUnmount组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 配置// 配置proxy package.json &quot;proxy&quot;: { &quot;^apis&quot;:{ &quot;target&quot;:&quot;http://xxx.xxx&quot;, &quot;changeOrigin&quot;:true } } // 配置css预处理less/sass yarn add less-loader less --dev yarn add sass-loader node-sass --dev // webpack.config.dev.js module: { strictExportPresence: true, //... rules: [ // ... { test: /\.(css|less)$/, // 修改 use: [ require.resolve(&apos;style-loader&apos;), { loader: require.resolve(&apos;css-loader&apos;), options: { importLoaders: 1, }, }, { loader: require.resolve(&apos;postcss-loader&apos;), options: {}, }, // 增加 { loader: require.resolve(&apos;less-loader&apos;) // compiles Less to CSS } ], }, ] // webpack.config.prod.js { test: /\.(css|less)$/, // 修改 loader: ExtractTextPlugin.extract( Object.assign( { fallback: { loader: require.resolve(&apos;style-loader&apos;), options: { hmr: false, }, }, use: [ // ...code { loader: require.resolve(&apos;less-loader&apos;) // 增加 } ], }, extractTextPluginOptions ) ), } // 别名 webpack.config.prod.js webpack.config.dev.js alias: { &apos;react-native&apos;: &apos;react-native-web&apos;, // +++ 加入配置 &apos;@&apos;: resolve(&apos;src&apos;) } // webpack.config.prod.js 去掉map文件 - devtool: shouldUseSourceMap ? &apos;source-map&apos; : false // 改为 devtool: false, // 修改端口号 node_modules/react-scripts/scripts/start.js中：把3000端口修改成自己想要的端口 // 模块热替换 npm i react-hot-loader -D webpack.config.dev.js中entry第一行增加`&apos;react-hot-loader/patch&apos;， .babelrc { &quot;presets&quot;: [ [&quot;es2015&quot;, {&quot;loose&quot;: true}], &quot;react&quot; ], &quot;plugins&quot;: [&quot;react-hot-loader/babel&quot;] } // webpack.config.dev.js { test: /\.(js|jsx|mjs)$/, include: paths.appSrc, loader: require.resolve(&apos;babel-loader&apos;), options: { // This is a feature of `babel-loader` for webpack (not Babel itself). // It enables caching results in ./node_modules/.cache/babel-loader/ // directory for faster rebuilds. cacheDirectory: true, plugins: [ &apos;react-hot-loader/babel&apos; ] }, }, // index.js if (module.hot) { module.hot.accept(&apos;./App&apos;, () =&gt; { // 当我们热更新的代码出现的时候，把App重新加载 const NextApp = require(&apos;./App&apos;).default //因为在App里使用的是export default语法，这里使用的是require,默认不会加载default的，所以需要手动加上 render(NextApp) // 重新渲染到 document 里面 }) }]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包规定]]></title>
    <url>%2F2019%2F05%2F30%2Fwebpack%E6%89%93%E5%8C%85%E8%A7%84%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[文中主要讲一些优化方案 使用vuecli3 webpack兼容 IE123456789101112131415161718192021222324252627282930313233// 第一步,安装依赖npm install --save babel-polyfill安装安装依赖依赖// 第二步 然后在main.js中的最前面引入babel-polyfillimport &apos;babel-polyfill&apos;// 在config中的webpack.base.conf.js中,修改编译配置entry:&#123; app:[&apos;babel-polyfill&apos;,&apos;./src/main.js&apos;]&#125;// 在规则中加入解析的内容module:&#123; rules: [ &#123; test: /\.js$/, loader: &apos;babel-loader&apos;, include: [ resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;), resolve(&apos;/node_modules/element-ui/src&apos;), resolve(&apos;/node_modules/element-ui/pachages&apos;), resolve(&apos;/node_modules/_element-ui@2.3.4@_element-ui/src&apos;), resolve(&apos;/node_modules/_element-ui@2.3.4@_element-ui/pachages&apos;), resolve(&apos;/node_modules/easyscroll/src&apos;), resolve(&apos;/node_modules/_easyscroll@1.0.1@easyscroll/src&apos;) ] &#125; ]&#125;// 在vuecli3中chainWebpack:config=&gt;&#123; config.entry(&apos;main&apos;).add(&apos;babel-polyfill&apos;)&#125; webpack 使用按需加载elementUI按需引入官方文档1234567891011121314npm install babel-plugin-component -D// 将 .babelrc 修改为&#123; &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]], &quot;plugins&quot;: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; antdesignvue官方文档12345678910111213141516171819202122232425262728yarn add babel-plugin-import --dev// Modify babel.config.js module.exports = &#123; presets: [&quot;@vue/app&quot;],+ plugins: [+ [+ &quot;import&quot;,+ &#123; libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: true &#125;+ ]+ ]&#125;; // src/main.js import Vue from &apos;vue&apos;- import Button from &apos;ant-design-vue/lib/button&apos;;+ import &#123; Button &#125; from &apos;ant-design-vue&apos;;- import &apos;ant-design-vue/dist/antd.css&apos; import App from &apos;./App&apos; Vue.component(Button.name, Button) Vue.config.productionTip = false /* eslint-disable no-new */ new Vue(&#123; el: &apos;#app&apos;, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos; &#125;) CDN加载1234567891011121314151617181920212223242526272829// 在vue.config.js文件:module.exports = &#123; chainWebpack: config =&gt; &#123; // 压缩代码 config.optimization.minimize(true); // 分割代码 config.optimization.splitChunks(&#123; chunks: &apos;all&apos; &#125;) // 用cdn方式引入 config.externals(&#123; &apos;vue&apos;: &apos;Vue&apos;, &apos;vuex&apos;: &apos;Vuex&apos;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;axios&apos;: &apos;axios&apos; &#125;) &#125;&#125;// 在html中&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.runtime.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt;// 提取CSSmodule.exports = &#123; css: &#123; extract: true &#125;&#125; gzip的压缩123456789101112131415161718192021222324252627282930313233npm install --save-dev compression-webpack-pluginconst CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;)const compress = new CompressionWebpackPlugin( &#123; filename: info =&gt; &#123; return `$&#123;info.path&#125;.gz$&#123;info.query&#125;` &#125;, algorithm: &apos;gzip&apos;, threshold: 10240, test: new RegExp( &apos;\\.(&apos; + [&apos;js&apos;].join(&apos;|&apos;) + &apos;)$&apos; ), minRatio: 0.8, deleteOriginalAssets: false &#125;)module.exports = &#123;devServer: &#123; before(app, server) &#123; app.get(/.*.(js)$/, (req, res, next) =&gt; &#123; req.url = req.url + &apos;.gz&apos;; res.set(&apos;Content-Encoding&apos;, &apos;gzip&apos;); next(); &#125;) &#125; &#125; configureWebpack: &#123; plugins: [compress] &#125; 去除console.log123456789101112131415161718192021222324252627282930313233343536373839// 方法一const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);module.exports = &#123; configureWebpack: config =&gt; &#123; if (IS_PROD) &#123; const plugins = []; plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console: true, drop_debugger: false, pure_funcs: [&apos;console.log&apos;]//移除console &#125; &#125;, sourceMap: false, parallel: true &#125;) ); config.plugins = [ ...config.plugins, ...plugins ]; &#125; &#125;&#125;// 方法二npm i --save-dev babel-plugin-transform-remove-console// 在babel.config.js中配置const plugins = [];if([&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV)) &#123; plugins.push(&quot;transform-remove-console&quot;)&#125;module.exports = &#123; presets: [[&quot;@vue/app&quot;,&#123;&quot;useBuiltIns&quot;: &quot;entry&quot;&#125;]], plugins: plugins&#125;; 环境配置在根目录新建2个文件，分别为.env.development，.env.production，.env.test项目变量1234567891011VUE_APP_BASE_API = &apos;变量值&apos;// 取值process.env.VUE_APP_BASE_API// 更改package.json文件 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;test&quot;: &quot;vue-cli-service serve --mode test&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:test&quot;: &quot;vue-cli-service build --mode test&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, 设置别名参考下方123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123const path = require(&quot;path&quot;);const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);const isProduction = process.env.NODE_ENV === &apos;production&apos;;const cdn = &#123; css: [], js: [ &apos;https://cdn.bootcss.com/vue/2.5.17/vue.runtime.min.js&apos;, &apos;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&apos;, &apos;https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js&apos;, &apos;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&apos;, ]&#125;function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; // 基本路径 baseUrl: &apos;./&apos;, // 输出文件目录 outputDir: &apos;dist&apos;, // 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 // assetsDir: &quot;./&quot;, // 指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径 indexPath: &apos;./&apos;, // eslint-loader 是否在保存的时候检查 lintOnSave: true, // webpack配置 // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md chainWebpack: config =&gt; &#123; config .entry(&apos;index&apos;) .add(&apos;babel-polyfill&apos;) .end(); // 配置别名 config.resolve.alias .set(&quot;@&quot;, resolve(&quot;src&quot;)) .set(&quot;@img&quot;, resolve(&quot;src/assets/images&quot;)) .set(&quot;@css&quot;, resolve(&quot;src/assets/styles/css&quot;)) .set(&quot;@scss&quot;, resolve(&quot;src/assets/styles/scss&quot;)); // 生产环境配置 if (isProduction) &#123; // 删除预加载 config.plugins.delete(&apos;preload&apos;); config.plugins.delete(&apos;prefetch&apos;); // 压缩代码 config.optimization.minimize(true); // 分割代码 config.optimization.splitChunks(&#123; chunks: &apos;all&apos; &#125;) // 生产环境注入cdn config.plugin(&apos;html&apos;) .tap(args =&gt; &#123; args[0].cdn = cdn; return args; &#125;); &#125; &#125;, configureWebpack: config =&gt; &#123; if (isProduction) &#123; // 用cdn方式引入 config.externals = &#123; &apos;vue&apos;: &apos;Vue&apos;, &apos;vuex&apos;: &apos;Vuex&apos;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;axios&apos;: &apos;axios&apos; &#125; // 为生产环境修改配置... config.plugins.push( //生产环境自动删除console new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_debugger: true, drop_console: true, &#125;, &#125;, sourceMap: false, parallel: true, &#125;) ); &#125; else &#123; // 为开发环境修改配置... &#125; &#125;, // 生产环境是否生成 sourceMap 文件 productionSourceMap: false, // css相关配置 css: &#123; // 是否使用css分离插件 ExtractTextPlugin extract: true, // 开启 CSS source maps? sourceMap: false, // css预设器配置项 loaderOptions: &#123; // pass options to sass-loader sass: &#123; // 引入全局变量样式 data: ` @import &quot;@/stylePath/theme.scss; ` &#125; &#125;, // 启用 CSS modules for all css / pre-processor files. modules: false, &#125;, // use thread-loader for babel &amp; TS in production build // enabled by default if the machine has more than 1 cores parallel: require(&apos;os&apos;).cpus().length &gt; 1, devServer: &#123; port: 8888, // 端口 open: true, // 自动开启浏览器 compress: false, // 开启压缩 overlay: &#123; warnings: true, errors: true &#125; &#125;,&#125;]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作字体图标]]></title>
    <url>%2F2019%2F05%2F30%2F%E5%88%B6%E4%BD%9C%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[制作字体图标主要讲了怎么利用svg制作属于自己的字体图标，适合结合公司UI制作一套自己公司的图标 方法https://icomoon.io/app/#/select1、打开上述网站，然后选择导入图标，导入自己的SVG文件2、选择你上传的图标3、点击generatate font4、勾选选项，起名字以及一些支持IE等选项5、下载，文件中包含案列及使用方法，以及各种字体的文件6、根据Dome使用字体图标 第二种方法在icon-font 阿里字体图标库中建立团队 直接下载]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>ICON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片规范]]></title>
    <url>%2F2019%2F05%2F30%2F%E5%9B%BE%E7%89%87%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[#图片规范 图片格式 常见的图片格式有 GIF、PNG8、PNG24、JPEG、WEBP，根据图片格式的特性和场景需要选取适合的图片格式。 GIF GIF图象是基于颜色列表的（存储的数据是该点的颜色对应于颜色列表的索引值），最多只支持8位（256色）。GIF文件内部分成许多存储块，用来存储多幅图象或者是决定图象表现行为的控制块，用以实现动画和交互式应用。GIF文件还通过LZW压缩算法压缩图象数据来减少图象尺寸 特性 优秀的压缩算法使其在一定程度上保证图像质量的同时将体积变得很小。 可插入多帧，从而实现动画效果。 可设置透明色以产生对象浮现于背景之上的效果。 由于采用了8位压缩，最多只能处理256种颜色，故不宜应用于真彩色图片。 png PNG是20世纪90年代中期开始开发的图像文件存储格式，其目的是企图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。流式网络图形格式(Portable Network Graphic Format，PNG)名称来源于非官方的“PNG’s Not GIF”，是一种位图文件(bitmap file)存储格式，读成“ping”。PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的α通道数据。PNG使用从LZ77派生的无损数据压缩算法。 特性 支持256色调色板技术，文件体积小。 无损压缩 最高支持48位真彩色图像以及16位灰度图像。 支持Alpha通道的透明/半透明特性。 支持图像亮度的Gamma校准信息。 支持存储附加文本信息，以保留图像名称、作者、版权、创作时间、注释等信息。 渐近显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌。 使用CRC防止文件出错。 最新的PNG标准允许在一个文件内存储多幅图像。 JPEG JPEG是一种针对照片视频而广泛使用的一种有损压缩标准方法。这个名称代表Joint Photographic Experts Group（联合图像专家小组）。此团队创立于公元1986年，1992年发布了JPEG的标准而在1994年获得了ISO 10918-1的认定 特性 适用于储存24位元全采影像 采取的压缩方式通常为有损压缩 不支持透明或动画 压缩比越高影像耗损越大，失真越严重 压缩比在10左右肉眼无法辨出压缩图与原图的差别 WEBP WebP，是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自视频编码格式 VP8，是由Google在购买On2 Technologies后发展出来。WebP最初在2010年发布，2011年11月8日，Google开始让WebP支持无损压缩和透明色的功能，而在2012年8月16日的参考实做libwebp 0.2.0中正式支持 特性： 同时提供有损压缩和无损压缩两种图片文件格式 文件体积小，无损压缩后，比 PNG 文件少了 45％ 的文件大小；有损压缩后，比 JPEG 文件少了 25% - 34% 文件大小 浏览器兼容差，目前只支持客户端 Chrome 和 Opera 浏览器以及安卓原生浏览器(Andriod 4.0+)，WebP兼容性 团队约定内容图内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大 优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式 尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大 背景图背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片 PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式 图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式 图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式 条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式 图片大小 中国普通家庭的宽带基本能达到8Mbps，实际速率大约为500—900KB/s，全国3G/4G用户占有比超过了50%，为了保证图片能更好地加载展示给用户看，团队约定： PC平台单张的图片的大小不应大于 200KB。 移动平台单张的图片的大小不应大于 100KB。 图片质量 上线的图片都应该经过压缩处理，压缩后的图片不应该出现肉眼可感知的失真区域 60质量的JPEG格式图片与质量大于60的相比，肉眼已看不出明显的区别，因此保存 JPEG 图的时候，质量一般控制在60，若保真度要求高的图片可适量提高到 80，图片大小控制在 200KB 以内 图片引入 测试内容图应该写上表明图片尺寸的占位图，可以用线上占位图生成服务，如： http://placeholder.qiniudn.com/300x200 HTML 中图片引入不需添加 width、height 属性，alt 属性应该写上12推荐：&lt;img src="" alt="" &gt; 12不推荐：&lt;img src="" width="" height="" &gt; CSS 中图片引入不需要引号123.jdc &#123; background-image: url(icon.png);&#125; CSS Sprites VS Data URIsCSS Sprites特点 减少请求数 加速图片的显示 维护更新成本大 更多的内存消耗，特别是大体积或有过多空白的 Sprites 图 图片渗漏，相邻的不需展示的图片有可能出现在展示元素中，特别是在高清设备移动设备上 Data URIs（base64编码） 减少请求数 转换文件体积大，大约比原始的二进制大33% IE6 / IE7 不支持 图片显示相对较慢，需要更多的CPU消耗 团队约定CSS Sprites 使用建议 适合使用频率高更新频率低的小图标 尽量不留太多的空白 体积较大的图片不合并 确保要合并的小图坐标数值和合并后的 Sprites 图尺寸均为偶数 Data URIs（base64编码）使用建议 适合更新频率高的小图片，如某些具备自定义功能的标题icon等 转换成 Base64 编码的图片应小于 2KB 移动端不使用 Base64 编码 要兼容 IE6/IE7 的不使用]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM搭建]]></title>
    <url>%2F2019%2F05%2F29%2FNPM%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[NPM搭建本章会介绍 CNPM 的基础部署方法 准备 部署的宿体，如服务器、云主机、自己的电脑等； 数据库，支持 MySQL、PostgreSQL、MariaDB，如果使用 SQLite则无需准备； Git 客户端（推荐）。克隆 CNPM 123git clone https://github.com/cnpm/cnpmjs.org.git//安装依赖npm install 修改配置文件123'use strict';module.exports = &#123;&#125;; enableCluster 是否启用 cluster-worker 模式启动服务，默认 false，生产环节推荐为 true; registryPort API 专用的 registry 服务端口，默认 7001 webPort Web 服务端口，默认 7002 bindingHost 监听绑定的 Host，默认为 127.0.0.1，如果外面架了一层本地的 Nginx 反向代理或者 Apache 反向代理的话推荐不用改 sessionSecret session 用的 logdir 日志目录 uploadDir 临时上传文件目录 viewCache 视图模板缓存是否开启，默认为 false enableCompress 是否开启 gzip 压缩，默认为 false admins 管理员们，这是一个 JSON Object，对应各键名为各管理员的用户名，键值为其邮箱，默认为 { fengmk2: &#39;fengmk2@gmail.com‘, admin: &#39;admin@cnpmjs.org‘, dead_horse: &#39;dead_horse@qq.com‘ } logoURL Logo 地址 adBanner 广告 Banner 的地址 customReadmeFile 实际上我们看到的 cnpmjs.org 首页中间一大堆冗长的介绍是一个 Markdown 文件转化而成的，你可以设置该项来自行替换这个文件 customFooter 自定义页脚模板 npmClientName 默认为 cnpm，如果你有自己开发或者 fork 的 npm 客户端的话请改成自己的 CLI 命令，这个应该会在一些页面的说明处替换成你所写的 backupFilePrefix 备份目录 database 数据库相关配置，为一个对象，默认如果不配置将会是一个~/.http://cnpmjs.org/data.sqlite 的 SQLite； db 数据的库名； username 数据库用户名 password 数据库密码； dialect 数据库适配器，可选 “mysql”、”sqlite”、”postgres”、”mariadb”，默认为”sqlite”； host 数据库地址； port 数据库端口； pool 数据库连接池相关配置，为一个对象 maxConnections 最大连接数，默认为 10； minConnections 最小连接数，默认为 0； maxIdleTime 单条链接最大空闲时间，默认为 30000 毫秒； storege 仅对 SQLite 配置有效，数据库地址，默认为 ~/.cnpmjs/data.sqlite； nfs 包文件系统处理对象，为一个 Node.js 对象，默认是 fs-cnpm 这个包，并且配置在~/.cnpmjs/nfs 目录下，也就是说默认所有同步的包都会被放在这个目录下 registryHost enablePrivate 是否开启私有模式，默认为 false；如果是私有模式则只有管理员能发布包，其它人只能从源站同步包；如果是非私有模式则所有登录用户都能发布包 scopes 非管理员发布包的时候只能用以 scopes 里面列举的命名空间为前缀来发布，如果没设置则无法发布，也就是说这是一个必填项，默认为 [ ‘@cnpm’, ‘@cnpmtest’, ‘@cnpm-test’ ]， privatePackages 就如该配置项的注释所述，出于历史包袱的原因，有些已经存在的私有包（可能之前是用 Git 的方式安装的）并没有以命名空间的形式来命名，而这种包本来是无法上传到 CNPM 的，这个配置项数组就是用来加这些例外白名单的，默认为一个空数组 sourceNpmRegistry 更新源 NPM 的 registry 地址，默认为https://registry.npm.taobao.org sourceNpmRegistryIsCNpm 源 registry 是否为 CNPM，默认为 true，如果你使用的源是官方 NPM 源，请将其设为 false； syncByInstall 如果安装包的时候发现包不存在，则尝试从更新源同步，默认为 true syncModel 更新模式（不过我觉得是个 typo），有下面几种模式可以选择，默认为 “none”;”none”：永不同步，只管理私有用户上传的包，其它源包会直接从源站获取；”exist”：定时同步已经存在于数据库的包；”all”：定时同步所有源站的包 syncInterval 同步间隔，默认为 “10m” 即十分钟 syncDevDependencies 是否同步每个包里面的 devDependencies 包们，默认为 false badgeSubject 包的 badge 显示的名字，默认为 cnpm userService 用户验证接口，默认为 null，即无用户相关功能也就是无法有用户去上传包，该部分需要自己实现接口功能并配置，如与公司的 Gitlab 相对接，这也是后话了 alwaysAuth 是否始终需要用户验证，即便是 $ cnpm install 等命令 httpProxy 代理地址设置 初始化数据库如果你使用的是 SQLite 的话，数据库是自动就好了的，可以忽略该步。 其它数据库需要自行导入初始数据库结构。 初始数据库脚本在 docs/db.sql 里面，你可以用一些 GUI 工具将数据导入，也可以直接进入命令行导入。 比如你用的是 MySQL，就可以在本机操作 MySQL。 123$ mysql -u yourname -pmysql&gt; use cnpmjs;mysql&gt; source docs/db.sql 启动服务12345npm run dev：调试模式启动；npm run test：跑测试；npm run start：启动 CNPM；npm run status：查看 CNPM 启动状态；npm run stop：停止 CNPM。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS规范]]></title>
    <url>%2F2019%2F05%2F28%2FCSS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[代码规范 编码规范： @charset规则一定要在样式文件的第一行首个字符位置开始 @charset “”;一定要写上，并且用小写字母，不能出现转义符 代码风格 样式书写：紧凑型（Compact） 1.jdc&#123;display: block;width: 50px;&#125; 展开型（Expanded）推荐 1234.jdc&#123; display: block; width: 50px;&#125; 代码大小写样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写 12345678/* 推荐 */.jdc&#123; display:block;&#125;/* 不推荐 */.JDC&#123; DISPLAY:BLOCK;&#125; 选择器 尽量少用通用选择器* 不使用ID选择器 不使用无具体语义定义的标签选择器1234/* 推荐 */.jdc &#123;&#125;.jdc li &#123;&#125;.jdc li p&#123;&#125; 1234/* 不推荐 */*&#123;&#125;#jdc &#123;&#125;.jdc div&#123;&#125; 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）1234.jdc &#123; width: 100%; height: 100%;&#125; 代码易读性左括号与类名之间一个空格，冒号与属性值之间一个空格1234/*推荐*/.jdc &#123; width: 100%; &#125; 1234/*不推荐*/.jdc&#123; width:100%;&#125; 逗号分隔的取值，逗号之后一个空格1234/*推荐：*/.jdc &#123; box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;&#125; 1234/*不推荐：*/.jdc &#123; box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;&#125; 为单个css选择器或新申明开启新行：123456789/*推荐*/.jdc, .jdc_logo, .jdc_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 123456/*不推荐：*/.jdc,jdc_logo,.jdc_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 01234/*推荐：*/.jdc &#123; color: rgba(255,255,255,.5);&#125; 1234/*不推荐：*/.jdc &#123; color: rgba( 255, 255, 255, 0.5 );&#125; 属性值十六进制数值能用简写的尽量用简写1234/*推荐：*/.jdc &#123; color: #fff;&#125; 1234/*不推荐：*/.jdc &#123; color: #ffffff;&#125; 不要为 0 指明单位1234/*推荐：*/.jdc &#123; margin: 0 10px;&#125; 1234/*不推荐：*/.jdc &#123; margin: 0px 10px;&#125; 属性值引导css属性值需要用到引号时，统一使用单引号1234/* 推荐 */.jdc &#123; font-family: 'Hiragino Sans GB';&#125; 1234/* 不推荐 */.jdc &#123; font-family: "Hiragino Sans GB";&#125; 属性书写顺序建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …1234567891011121314151617.jdc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; CSS3浏览器私有前缀写法CSS3 浏览器私有前缀在前，标准前缀在后1234567.jdc &#123; -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; 注释规范 注释以字符 / 开始，以字符 / 结束 注释不能嵌套 单行注释注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行123456推荐：/* Comment Text */.jdc&#123;&#125;/* Comment Text */.jdc&#123;&#125; 12345678不推荐：/*Comment Text*/.jdc&#123; display: block;&#125;.jdc&#123; display: block;/*Comment Text*/&#125; 模块注释注释内容第一个字符和最后一个字符都是一个空格字符，/ 与 模块信息描述占一行，多个横线分隔符-与/占一行，行与行之间相隔两行1234567推荐：/* Module A---------------------------------------------------------------- */.mod_a &#123;&#125;/* Module B---------------------------------------------------------------- */.mod_b &#123;&#125; 12345不推荐：/* Module A ---------------------------------------------------- */.mod_a &#123;&#125;/* Module B ---------------------------------------------------- */.mod_b &#123;&#125; 文件信息注释在样式文件编码声明 @charset 语句下面注明页面名称、作者、创建日期等信息123456@charset "UTF-8";/** * @desc File Info * @author Author Name * @date 2015-10-10 */ SASS规范 SASS注释规范SASS支持 CSS 标准的多行注释 / /，同时也支持单行注释 //。 多行注释在使用非 Compressed 模式进行编译后的输出文件中会保留下来，单行注释 // 侧会被移除 多行注释和单行注释在 SASS 编译后输出的压缩 CSS 文件都会被移除 当多行注释内容第一个字符是感叹号 “!” 的时候，即 /! /，SASS无论用哪一种编译方式编译注释都会保留 注释内容可以加入 SASS 变量 嵌套规范选择器嵌套12345678/* CSS */.jdc &#123;&#125;body .jdc &#123;&#125;/* SCSS */.jdc &#123; body &amp; &#123;&#125;&#125; 12345678910111213/* CSS */.jdc &#123;&#125;.jdc_cover &#123;&#125;.jdc_info &#123;&#125;.jdc_info_name &#123;&#125;/* SCSS */.jdc &#123; &amp;_cover &#123;&#125; &amp;_info &#123; &amp;_name &#123;&#125; &#125;&#125; 属性嵌套1234567/* CSS */.jdc &#123; background-color: red; background-repeat: no-repeat; background-image: url(/img/icon.png); background-position: 0 0;&#125; 123456789/* SCSS */.jdc &#123; background: &#123; color: red; repeat: no-repeat; image: url(/img/icon.png); position: 0 0; &#125;&#125; 变量可复用属性尽量抽离为页面变量，易于统一维护12345// CSS.jdc &#123; color: red; border-color: red;&#125; 123456// SCSS$color: red;.jdc &#123; color: $color; border-color: $color;&#125; 混合(mixin)根据功能定义模块，然后在需要使用的地方通过 @include 调用，避免编码时重复输入代码段12345678910111213141516171819202122232425262728293031323334353637383940// CSS.jdc_1 &#123; -webkit-border-radius: 5px; border-radius: 5px;&#125;.jdc_2 &#123; -webkit-border-radius: 10px; border-radius: 10px;&#125;// SCSS@mixin radius($radius:5px) &#123; -webkit-border-radius: $radius; border-radius: $radius;&#125;.jdc_1 &#123; @include radius; //参数使用默认值&#125;.jdc_2 &#123; @include radius(10px);&#125;// CSS.jdc_1 &#123; background: url(/img/icon.png) no-repeat -10px 0;&#125;.jdc_2 &#123; background: url(/img/icon.png) no-repeat -20px 0;&#125;// SCSS@mixin icon($x:0, $y:0) &#123; background: url(/img/icon.png) no-repeat $x, $y;&#125;.jdc_1 &#123; @include icon(-10px, 0);&#125;.jdc_2 &#123; @include icon(-20px, 0);&#125; 占位选择器 %如果不调用则不会有任何多余的 css 文件，占位选择器以 % 标识定义，通过 @extend 调用12345678//scss%borderbox &#123; -webkit-box-sizing: border-box; box-sizing: border-box;&#125;.jdc &#123; @extend %borderbox;&#125; extend 继承123456789101112131415161718192021222324252627282930313233// CSS.jdc_1 &#123; font-size: 12px; color: red;&#125;.jdc_2 &#123; font-size: 12px; color: red; font-weight: bold;&#125;// SCSS.jdc_1 &#123; font-size: 12px; color: red;&#125;.jdc_2 &#123; @extend .jdc_1; font-weight: bold;&#125;// 或者%font_red &#123; font-size: 12px; color: red;&#125;.jdc_1 &#123; @extend %font_red;&#125;.jdc_2 &#123; @extend %font_red; font-weight: bold;&#125; for 循环12345678910111213注意：#&#123;&#125; 是连接符，变量连接使用时需要依赖// CSS.jdc_1 &#123;background-position: 0 -20px;&#125;.jdc_2 &#123;background-position: 0 -40px;&#125;.jdc_3 &#123;background-position: 0 -60px;&#125;// SCSS@for $i from 1 through 3 &#123; .jdc_#&#123;$i&#125; &#123; background-position: 0 (-20px) * $i; &#125;&#125; each 循环1234567891011121314151617181920212223242526272829303132// CSS.jdc_list &#123; background-image: url(/img/jdc_list.png);&#125;.jdc_detail &#123; background-image: url(/img/jdc_detail.png);&#125;// SCSS@each $name in list, detail &#123; .jdc_#&#123;$name&#125; &#123; background-image: url(/img/jdc_#&#123;$name&#125;.png); &#125;&#125;// CSS.jdc_list &#123; background-image: url(/img/jdc_list.png); background-color: red;&#125;.jdc_detail &#123; background-image: url(/img/jdc_detail.png); background-color: blue;&#125;// SCSS@each $name, $color in (list, red), (detail, blue) &#123; .jdc_#&#123;$name&#125; &#123; background-image: url(/img/jdc_#&#123;$name&#125;.png); background-color: $color; &#125;&#125; function 函数123456@function pxToRem($px) &#123; @return $px / 10px * 1rem;&#125;.jdc &#123; font-size: pxToRem(12px);&#125; 运算规范运算符之间空出一个空格1234.jdc &#123; width: 100px - 50px; height: 30px / 5;&#125; 注意运算单位，单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意1234567// 正确的运算格式.jdc &#123; width: 100px - 50px; width: 100px + 50px; width: 100px * 2; width: 100px / 2;&#125; 重置样式 移动端12345678910* &#123; -webkit-tap-highlight-color: transparent; outline: 0; margin: 0; padding: 0; vertical-align: baseline; &#125;body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin: 0; padding: 0; vertical-align: baseline; &#125;img &#123; border: 0 none; vertical-align: top; &#125;i, em &#123; font-style: normal; &#125;ol, ul &#123; list-style: none; &#125;input, select, button, h1, h2, h3, h4, h5, h6 &#123; font-size: 100%; font-family: inherit; &#125;table &#123; border-collapse: collapse; border-spacing: 0; &#125;a &#123; text-decoration: none; color: #666; &#125;body &#123; margin: 0 auto; min-width: 320px; max-width: 640px; height: 100%; font-size: 14px; font-family: -apple-system,Helvetica,sans-serif; line-height: 1.5; color: #666; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; &#125;input[type="text"], textarea &#123; -webkit-appearance: none; -moz-appearance: none; appearance: none; &#125; PC端12345678910111213141516html, body, div, h1, h2, h3, h4, h5, h6, p, dl, dt, dd, ol, ul, li, fieldset, form, label, input, legend, table, caption, tbody, tfoot, thead, tr, th, td, textarea, article, aside, audio, canvas, figure, footer, header, mark, menu, nav, section, time, video &#123; margin: 0; padding: 0; &#125;h1, h2, h3, h4, h5, h6 &#123; font-size: 100%; font-weight: normal &#125;article, aside, dialog, figure, footer, header, hgroup, nav, section, blockquote &#123; display: block; &#125;ul, ol &#123; list-style: none; &#125;img &#123; border: 0 none; vertical-align: top; &#125;blockquote, q &#123; quotes: none; &#125;blockquote:before, blockquote:after, q:before, q:after &#123; content: none; &#125;table &#123; border-collapse: collapse; border-spacing: 0; &#125;strong, em, i &#123; font-style: normal; font-weight: normal; &#125;ins &#123; text-decoration: underline; &#125;del &#123; text-decoration: line-through; &#125;mark &#123; background: none; &#125;input::-ms-clear &#123; display: none !important; &#125;body &#123; font: 12px/1.5 \5FAE\8F6F\96C5\9ED1, \5B8B\4F53, "Hiragino Sans GB", STHeiti, "WenQuanYi Micro Hei", "Droid Sans Fallback", SimSun, sans-serif; background: #fff; &#125;a &#123; text-decoration: none; color: #333; &#125;a:hover &#123; text-decoration: underline; &#125; 媒体查询 常用查询语句判断设备横竖屏123/* 横屏 */@media all and (orientation :landscape) &#123;&#125; 1234/* 竖屏 */@media all and (orientation :portrait) &#123;&#125; 判断设备宽高1234/* 设备宽度大于 320px 小于 640px */@media all and (min-width:320px) and (max-width:640px) &#123; &#125; 判断设备像素比1234567891011121314/* 设备像素比为 1 */@media only screen and (-webkit-min-device-pixel-ratio: 1), only screen and (min-device-pixel-ratio: 1) &#123; &#125;/* 设备像素比为 1.5 */@media only screen and (-webkit-min-device-pixel-ratio: 1.5), only screen and (min-device-pixel-ratio: 1.5) &#123; &#125;/* 设备像素比为 2 */@media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min-device-pixel-ratio: 2) &#123; &#125; 常用设备设置iPhones123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* ----------- iPhone 4 and 4S ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape) &#123;&#125;/* ----------- iPhone 5 and 5S ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 320px) and (max-device-width: 568px) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 320px) and (max-device-width: 568px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 320px) and (max-device-width: 568px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape) &#123;&#125;/* ----------- iPhone 6 ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 375px) and (max-device-width: 667px) and (-webkit-min-device-pixel-ratio: 2) &#123; &#125;/* Portrait */@media only screen and (min-device-width: 375px) and (max-device-width: 667px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait) &#123; &#125;/* Landscape */@media only screen and (min-device-width: 375px) and (max-device-width: 667px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: landscape) &#123; &#125;/* ----------- iPhone 6+ ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) &#123; &#125;/* Portrait */@media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) and (orientation: portrait) &#123; &#125;/* Landscape */@media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) and (orientation: landscape) &#123; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Galaxy Phones/* ----------- Galaxy S3 ----------- *//* Portrait and Landscape */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 2) &#123;&#125;/* Portrait */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait) &#123;&#125;/* Landscape */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape) &#123;&#125;/* ----------- Galaxy S4 ----------- *//* Portrait and Landscape */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* Portrait */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait) &#123;&#125;/* Landscape */@media screen and (device-width: 320px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape) &#123;&#125;/* ----------- Galaxy S5 ----------- *//* Portrait and Landscape */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* Portrait */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait) &#123;&#125;/* Landscape */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape) &#123;&#125; 12345678910111213141516171819202122232425262728HTC Phones/* ----------- HTC One ----------- *//* Portrait and Landscape */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) &#123;&#125;/* Portrait */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait) &#123;&#125;/* Landscape */@media screen and (device-width: 360px) and (device-height: 640px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape) &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384iPads/* ----------- iPad mini ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: portrait) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: landscape) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* ----------- iPad 1 and 2 ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: portrait) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: landscape) and (-webkit-min-device-pixel-ratio: 1) &#123;&#125;/* ----------- iPad 3 and 4 ----------- *//* Portrait and Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125;/* Portrait */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: portrait) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125;/* Landscape */@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: landscape) and (-webkit-min-device-pixel-ratio: 2) &#123;&#125; 移动端常用私有属性 目前两大主流移动平台为 iOS 和 Android，有不少带 -webkit- 前辍的 CSS 私有属性以及一些 iOS only 属性，当中好些属性在日常需求中经常应用到。 WebKit CSS 属性中的一部分已经被包含在 CSS 规范草案中，并且可能成为最后的推荐标准，但目前仍然是试验性的属性，还有一些属性是不规范的属性，它们没有出现在跟踪规范中。 -webkit-scrollbar-webkit-scrollbar 是-webkit-私有的伪元素，用于对拥有overflow属性的区域 自定义滚动条的样式。譬如，为了隐藏滚动条，你可以这么做：1234.scroll::-webkit-scrollbar &#123; width: 0; height: 0;&#125; 除了对整个滚动条的控制外，Webkit还提供了控制对滚动条各组成部分的表现渲染的伪元素，甚至具体到滚动条的各种状态行为的伪类。 滚动条各块组成表现渲染的伪元素一般而言，滚动条的主要组成部分包括： 滚动按钮 — 滚动按钮的夹角则被称为滚动角(corner)。 轨道 — 轨道(track)可以进一步分为轨枕(track pieces) 和滑块(thumb)。Webkit则根据滚动条各组成部分，提供了不同的伪元素来自定义样式。1234567::-webkit-scrollbar &#123; /* 1 */ &#125;::-webkit-scrollbar-button &#123; /* 2 */ &#125;::-webkit-scrollbar-track &#123; /* 3 */ &#125;::-webkit-scrollbar-track-piece &#123; /* 4 */ &#125;::-webkit-scrollbar-thumb &#123; /* 5 */ &#125;::-webkit-scrollbar-corner &#123; /* 6 */ &#125;::-webkit-resizer &#123; /* 7 */ &#125; 滚动条各块组成的伪元素下面的伪类可以应用到上面的伪元素中。:horizontal：选择水平方向的滚动条。 :vertical：选择垂直方向的滚动条。 :decrement：适用于滚动按钮和轨枕。选择能够使得视窗位置递减状态(例如，垂直滚动条向上滚动，水平滚动条向左滚动。)的滚动按钮或轨枕。 :increment：适用于滚动按钮和轨枕。选择能够使得视窗位置递增状态(例如，垂直滚动条向下滚动，水平滚动条向右滚动。)的滚动按钮或轨枕。 :start：适用于滚动按钮和轨枕。选择位于滚动滑块前边的滚动按钮和轨枕。 :end：适用于滚动按钮和轨枕。选择位于滚动滑块后边的滚动按钮和轨枕。 :double-button：适用于滚动按钮和轨枕。选中紧挨着一对按钮的轨枕以及位于滚动条某一端的一对按钮中的其中一个滚动按钮。 :single-button：适用于滚动按钮和轨枕。选中紧挨着仅一个按钮的轨枕以及位于滚动条某一端的仅它本身一个的滚动按钮。 :no-button：适用于轨枕。选中轨道结束位置没有按钮的轨枕。 :corner-present：适用于选中滚动角不存在的滚动条。 :window-inactive：适用于所有滚动条，选中焦点不在该视窗的滚动区域。 另外，:enabled、:disabled、:hover、和:active等伪类同样在滚动条中适用。为了更好地理解，以下是几个伪元素组合伪类的应用例子：123456789::-webkit-scrollbar-track-piece:start &#123; /\*滚动条上半边或左半边\*/&#125;::-webkit-scrollbar-thumb:window-inactive &#123; /\*当焦点不在当前区域滑块的状态\*/::-webkit-scrollbar-button:horizontal:decrement:hover &#123; /\*当鼠标在水平滚动条下面的按钮上的状态\*/ &#125; -webkit-touch-callout-webkit-touch-callout 是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 当你触摸并按住触摸目标时候，禁止或显示系统默认菜单。在iOS上，当你触摸并按住触摸的目标，比如一个链接，Safari浏览器将显示链接有关的系统默认菜单，这个属性可以让你禁用系统默认菜单。属性值 none：系统默认菜单被禁用 inherit：系统默认菜单不被禁用 兼容性 iOS 2.0及更高版本的 Safari 浏览器可用 Android 尚不明确 -webkit-tap-highlight-color-webkit-tap-highlight-color 是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 在 iOS Safari 上，当用户点击链接或具有 JavaScript 可点击脚本的元素，系统会为这些被点击元素加上一个默认的透明色值，该属性可以覆盖该透明值。兼容性 iOS 1.1.1及更高版本的Safari浏览器可用 大部分安卓手机 -webkit-overflow-scrolling定义在具 overflow:scroll 属性的元素内是否采用原生样式滚动行为属性值 auto:默认值，单手滚动，滚动没有惯性效果 touch：原生样式滚动，应用此属性值会产生层叠上下文（会影响定位参照物的属性，类似 opacity、masks、transforms属性，影响到 position 的效果，甚至影响到 position:fixed 的定位参照物，） 兼容性 OS 5.0 及更高版本 大部分安卓机 -webkit-line-clamp-webkit-line-clamp 是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他外来的WebKit属性。 常见结合属性： display: -webkit-box：必须结合的属性，将对象作为弹性伸缩盒子模型显示。 -webkit-box-orient：必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式。 text-overflow：可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。 属性值number:块元素显示的文本的行数 兼容性 iOS Andriod -webkit-appearance-webkit-appearance 是一个不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 改变按钮和其他控件的外观，使其类似于原生控件。 属性值(https://developer.mozilla.org/en-US/docs/Web/CSS/appearance) none：去除系统默认 appearance 的样式，常用于 iOS 下移除原生样式 button：渲染成 button 的风格 checkbox：渲染成 input checkbox 样式的复选框按钮 radio：渲染成 radio 的风格 兼容性 iOS 2.0及更高版本的Safari浏览器可用 Android 尚不明确 -webkit-font-smoothing字体平滑，该属性定义文本的平滑属性，但要注意以下说明： 非标准属性，不建议用于网页上，这个属性不能保证所有用户都能看到相同效果，这会使网站的字体渲染造成不一致，而此属性的渲染行为日后也有可能会改变 属性值 none：去掉字体平滑效果，使字体带锯齿 antialiased：使字体在像素级别更平滑更轻细 subpixel-antialiased：在多数非 Retina 显示设备中字体将会更锐利。注意：以上属性在 Retina 设备上会有明显的效果，在非 Retina 设备上看不出差异 兼容性部分高清设备，如 Retina Mac -webkit-backface-visibilitybackface-visibility 在 W3文档 有定义描述 定义转换元素的背面是否显示属性值 visible：显示（默认值） hidden：隐藏 兼容性 iOS 2.0 及更高版本的 Safari 浏览器可用 大部分 Android]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名规范]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[(阿里BEM命名规范：https://segmentfault.com/a/1190000012705634)由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。 目录命名 项目文件夹：projectname 样式文件夹：css 脚本文件夹：js 样式类图片文件夹：img 图片顺序图片命名建议以以下顺序命名： 图片业务（可选） +（mod_）图片功能类别（必选）+ 图片模块名称（可选） + 图片精度（可选） 图片业务： pp_：拍拍 wx_：微信 sq_：手Q jd_：京东商城 图片功能类别： mod_：是否公共，可选 icon：模块类固化的图标 logo：LOGO类 spr：单页面各种元素合并集合 btn：按钮 bg：可平铺或者大背景 图片模块名称： goodslist：商品列表 goodsinfo：商品信息 userava tar：用户头像 图片精度： 普清：@1x Retina：@2x | @3x 如下面例子：123456789公共模块：wx_mod_btn_goodlist@2x.pngwx_mod_btn_goodlist.pngmod_btn_goodlist.png 非公共模块：wx_btn_goodlist@2x.pngwx_btn_goodlist.pngbtn_goodlist.png 交叉业务协作业务交叉协作的时候，为了避免图片命名冲突，建议图片名加上业务和模块前辍，如拍拍侧和手Q侧的业务交叉合作时，侧栏导航icon雪碧图命名： 12345推荐：pp_icon_mod_sidenav.png不推荐：icon_mod_sidenav.png 处理高清图片的时候，命名应该加上图片相应的精度说明1234567推荐：jdc_logo@1x.pngjdc_logo@2x.png不推荐：jdc_logo.pngjdc_logo_retina.png HTML/CSS文件命名确保文件命名总是以字母开头而不是数字，且字母一律小写，以下划线连接且不带其他标点符号，如： 123456789&lt;!-- HTML --&gt;jdc.htmljdc_list.htmljdc_detail.html&lt;!-- SASS --&gt;jdc.scssjdc_list.scssjdc_detail.scss ClassName命名ClassName的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线 “_” 连接 命名原则祖先模块不能出现下划线，除了是全站公用模块，如 mod_ 系列的命名：123456789101112131415推荐：&lt;div class="modulename"&gt; &lt;div class="modulename_info"&gt; &lt;div class="modulename_son"&gt;&lt;/div&gt; &lt;div class="modulename_son"&gt;&lt;/div&gt; ... &lt;/div&gt;&lt;/div&gt; &lt;!-- 这个是全站公用模块，祖先模块允许直接出现下划线 --&gt;&lt;div class="mod_info"&gt; &lt;div class="mod_info_son"&gt;&lt;/div&gt; &lt;div class="mod_info_son"&gt;&lt;/div&gt; ... &lt;/div&gt; 1234567不推荐：&lt;div class="modulename_info"&gt; &lt;div class="modulename_info_son"&gt;&lt;/div&gt; &lt;div class="modulename_info_son"&gt;&lt;/div&gt; ... &lt;/div&gt; 在子孙模块数量可预测的情况下，严格继承祖先模块的命名前缀1234&lt;div class="modulename"&gt; &lt;div class="modulename_cover"&gt;&lt;/div&gt; &lt;div class="modulename_info"&gt;&lt;/div&gt;&lt;/div&gt; 当子孙模块超过4级或以上的时候，可以考虑在祖先模块内具有识辨性的独立缩写作为新的子孙模块12345678910111213141516推荐：&lt;div class="modulename"&gt; &lt;div class="modulename_cover"&gt;&lt;/div&gt; &lt;div class="modulename_info"&gt; &lt;div class="modulename_info_user"&gt; &lt;div class="modulename_info_user_img"&gt; &lt;img src="" alt=""&gt; &lt;!-- 这个时候 miui 为 modulename_info_user_img 首字母缩写--&gt; &lt;div class="miui_tit"&gt;&lt;/div&gt; &lt;div class="miui_txt"&gt;&lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="modulename_info_list"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415不推荐：&lt;div class="modulename"&gt; &lt;div class="modulename_cover"&gt;&lt;/div&gt; &lt;div class="modulename_info"&gt; &lt;div class="modulename_info_user"&gt; &lt;div class="modulename_info_user_img"&gt; &lt;img src="" alt=""&gt; &lt;div class="modulename_info_user_img_tit"&gt;&lt;/div&gt; &lt;div class="modulename_info_user_img_txt"&gt;&lt;/div&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="modulename_info_list"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 模块命名全站公共模块：以 mod_ 开头1&lt;div class="mod_yours"&gt;&lt;/div&gt; 业务公共模块：以 业务名mod 开头1&lt;div class="paipai_mod_yours"&gt;&lt;/div&gt; 常用命名推荐注意：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此1&lt;div class="ad"&gt;&lt;/div&gt; 这种广告的英文或拼音类名不应该出现另外，敏感不和谐字眼也不应该出现，如：123456&lt;div class="fuck"&gt;&lt;/div&gt;&lt;div class="jer"&gt;&lt;/div&gt;&lt;div class="sm"&gt;&lt;/div&gt;&lt;div class="gcd"&gt;&lt;/div&gt; &lt;div class="ass"&gt;&lt;/div&gt; &lt;div class="KMT"&gt;&lt;/div&gt; ClassName 含义 about 关于 account 账户 arrow 箭头图标 article 文章 aside 边栏 audio 音频 avatar 头像 bg,background 背景 bar 栏（工具类） branding 品牌化 crumb,breadcrumbs 面包屑 btn,button 按钮 caption 标题，说明 category 分类 chart 图表 clearfix 清除浮动 close 关闭 col,column 列 comment 评论 community 社区 container 容器 content 内容 copyright 版权 current 当前态，选中态 default 默认 description 描述 details 细节 disabled 不可用 entry 文章，博文 error 错误 even 偶数，常用于多行列表或表格中 fail 失败（提示） feature 专题 fewer 收起 field 用于表单的输入区域 figure 图 filter 筛选 first 第一个，常用于列表中]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM上传JS包]]></title>
    <url>%2F2019%2F05%2F28%2FNPM%E5%B7%A5%E5%85%B7JS%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[NPM上传包 初始化JS12345运行npm init 目录如下|---index.js // 主文件|---package.json // 包文件|---README.md // 使用说明|---test.js // 测试JS 以下方的代码为例index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159var region = require('./area.js')var parse = &#123; result:&#123; name:"", mobile:"", phone:"", province:"", city:"", area:"", detail:'', zipCode:'' &#125;, address:'', parseAddress:function(address)&#123; if( address &amp;&amp; typeof address == 'string' )&#123; this.address = address.trim() this.parseResult() &#125;else&#123; this.result = &#123; name:"", mobile:"", phone:"", province:"", city:"", area:"", detail:'', zipCode:'' &#125; &#125; return this.result &#125;, parseResult:function()&#123; this.address = this.address.replace(/\r\n/g, ' ').replace(/\n/g, ' ').replace(/\t/g, ' ') var search = ['地址', '收货地址', '收货人', '收件人', '收货', '邮编', '电话', '：', ':', '；', ';', '，', ',', '。'] search.forEach(str =&gt; &#123; this.address = this.address.replace(new RegExp(str, 'g'), ' ') &#125;); this.address = this.address.replace(/ &#123;2,&#125;/g, ' '); // 找出手机 var mobileReg = /(86-[1][0-9]&#123;10&#125;)|(86[1][0-9]&#123;10&#125;)|([1][0-9]&#123;10&#125;)/g; var mobile = mobileReg.exec(this.address); if (mobile) &#123; this.result.mobile = mobile[0]; this.address = this.address.replace(mobile[0], ' ') &#125; // 找出固话 var phoneReg = /(([0-9]&#123;3,4&#125;-)[0-9]&#123;7,8&#125;)|([0-9]&#123;12&#125;)|([0-9]&#123;11&#125;)|([0-9]&#123;10&#125;)|([0-9]&#123;9&#125;)|([0-9]&#123;8&#125;)|([0-9]&#123;7&#125;)/g; var phone = phoneReg.exec(this.address); if (phone) &#123; this.result.phone = phone[0]; this.address = this.address.replace(phone[0], ' ') &#125; // 邮政编码 const zipReg = /([0-9]&#123;6&#125;)/g; const zip = zipReg.exec(this.address); if (zip) &#123; this.result.zipCode = zip[0]; this.address = this.address.replace(zip[0], '') &#125; // 空格缩减 this.address = this.address.replace(/ &#123;2,&#125;/,' '); // 省市区的识别 var region = this.parseRegion() if(region.weights &gt;= 2)&#123; this.result.province = region.province this.result.city = region.city this.result.area = region.area this.address = this.address.replace(this.result.province, '') this.address = this.address.replace(this.result.city, '') this.address = this.address.replace(this.result.area, '') &#125; var provinceKey = ['特别行政区', '古自治区', '维吾尔自治区', '壮族自治区', '回族自治区', '自治区', '直辖', '省', '市']; var cityKey = ['布依族苗族自治州', '苗族侗族自治州', '自治州', '州', '市', '县']; for (var k in provinceKey) &#123; if (this.address.indexOf(provinceKey[k]) &gt;-1) &#123; this.address = this.address.replace(provinceKey[k], ' '); &#125; &#125; for (var key in cityKey) &#123; if (this.address.indexOf(cityKey[key]) &gt;-1) &#123; this.address = this.address.replace(cityKey[key], ' '); &#125; &#125; // 取消双空格 和 前后空格 this.address = this.address.replace(/ &#123;2,&#125;/,' ').trim(); var info = this.address.split(' ') var name = info[0] || '' info.forEach(function(item)&#123; if(item.length &lt; name.length)&#123; name = item &#125; &#125;) var detail = this.address.replace(name,' ').replace(/ /,'').trim(); this.result.name = name this.result.detail = detail &#125;, parseRegion:function()&#123; var that = this var citys = [] var result = &#123; province:'', city:'', area:'', weights:0 &#125; region.forEach(function(items)&#123; if(that.address.indexOf(items.name) &gt; -1)&#123; citys.push(&#123; province:items.name, weights:1 &#125;) items.city.forEach(function(item)&#123; if(that.address.indexOf(item.name) &gt; -1)&#123; Object.assign(citys[citys.length-1],&#123; city:item.name, weights:2 &#125;) item.area.forEach(function(name)&#123; if(that.address.indexOf(name) &gt; -1)&#123; Object.assign(citys[citys.length-1],&#123; area:name, weights:3 &#125;) &#125; &#125;) &#125; &#125;) &#125; else &#123; items.city.forEach(function(item)&#123; citys.push(&#123; province:items.name, &#125;) if(that.address.indexOf(item.name) &gt; -1)&#123; Object.assign(citys[citys.length-1],&#123; city:item.name, weights:1 &#125;) item.area.forEach(function(name)&#123; if(that.address.indexOf(name) &gt; -1)&#123; Object.assign(citys[citys.length-1],&#123; area:name, weights:2 &#125;) &#125; &#125;) &#125; &#125;) &#125; &#125;) citys.forEach(function(item)&#123; if(result.weights &lt; item.weights)&#123; Object.assign(result,item) &#125; &#125;) return result &#125;&#125;module.exports = parse package.json123456789101112131415&#123; "name": "parse-address-cn", "version": "1.0.2", "description": "解析地址姓名及电话", "main": "index.js", "scripts": &#123; "test": "node test.js" &#125;, "keywords":[ "parse", "address" ], "author": "akcedar@163.com", "license": "MIT"&#125; test.js123456789101112131415var aa = require('./index.js')console.log(aa.parseAddress('陕西省安康市汉滨区果园小区 13222222222 张三 725000'))console.log(aa.parseAddress('上海市青浦区华南路555号 张三'))console.log(aa.parseAddress('张三上海市青浦区华南路555号 12222222222'))console.log(aa.parseAddress('张北京上海市青浦区华南路555号 12222222222'))console.log(aa.parseAddress(''))console.log(aa.parseAddress([])) 编写万上述文件后npm login //输入以下命令，会提示输入用户名、密码、邮箱。继续执行12//退出当前文件夹，开始命令行发布包，命令如下：npm publish testxxxxx 验证下载npm install testxxxxx强制删除12//删除要用force强制删除。超过24小时就不能删除了。自己把握好时间。npm --force unpublish testxxxxx]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD语法编写]]></title>
    <url>%2F2019%2F05%2F27%2Fmd%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题 #号标题前面带#号，后面带文字，分别表示h1-h6,h1下面会有一条横线，注意，#号后面有空格 ==标题在标题的下一行写==号 数量不限制 &gt;1 –二级标题在标题的下一行写- 数量不限制 &gt;1 列表无序列表无序列表可以用* ， + ， — 来创建 有序列表数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的 区块引用用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用可以嵌套，只需要多加一个&gt; &gt;&gt;表示二级引用 最多到6层 分割线分割线可以由 _（星号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 表示虚线 _表示实线 链接行内连接行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中 链接还可以带title属性 参数式这就好理解了，就是把链接当成参数，适合多出使用相同链接的场景，注意参数的对应关系，参数定义时，这几种写法都可以：1234567[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here)[foo]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 图片也分为行内式和参数式 用法和链接一样，区别是图片前面要写一个！ 代码框一行用单反引号包起来 多行多行用三个反引号，如果要写注释，可以在反引号后面写 表格1234name | age |sex:-:| -:| :-居中| 右对齐|左对齐zhangsan| 18| man name age sex zhangsan 18 man 强调一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗 转义和jS保持一直 \ 删除线两个~包表示删除线 如：~~ 删除线文字~~ 显示 删除线文字]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语法规范]]></title>
    <url>%2F2019%2F05%2F27%2FJS%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[语言规范JavaScript 是一种客户端脚本语言，这里列出了编写 JavaScript 时需要遵守的规则。 类型 基本类型 字符串 数值 布尔类型 null undefined 123456const foo = 1let bar = foobar = 9console.log(foo, bar) // 1, 9 复杂类型 object array function 123456const foo = [1, 2, 3]const bar = foobar[0] = 9console.log(foo[0], bar[0]) // 9, 9 引用const 和 let 都是块级作用域，var 是函数级作用域 对所有引用都使用 const，不要使用 var 1234567// badvar a = 1var b = 2// goodconst a = 1const b = 2 如果引用是可变动的，则使用 let 1234567891011// badvar count = 1if (count &lt; 10) &#123; count += 1&#125;// goodlet count = 1if (count &lt; 10) &#123; count += 1&#125; 对象 请使用字面量值创建对象 12345// badconst a = new Object&#123;&#125;// goodconst a = &#123;&#125; 别使用保留字作为对象的键值，这样在 IE8 下不会运行 1234567891011// badconst a = &#123; default: &#123;&#125;, // default 是保留字 common: &#123;&#125;&#125;// goodconst a = &#123; defaults: &#123;&#125;, common: &#123;&#125;&#125; 请使用对象方法的简写方式 1234567891011121314151617// badconst item = &#123; value: 1, addValue: function (val) &#123; return item.value + val &#125;&#125;// goodconst item = &#123; value: 1, addValue(val) &#123; return item.value + val &#125;&#125; 请使用对象属性值的简写方式 1234567891011const job = 'FrontEnd'// badconst item = &#123; job: job&#125;// goodconst item = &#123; job&#125; 对象属性值的简写方式要和声明式的方式分组 123456789101112131415161718const job = 'FrontEnd'const department = 'JDC'// badconst item = &#123; sex: 'male', job, age: 25, department&#125;// goodconst item = &#123; job, department, sex: 'male', age: 25&#125; 数组 请使用字面量值创建数组 12345// badconst items = new Array()// goodconst items = [] 向数组中添加元素时，请使用 push 方法 1234567const items = []// baditems[items.length] = 'test'// gooditems.push('test') 使用拓展运算符 ... 复制数组 12345678910111213// badconst items = []const itemsCopy = []const len = items.lengthlet i// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]&#125;// gooditemsCopy = [...items] 使用数组的 map 等方法时，请使用 return 声明，如果是单一声明语句的情况，可省略 return 12345678910111213141516171819202122232425262728293031323334353637383940414243// good[1, 2, 3].map(x =&gt; &#123; const y = x + 1 return x * y&#125;)// good[1, 2, 3].map(x =&gt; x + 1)// badconst flat = &#123;&#125;[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123; const flatten = memo.concat(item) flat[index] = flatten&#125;)// goodconst flat = &#123;&#125;[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123; const flatten = memo.concat(item) flat[index] = flatten return flatten&#125;)// badinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg if (subject === 'Mockingbird') &#123; return author === 'Harper Lee' &#125; else &#123; return false &#125;&#125;)// goodinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg if (subject === 'Mockingbird') &#123; return author === 'Harper Lee' &#125; return false&#125;) 解构赋值 当需要使用对象的多个属性时，请使用解构赋值 12345678910111213141516171819// badfunction getFullName (user) &#123; const firstName = user.firstName const lastName = user.lastName return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125;// goodfunction getFullName (user) &#123; const &#123; firstName, lastName &#125; = user return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125;// betterfunction getFullName (&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125; 当需要使用数组的多个值时，请同样使用解构赋值 12345678const arr = [1, 2, 3, 4]// badconst first = arr[0]const second = arr[1]// goodconst [first, second] = arr 函数需要回传多个值时，请使用对象的解构，而不是数组的解构 123456789101112131415// badfunction doSomething () &#123; return [top, right, bottom, left]&#125;// 如果是数组解构，那么在调用时就需要考虑数据的顺序const [top, xx, xxx, left] = doSomething()// goodfunction doSomething () &#123; return &#123; top, right, bottom, left &#125;&#125;// 此时不需要考虑数据的顺序const &#123; top, left &#125; = doSomething() 字符串 字符串统一使用单引号的形式 &#39;&#39; 12345// badconst department = "JDC"// goodconst department = 'JDC' 字符串太长的时候，请不要使用字符串连接符换行 \，而是使用 + 123const str = '凹凸实验室 凹凸实验室 凹凸实验室' + '凹凸实验室 凹凸实验室 凹凸实验室' + '凹凸实验室 凹凸实验室' 程序化生成字符串时，请使用模板字符串 12345678910const test = 'test'// badconst str = ['a', 'b', test].join()// badconst str = 'a' + 'b' + test// goodconst str = `ab$&#123;test&#125;` 函数 请使用函数声明，而不是函数表达式 123456789// badconst foo = function () &#123; // do something&#125;// goodfunction foo () &#123; // do something&#125; 不要在非函数代码块中声明函数 1234567891011121314// badif (isUse) &#123; function test () &#123; // do something &#125;&#125;// goodlet testif (isUse) &#123; test = () =&gt; &#123; // do something &#125;&#125; 不要使用 arguments，可以选择使用 ... arguments 只是一个类数组，而 ... 是一个真正的数组 12345678910// badfunction test () &#123; const args = Array.prototype.slice.call(arguments) return args.join('')&#125;// goodfunction test (...args) &#123; return args.join('')&#125; 不要更改函数参数的值 123456789// badfunction test (opts) &#123; opts = opts || &#123;&#125;&#125;// goodfunction test (opts = &#123;&#125;) &#123; // ...&#125; 原型 使用 class，避免直接操作 prototype 12345678910111213141516171819202122// badfunction Queue (contents = []) &#123; this._queue = [..contents]&#125;Queue.prototype.pop = function () &#123; const value = this._queue[0] this._queue.splice(0, 1) return value&#125;// goodclass Queue &#123; constructor (contents = []) &#123; this._queue = [...contents] &#125; pop () &#123; const value = this._queue[0] this._queue.splice(0, 1) return value &#125;&#125; 模块 使用标准的 ES6 模块语法 import 和 export 1234567891011// badconst util = require('./util')module.exports = util// goodimport Util from './util'export default Util// betterimport &#123; Util &#125; from './util'export default Util 不要使用 import 的通配符 *，这样可以确保你只有一个默认的 export 12345// badimport * as Util from './util'// goodimport Util from './util' 迭代器 不要使用 iterators 1234567891011121314const numbers = [1, 2, 3, 4, 5]// badlet sum = 0for (let num of numbers) &#123; sum += num&#125;// goodlet sum = 0numbers.forEach(num =&gt; sum += num)// betterconst sum = numbers.reduce((total, num) =&gt; total + num, 0) 对象属性 使用 . 来访问对象属性 12345678910const joke = &#123; name: 'haha', age: 28&#125;// badconst name = joke['name']// goodconst name = joke.name 变量声明 声明变量时，请使用 const、let 关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能会和现有变量冲突，另外，也很难明确该变量的作用域是什么。这里推荐使用 const 来声明变量，我们需要避免全局命名空间的污染。 12345// baddemo = new Demo()// goodconst demo = new Demo() 将所有的 const 和 let 分组 12345678910111213// badlet aconst blet cconst dlet e// goodconst bconst dlet alet clet e Hoisting var 存在变量提升的情况，即 var 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 const 和 let 并不存在这种情况，他们被赋予了 Temporal Dead Zones, TDZ 1234567891011121314151617181920function example () &#123; console.log(notDefined) // =&gt; throws a ReferenceError&#125;function example () &#123; console.log(declareButNotAssigned) // =&gt; undefined var declaredButNotAssigned = true&#125;function example () &#123; let declaredButNotAssigned console.log(declaredButNotAssigned) // =&gt; undefined declaredButNotAssigned = true&#125;function example () &#123; console.log(declaredButNotAssigned) // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned) // =&gt; throws a ReferenceError const declaredButNotAssigned = true&#125; 匿名函数的变量名会提升，但函数内容不会 123456789function example () &#123; console.log(anonymous) // =&gt; undefined anonymous() var anonymous = function () &#123; console.log('test') &#125;&#125; 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会 123456789101112131415161718192021function example() &#123; console.log(named) // =&gt; undefined named() // =&gt; TypeError named is not a function superPower() // =&gt; ReferenceError superPower is not defined var named = function superPower () &#123; console.log('Flying') &#125;&#125;function example() &#123; console.log(named) // =&gt; undefined named() // =&gt; TypeError named is not a function var named = function named () &#123; console.log('named') &#125;&#125; 分号 我们遵循 Standard 的规范，不使用分号。 关于应不应该使用分号的讨论有很多，本规范认为非必要的时候，应该不使用分号，好的 JS 程序员应该清楚场景下是一定要加分号的，相信你也是名好的开发者。 1234567891011// badconst test = 'good';(function () &#123; const str = 'hahaha';&#125;)()// goodconst test = 'good';(() =&gt; &#123; const str = 'hahaha'&#125;)(); 标准特性为了代码的可移植性和兼容性，我们应该最大化的使用标准方法，例如优先使用 string.charAt(3) 而不是 string[3] eval()由于 eval 方法比较 evil，所以我们约定禁止使用该方法 with() {}由于 with 方法会产生神奇的作用域，所以我们也是禁止使用该方法的 for-in 循环推荐使用 for in 语法，但是在对对象进行操作时，容易忘了检测 hasOwnProperty(key)，所以我们启用了 ESLint 的 guard-for-in 选项 对数组进行 for in 的时候，顺序是不固定的 修改内置对象的原型不要修改内置对象，如 Object 和 Array]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS规范]]></title>
    <url>%2F2019%2F05%2F27%2FJS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[编码规范统一团队的编码规范，有助于代码的维护。本章是传统意义上的 Style Guideline，目的是统一一些相对主观化的代码风格。 单行代码块在单行代码块中使用空格 不推荐 12function foo () &#123;return true&#125;if (foo) &#123;bar = 0&#125; 推荐 12function foo () &#123; return true &#125;if (foo) &#123; bar = 0 &#125; 大括号风格在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下： One True Brace Style 12345if (foo) &#123; bar()&#125; else &#123; baz()&#125; Stroustrup 123456if (foo) &#123; bar()&#125;else &#123; baz()&#125; Allman 12345678if (foo)&#123; bar()&#125;else&#123; baz()&#125; 我们团队约定使用 One True Brace Style 风格 变量命名当命名变量时，主流分为驼峰式命名（variableName）和下划线命名（variable_name）两大阵营。 团队约定使用驼峰式命名 拖尾逗号在 ECMAScript5 里面，对象字面量中的拖尾逗号是合法的，但在 IE8（非 IE8 文档模式）下，当出现拖尾逗号，则会抛出错误。 拖尾逗号的例子： 1234var foo = &#123; name: 'foo', age: '22',&#125; 拖尾逗号的好处是，简化了对象和数组添加或删除元素，我们只需要修改新增的行即可，并不会增加差异化的代码行数。 因为拖尾逗号有好也有不好，所以团队约定允许在最后一个元素或属性与闭括号 ] 或 } 在不同行时，可以（但不要求）使用拖尾逗号。当在同一行时，禁止使用拖尾逗号。 逗号空格逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。 不推荐 123var foo = 1,bar = 2var foo = 1 , bar = 2var foo = 1 ,bar = 2 推荐 1var foo = 1, bar = 2 逗号风格逗号分隔列表时，在 JavaScript 中主要有两种逗号风格： 标准风格，逗号放置在当前行的末尾 逗号前置风格，逗号放置在下一行的开始位置 团队约定使用标准风格 不推荐 123456789var foo = 1,bar = 2var foo = 1, bar = 2var foo = ['name' , 'age'] 推荐 12345var foo = 1, bar = 2var foo = ['name', 'age'] 计算属性的空格团队约定在对象的计算属性内，禁止使用空格 不推荐 123obj['foo' ]obj[ 'foo']obj[ 'foo' ] 推荐 1obj['foo'] 拖尾换行在非空文件中，存在拖尾换行是一个常见的 UNIX 风格，它的好处是可以方便在串联和追加文件时不会打断 Shell 的提示。在日常的项目中，保留拖尾换行的好处是，可以减少版本控制时的代码冲突。 不推荐 123function func () &#123; // do something&#125; 推荐 1234function func () &#123; // do something&#125; // 此处是新的一行 可以通过 .editorconfig 添加 EOL 函数调用为了避免语法错误，团队约定在函数调用时，禁止使用空格 不推荐 123fn ()fn() 推荐 1fn() 缩进代码保持一致的缩进，是作为工程师的职业素养。但缩进用两个空格，还是四个空格，是用 Tab 还是空格呢？这样的争论太多了，也得不出答案。本规范结合了市面上优秀的开源项目，姑且约定使用 空格 来缩进，而且缩进使用两个空格。 那是不是不能使用 Tab 进行缩进了？我们可以通过配置 .editorconfig ，将 Tab 自动转换为空格。 对象字面量的键值缩进团队约定对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格 不推荐 1var obj = &#123; 'foo' : 'haha' &#125; 推荐 1var obj = &#123; 'foo': 'haha' &#125; 构造函数首字母大写在 JavaScript 中 new 操作符用来创建某个特定类型的对象的一个实例，该类型的对象是由一个构造函数表示的。由于构造函数只是常规函数，唯一区别是使用 new 来调用。所以我们团队约定构造函数的首字母要大小，以此来区分构造函数和普通函数。 不推荐 1var fooItem = new foo() 推荐 1var fooItem = new Foo() 构造函数的参数在 JavaScript 中，通过 new 调用构造函数时，如果不带参数，可以省略后面的圆括号。但这样会造成与整体的代码风格不一致，所以团队约定使用圆括号 不推荐 1var person = new Person 推荐 1var person = new Person() 链式调用链式调用如果放在同一行，往往会造成代码的可读性差，但有些时候，短的链式调用并不会影响美观。所以本规范约定一行最多只能有四个链式调用，超过就要求换行。 空行空白行对于分离代码逻辑有帮助，但过多的空行会占据屏幕的空间，影响可读性。团队约定最大连续空行数为 2 不推荐 12345var a = 1var b = 2 推荐 1234var a = 1var b = 2 链式赋值链式赋值容易造成代码的可读性差，所以团队约定禁止使用链式赋值 不推荐 1var a = b = c = 1 推荐 123var a = 1var b = 1var c = 1 变量声明JavaScript 允许在一个声明中，声明多个变量。团队约定在声明变量时，一个声明只能有一个变量 不推荐 1var a, b, c 推荐 123var avar bvar c 分号JavaScript 在所有类 C 语言中是比较独特的，它不需要在每个语句的末尾有分号。在很多情况下，JavaScript 引擎可以确定一个分号应该在什么位置然后自动添加它。此特征被称为 自动分号插入 (ASI)，被认为是 JavaScript 中较为有争议的特征。 团队中对于是否应该使用分号，也有许多争论，本规范推荐不使用分号，因为我们认为好的工程师应该知道什么时候该加，什么时候不该加。 相关参考 ：semi 代码块空格一致性是任何风格指南的重要组成部分。虽然在哪里放置块的开括号纯属个人偏好，但在整个项目中应该保持一致。不一致的风格将会分散读者阅读代码的注意力。 团队约定代码块前要添加空格 不推荐 12345if (a)&#123; b()&#125;function a ()&#123;&#125; 推荐 12345if (a) &#123; b()&#125;function a () &#123;&#125; 函数声明的空格当格式化一个函数，函数名或 function 关键字与左括号之间允许有空白。命名函数要求函数名和 function 关键字之间有空格，但是匿名函数要求不加空格。 团队约定函数括号前要加空格 不推荐 123function func(x) &#123; // ...&#125; 推荐 123function func (x) &#123; // ...&#125; 操作符的空格团队约定操作符前后都需要添加空格 不推荐 1var sum = 1+2 推荐 1var sum = 1 + 2 BOMUnicode 字节顺序标记 (BOM) 用来指定代码单元是高字节序还是低字节序。也就是说，是高位在前还是低位在前。UTF-8 不需要 BOM 来表明字节顺序，因为单个字节并不影响字节顺序。 相信不少同学遇到过 BOM 的坑，这里不多说了，切记不要使用 windows 的记事本改代码！]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html模板]]></title>
    <url>%2F2019%2F05%2F27%2FHTML%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[HTML模版指的是团队使用的初始化HTML文件，里面会根据不同平台而采用不一样的设置，一般主要不同的设置就是 mata 标签的设置，以下是 PC 和移动端的 HTML 模版。 HTML5标准模版123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;&lt;meta HTTP-EQUIV="pragma" CONTENT="no-cache"&gt; &lt;meta HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="0"&gt;&lt;title&gt;HTML5标准模版&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 团队约定移动端123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta HTTP-EQUIV="pragma" CONTENT="no-cache"&gt; &lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;&lt;meta HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="0"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" &gt;&lt;meta name="format-detection" content="telephone=no" &gt;&lt;title&gt;移动端HTML模版&lt;/title&gt; &lt;!-- DNS预解析 --&gt;&lt;link rel="dns-prefetch" href=""&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; PC端123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;&lt;meta name="keywords" content="your keywords"&gt;&lt;meta name="description" content="your description"&gt;&lt;meta name="author" content="author,email address"&gt;&lt;meta HTTP-EQUIV="pragma" CONTENT="no-cache"&gt; &lt;meta HTTP-EQUIV="Cache-Control" CONTENT="no-store, must-revalidate"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT"&gt; &lt;meta HTTP-EQUIV="expires" CONTENT="0"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt;&lt;meta name="renderer" content="ie-stand"&gt;&lt;title&gt;PC端HTML模版&lt;/title&gt;&lt;!-- DNS预解析 --&gt; &lt;link rel="dns-prefetch" href=""&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注释规范]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[遵循标准HTML注释规范写法应该遵循以下标准： Comments must start with the four character sequence U+003C LESS-THAN SIGN, U+0021 EXCLAMATION MARK, U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS (&lt;!–). Following this sequence, the comment may have text, with the additional restriction that the text must not start with a single “&gt;” (U+003E) character, nor start with a U+002D HYPHEN-MINUS character (-) followed by a “&gt;” (U+003E) character, nor contain two consecutive U+002D HYPHEN-MINUS characters (–), nor end with a U+002D HYPHEN-MINUS character (-). Finally, the comment must be ended by the three character sequence U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN (–&gt;). 必须以4个有序字符开始：编码为 U+003C LESS-THAN SIGN 的小于号, 编码为 U+0021 EXCLAMATION MARK 的感叹号, 编码为 U+002D HYPHEN-MINUS 横线, 编码为 U+002D HYPHEN-MINUS横线 ，即 “&lt;!–” 在此之后是注释内容，注释的内容有以下限制： 不能以单个 “&gt;” (U+003E) 字符开始 不能以由 “-“（U+002D HYPHEN-MINUS）和 ”&gt;” (U+003E) 组合的字符开始，即 “-&gt;” 不能包含两个连续的 U+002D HYPHEN-MINUS 字符，即 “–” 不能以一个 U+002D HYPHEN-MINUS 字符结束，即 “-” 必须以3个有序字符结束：U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN，即 “–&gt;” 标准写法： 1&lt;!--Comment Text--&gt; 错误的写法： 1234567&lt;!--&gt;The Wrong Comment Text--&gt;&lt;!---&gt;The Wrong Comment Text--&gt;&lt;!--The--Wrong--Comment Text--&gt;&lt;!--The Wrong Comment Text---&gt; 参考 www.w3.org #Comments 团队约定单行注释一般用于简单的描述，如某些状态描述、属性描述等 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行 推荐： 12&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt; 不推荐： 12345&lt;div&gt;...&lt;/div&gt;&lt;!-- Comment Text --&gt; &lt;div&gt;&lt;!-- Comment Text --&gt; ...&lt;/div&gt; 模块注释一般用于描述模块的名称以及模块开始与结束的位置 注释内容前后各一个空格字符，&lt;!-- S Comment Text --&gt; 表示模块开始，&lt;!-- E Comment Text --&gt; 表示模块结束，模块与模块之间相隔一行 推荐写法： 1234567891011&lt;!-- S Comment Text A --&gt; &lt;div class="mod_a"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text A --&gt; &lt;!-- S Comment Text B --&gt; &lt;div class="mod_b"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text B --&gt; 不推荐写法： 12345678910&lt;!-- S Comment Text A --&gt;&lt;div class="mod_a"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text A --&gt;&lt;!-- S Comment Text B --&gt; &lt;div class="mod_b"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text B --&gt; 嵌套模块注释当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用 12&lt;!-- S Comment Text --&gt;&lt;!-- E Comment Text --&gt; 而改用 1&lt;!-- /Comment Text --&gt; 注释写在模块结尾标签底部，单独一行。 123456789101112131415&lt;!-- S Comment Text A --&gt;&lt;div class="mod_a"&gt; &lt;div class="mod_b"&gt; ... &lt;/div&gt; &lt;!-- /mod_b --&gt; &lt;div class="mod_c"&gt; ... &lt;/div&gt; &lt;!-- /mod_c --&gt; &lt;/div&gt;&lt;!-- E Comment Text A --&gt;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件-npm]]></title>
    <url>%2F2019%2F05%2F27%2Fvue%E7%BB%84%E4%BB%B6npm%2F</url>
    <content type="text"><![CDATA[使用vue-cli3 创建项目 12vue create my-project目录 有 public src package.json readme.md 等文件 首先需要创建一个 packages 目录，用来存放组件然后将 src 目录改为 examples 用作示例 修改配置启动项目的时候，默认入口文件是 src/main.js将 src 目录改为 examples 之后，就需要重新配置入口文件在根目录下创建一个 vue.config.js 文件1234567891011121314// vue.config.jsmodule.exports = &#123; // 将 examples 目录添加为新的页面 pages: &#123; index: &#123; // page 的入口 entry: 'examples/main.js', // 模板来源 template: 'public/index.html', // 输出文件名 filename: 'index.html' &#125; &#125;&#125; 开发组件之前已经创建了一个 packages 目录，用来存放组件该目录下存放每个组件单独的开发目录，和一个 index.js 整合所有组件，并对外导出每个组件都应该归类于单独的目录下，包含其组件源码目录 src，和 index.js 便于外部引用123456789// packages/textarea/index.js// 导入组件，组件必须声明 nameimport Textarea from './main.vue'// 为组件添加 install 方法，用于按需引入Textarea.install = function (Vue) &#123; Vue.component(Textarea.name, Textarea)&#125;export default Textarea 打包组件vue-cli 3.x 提供了一个库文件打包命令主要需要四个参数： target: 默认为构建应用，改为 lib 即可启用构建库模式 name: 输出文件名 dest: 输出目录，默认为 dist，这里我们改为 lib entry: 入口文件路径，默认为 src/App.vue，这里改为 packages/index.js123456// pageage.json&#123; "scripts": &#123; "lib": "vue-cli-service build --target lib --name tag-textarea --dest lib packages/index.js" &#125;&#125; 然后执行 npm run lib 命令，编译组件 准备发布123456789首先需要在 package.json 添加组件信息name: 包名，该名不能和已有的名称冲突；version: 版本号，不能和历史版本号相同；description: 简介；main: 入口文件，应指向编译后的包文件；keyword：关键字，以空格分割；author：作者；private：是否私有，需要修改为 false 才能发布到 npm；license：开源协议。 然后创建 .npmignore 文件，设置忽略文件该文件的语法和 .gitignore 的语法一样，设置发布到 npm 时忽略哪些目录或文件123456789101112131415161718192021222324.DS_Storenode_modules/examples/packages/public/vue.config.jsbabel.config.js*.map*.html# local env files.env.local.env.*.local# Log filesnpm-debug.log*yarn-debug.log*yarn-error.log*# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln*.sw* 发布方法同普通的发布]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML规范]]></title>
    <url>%2F2019%2F05%2F27%2Fhtml%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[DOCTYPE 声明一个DOCTYPE必须包含以下部分，并严格按照顺序出现： A string that is an ASCII case-insensitive match for the string “&lt;!DOCTYPE”. One or more space characters. A string that is an ASCII case-insensitive match for the string “html”. Optionally, a DOCTYPE legacy string or an obsolete permitted DOCTYPE string (defined below). Zero or more space characters. A “&gt;” (U+003E) character. 一个ASCII字符串 “&lt;!DOCTYPE” ，大小写不敏感 一个或多个空白字符 一个ASCII字符串”html”，大小写不敏感 一个可选的历史遗留的DOCTYPE字符串 （DOCTYPE legacy string），或者一个可选的已过时但被允许的DOCTYPE字符串 （obsolete permitted DOCTYPE string） 字符串 一个或多个空白字符 一个编码为 U+003E 的字符 “&gt;” 团队约定HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明： 1&lt;!DOCTYPE html&gt; 更多关于 DOCTYPE声明#The DOCTYPE 页面语言LANGLang属性的取值应该遵循互联网工程任务组–IETF（The Internet Engineering Task Force）制定的关于语言标签的文档 BCP 47 - Tags for Identifying Languages 团队约定推荐使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值1&lt;html lang="zh-CN"&gt; 更多地区语言参考： zh-SG 中文 (简体, 新加坡) 对应 cmn-Hans-SG 普通话 (简体, 新加坡) zh-HK 中文 (繁体, 香港) 对应 cmn-Hant-HK 普通话 (繁体, 香港) zh-MO 中文 (繁体, 澳门) 对应 cmn-Hant-MO 普通话 (繁体, 澳门) zh-TW 中文 (繁体, 台湾) 对应 cmn-Hant-TW 普通话 (繁体, 台湾) 已废弃不推荐使用的 Languages Tags以下写法已于 2009 年废弃，请勿使用（cmn、wuu、yue、gan 等已由 2005 年的 extlang 升级到 2009 年的 language）： zh-cmn, zh-cmn-Hans, zh-cmn-Hant, zh-wuu, zh-yue, zh-gan 以下写法已于 2009 年废弃，不推荐使用： zh-Hans, zh-Hans-CN, zh-Hans-SG, zh-Hans-HK, zh-Hans-MO, zh-Hans-TW, zh-Hant, zh-Hant-CN, zh-Hant-SG, zh-Hant-HK, zh-Hant-MO, zh-Hant-TW 更多已废弃 Languages Tags 参考 IANA Language Subtag Registry 里面的 “Type: redundant“” 更多关于 Languages Tags ：W3C Language tags in HTML and XML 网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？ CHARSET Because the character sets in ISO-8859 was limited in size, and not compatible in multilingual environments, the Unicode Consortium developed the Unicode Standard. The Unicode Standard covers (almost) all the characters, punctuations, and symbols in the world. Unicode enables processing, storage, and transport of text independent of platform and language. The default character encoding in HTML-5 is UTF-8. 因为 ISO-8859 中字符集大小是有限的，且在多语言环境中不兼容，所以 Unicode 联盟开发了 Unicode 标准。 Unicode 标准覆盖了（几乎）所有的字符、标点符号和符号。 Unicode 使文本的处理、存储和运输，独立于平台和语言。 HTML-5 中默认的字符编码是 UTF-8 参阅 HTML Unicode (UTF-8) Reference 团队约定一般情况下统一使用 “UTF-8” 编码1&lt;meta charset="UTF-8"&gt; 由于历史原因，有些业务可能会使用 “GBK” 编码 1&lt;meta charset="GBK"&gt; 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 IETF对UTF-8的定义，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。 更多关于UTF-8写法: UTF8 or UTF-8? GBK：Application of IANA Charset Registration for GBK Charset ：character-encoding-declaration 元素及标签闭合HTML元素共有以下5种： 空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr 原始文本元素：script、style RCDATA元素：textarea、title 外来元素：来自MathML命名空间和SVG命名空间的元素。 常规元素：其他HTML允许的元素都称为常规元素。 元素标签的闭合应遵循以下原则： Tags are used to delimit the start and end of elements in the markup. Raw text, escapable raw text, and normal elements have a start tag to indicate where they begin, and an end tag to indicate where they end. The start and end tags of certain normal elements can be omitted, as described below in the section on optional tags. Those that cannot be omitted must not be omitted. Void elements only have a start tag; end tags must not be specified for void elements. Foreign elements must either have a start tag and an end tag, or a start tag that is marked as self-closing, in which case they must not have an end tag. 原始文本元素、RCDATA元素以及常规元素都有一个开始标签来表示开始，一个结束标签来表示结束。 某些元素的开始和结束标签是可以省略的，如果规定标签不能被省略，那么就绝对不能省略它。 空元素只有一个开始标签，且不能为空元素设置结束标签。 外来元素可以有一个开始标签和配对的结束标签，或者只有一个自闭合的开始标签，且后者情况下该元素不能有结束标签。 团队约定为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定： 所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。 空元素标签都不加 “/” 字符 推荐： 123456&lt;div&gt; &lt;h1&gt;我是h1标题&lt;/h1&gt; &lt;p&gt;我是一段文字，我有始有终，浏览器能正确解析&lt;/p&gt;&lt;/div&gt; &lt;br&gt; 不推荐： 123456&lt;div&gt; &lt;h1&gt;我是h1标题&lt;/h1&gt; &lt;p&gt;我是一段文字，我有始无终，浏览器亦能正确解析&lt;/div&gt;&lt;br/&gt; 更多关于元素及标签关闭：#Elements 书写风格HTML代码大小写HTML标签名、类名、标签属性和大部分属性值统一用小写 推荐： 1&lt;div class="demo"&gt;&lt;/div&gt; 不推荐： 123&lt;div class="DEMO"&gt;&lt;/div&gt; &lt;DIV CLASS="DEMO"&gt;&lt;/DIV&gt; HTML文本、CDATA、JavaScript、meta标签某些属性等内容可大小写混合 12345678910111213141516&lt;!-- 优先使用 IE 最新版本和 Chrome Frame --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt;&lt;!-- HTML文本内容 --&gt;&lt;h1&gt;I AM WHAT I AM &lt;/h1&gt;&lt;!-- JavaScript 内容 --&gt;&lt;script type="text/javascript"&gt; var demoName = 'demoName'; ...&lt;/script&gt; &lt;!-- CDATA 内容 --&gt;&lt;script type="text/javascript"&gt;&lt;![CDATA[...]]&gt;&lt;/script&gt; 类型属性不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含 推荐： 12&lt;link rel="stylesheet" href="" &gt;&lt;script src=""&gt;&lt;/script&gt; 不推荐： 12&lt;link rel="stylesheet" type="text/css" href="" &gt;&lt;script type="text/javascript" src="" &gt;&lt;/script&gt; 元素属性 元素属性值使用双引号语法 元素属性值可以写上的都写上 推荐： 123&lt;input type="text"&gt; &lt;input type="radio" name="name" checked="checked" &gt; 不推荐： 1234&lt;input type=text&gt; &lt;input type='text'&gt; &lt;input type="radio" name="name" checked &gt; 更多关于元素属性：#Attributes 特殊字符引用 In certain cases described in other sections, text may be mixed with character references. These can be used to escape characters that couldn’t otherwise legally be included in text. 文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。 在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 推荐： 1&lt;a href="#"&gt;more&amp;gt;&amp;gt;&lt;/a&gt; 不推荐： 1&lt;a href="#"&gt;more&gt;&gt;&lt;/a&gt; 更多关于符号引用：#Character references 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 123&lt;div class="jdc"&gt; &lt;a href="#"&gt;&lt;/a&gt;&lt;/div&gt; 纯数字输入框使用 type=&quot;tel&quot; 而不是 type=&quot;number&quot; 1&lt;input type="tel"&gt; 代码嵌套元素嵌套规范，每个块状元素独立一行，内联元素可选 推荐： 12345&lt;div&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 不推荐： 1234567&lt;div&gt; &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/p&gt; 段落元素与标题元素只能嵌套内联元素 推荐： 12&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 不推荐： 12&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO的使用]]></title>
    <url>%2F2019%2F05%2F26%2FHEXO%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1234$ hexo deployhexo clean hexo g hexo d More info: Deployment 编辑要求必须包含title、date、categories、tags]]></content>
      <categories>
        <category>使用说明</category>
      </categories>
      <tags>
        <tag>user</tag>
      </tags>
  </entry>
</search>
