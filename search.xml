<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS规范]]></title>
    <url>%2F2019%2F05%2F27%2FJS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[编码规范统一团队的编码规范，有助于代码的维护。本章是传统意义上的 Style Guideline，目的是统一一些相对主观化的代码风格。 单行代码块在单行代码块中使用空格 不推荐 12function foo () &#123;return true&#125;if (foo) &#123;bar = 0&#125; 推荐 12function foo () &#123; return true &#125;if (foo) &#123; bar = 0 &#125; 大括号风格在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下： One True Brace Style 12345if (foo) &#123; bar()&#125; else &#123; baz()&#125; Stroustrup 123456if (foo) &#123; bar()&#125;else &#123; baz()&#125; Allman 12345678if (foo)&#123; bar()&#125;else&#123; baz()&#125; 我们团队约定使用 One True Brace Style 风格 变量命名当命名变量时，主流分为驼峰式命名（variableName）和下划线命名（variable_name）两大阵营。 团队约定使用驼峰式命名 拖尾逗号在 ECMAScript5 里面，对象字面量中的拖尾逗号是合法的，但在 IE8（非 IE8 文档模式）下，当出现拖尾逗号，则会抛出错误。 拖尾逗号的例子： 1234var foo = &#123; name: 'foo', age: '22',&#125; 拖尾逗号的好处是，简化了对象和数组添加或删除元素，我们只需要修改新增的行即可，并不会增加差异化的代码行数。 因为拖尾逗号有好也有不好，所以团队约定允许在最后一个元素或属性与闭括号 ] 或 } 在不同行时，可以（但不要求）使用拖尾逗号。当在同一行时，禁止使用拖尾逗号。 逗号空格逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。 不推荐 123var foo = 1,bar = 2var foo = 1 , bar = 2var foo = 1 ,bar = 2 推荐 1var foo = 1, bar = 2 逗号风格逗号分隔列表时，在 JavaScript 中主要有两种逗号风格： 标准风格，逗号放置在当前行的末尾 逗号前置风格，逗号放置在下一行的开始位置 团队约定使用标准风格 不推荐 123456789var foo = 1,bar = 2var foo = 1, bar = 2var foo = ['name' , 'age'] 推荐 12345var foo = 1, bar = 2var foo = ['name', 'age'] 计算属性的空格团队约定在对象的计算属性内，禁止使用空格 不推荐 123obj['foo' ]obj[ 'foo']obj[ 'foo' ] 推荐 1obj['foo'] 拖尾换行在非空文件中，存在拖尾换行是一个常见的 UNIX 风格，它的好处是可以方便在串联和追加文件时不会打断 Shell 的提示。在日常的项目中，保留拖尾换行的好处是，可以减少版本控制时的代码冲突。 不推荐 123function func () &#123; // do something&#125; 推荐 1234function func () &#123; // do something&#125; // 此处是新的一行 可以通过 .editorconfig 添加 EOL 函数调用为了避免语法错误，团队约定在函数调用时，禁止使用空格 不推荐 123fn ()fn() 推荐 1fn() 缩进代码保持一致的缩进，是作为工程师的职业素养。但缩进用两个空格，还是四个空格，是用 Tab 还是空格呢？这样的争论太多了，也得不出答案。本规范结合了市面上优秀的开源项目，姑且约定使用 空格 来缩进，而且缩进使用两个空格。 那是不是不能使用 Tab 进行缩进了？我们可以通过配置 .editorconfig ，将 Tab 自动转换为空格。 对象字面量的键值缩进团队约定对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格 不推荐 1var obj = &#123; 'foo' : 'haha' &#125; 推荐 1var obj = &#123; 'foo': 'haha' &#125; 构造函数首字母大写在 JavaScript 中 new 操作符用来创建某个特定类型的对象的一个实例，该类型的对象是由一个构造函数表示的。由于构造函数只是常规函数，唯一区别是使用 new 来调用。所以我们团队约定构造函数的首字母要大小，以此来区分构造函数和普通函数。 不推荐 1var fooItem = new foo() 推荐 1var fooItem = new Foo() 构造函数的参数在 JavaScript 中，通过 new 调用构造函数时，如果不带参数，可以省略后面的圆括号。但这样会造成与整体的代码风格不一致，所以团队约定使用圆括号 不推荐 1var person = new Person 推荐 1var person = new Person() 链式调用链式调用如果放在同一行，往往会造成代码的可读性差，但有些时候，短的链式调用并不会影响美观。所以本规范约定一行最多只能有四个链式调用，超过就要求换行。 空行空白行对于分离代码逻辑有帮助，但过多的空行会占据屏幕的空间，影响可读性。团队约定最大连续空行数为 2 不推荐 12345var a = 1var b = 2 推荐 1234var a = 1var b = 2 链式赋值链式赋值容易造成代码的可读性差，所以团队约定禁止使用链式赋值 不推荐 1var a = b = c = 1 推荐 123var a = 1var b = 1var c = 1 变量声明JavaScript 允许在一个声明中，声明多个变量。团队约定在声明变量时，一个声明只能有一个变量 不推荐 1var a, b, c 推荐 123var avar bvar c 分号JavaScript 在所有类 C 语言中是比较独特的，它不需要在每个语句的末尾有分号。在很多情况下，JavaScript 引擎可以确定一个分号应该在什么位置然后自动添加它。此特征被称为 自动分号插入 (ASI)，被认为是 JavaScript 中较为有争议的特征。 团队中对于是否应该使用分号，也有许多争论，本规范推荐不使用分号，因为我们认为好的工程师应该知道什么时候该加，什么时候不该加。 相关参考 ：semi 代码块空格一致性是任何风格指南的重要组成部分。虽然在哪里放置块的开括号纯属个人偏好，但在整个项目中应该保持一致。不一致的风格将会分散读者阅读代码的注意力。 团队约定代码块前要添加空格 不推荐 12345if (a)&#123; b()&#125;function a ()&#123;&#125; 推荐 12345if (a) &#123; b()&#125;function a () &#123;&#125; 函数声明的空格当格式化一个函数，函数名或 function 关键字与左括号之间允许有空白。命名函数要求函数名和 function 关键字之间有空格，但是匿名函数要求不加空格。 团队约定函数括号前要加空格 不推荐 123function func(x) &#123; // ...&#125; 推荐 123function func (x) &#123; // ...&#125; 操作符的空格团队约定操作符前后都需要添加空格 不推荐 1var sum = 1+2 推荐 1var sum = 1 + 2 BOMUnicode 字节顺序标记 (BOM) 用来指定代码单元是高字节序还是低字节序。也就是说，是高位在前还是低位在前。UTF-8 不需要 BOM 来表明字节顺序，因为单个字节并不影响字节顺序。 相信不少同学遇到过 BOM 的坑，这里不多说了，切记不要使用 windows 的记事本改代码！]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD语法编写]]></title>
    <url>%2F2019%2F05%2F27%2Fmd%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题#号标题前面带#号，后面带文字，分别表示h1-h6,h1下面会有一条横线，注意，#号后面有空格 ==标题在标题的下一行写==号 数量不限制 &gt;1 –二级标题在标题的下一行写- 数量不限制 &gt;1 列表无序列表无序列表可以用* ， + ， — 来创建 有序列表数字后面的点只能是英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的 区块引用用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用可以嵌套，只需要多加一个&gt; &gt;&gt;表示二级引用 最多到6层 分割线分割线可以由 _（星号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 表示虚线 _表示实线 链接行内连接行内式的链接格式是：链接的文字放在[]中，链接地址放在随后的（）中 链接还可以带title属性 参数式这就好理解了，就是把链接当成参数，适合多出使用相同链接的场景，注意参数的对应关系，参数定义时，这几种写法都可以：1234567[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here)[foo]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 图片也分为行内式和参数式 用法和链接一样，区别是图片前面要写一个！ 代码框一行用单反引号包起来 多行多行用三个反引号，如果要写注释，可以在反引号后面写 表格1234name | age |sex:-:| -:| :-居中| 右对齐|左对齐zhangsan| 18| man name age sex zhangsan 18 man 强调一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗 转义和jS保持一直 \ 删除线两个~包表示删除线 如：~~ 删除线文字~~ 显示 删除线文字]]></content>
      <categories>
        <category>工具方法</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS语法规范]]></title>
    <url>%2F2019%2F05%2F27%2FJS%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[语言规范JavaScript 是一种客户端脚本语言，这里列出了编写 JavaScript 时需要遵守的规则。 类型 基本类型 字符串 数值 布尔类型 null undefined 123456const foo = 1let bar = foobar = 9console.log(foo, bar) // 1, 9 复杂类型 object array function 123456const foo = [1, 2, 3]const bar = foobar[0] = 9console.log(foo[0], bar[0]) // 9, 9 引用const 和 let 都是块级作用域，var 是函数级作用域 对所有引用都使用 const，不要使用 var 1234567// badvar a = 1var b = 2// goodconst a = 1const b = 2 如果引用是可变动的，则使用 let 1234567891011// badvar count = 1if (count &lt; 10) &#123; count += 1&#125;// goodlet count = 1if (count &lt; 10) &#123; count += 1&#125; 对象 请使用字面量值创建对象 12345// badconst a = new Object&#123;&#125;// goodconst a = &#123;&#125; 别使用保留字作为对象的键值，这样在 IE8 下不会运行 1234567891011// badconst a = &#123; default: &#123;&#125;, // default 是保留字 common: &#123;&#125;&#125;// goodconst a = &#123; defaults: &#123;&#125;, common: &#123;&#125;&#125; 请使用对象方法的简写方式 1234567891011121314151617// badconst item = &#123; value: 1, addValue: function (val) &#123; return item.value + val &#125;&#125;// goodconst item = &#123; value: 1, addValue(val) &#123; return item.value + val &#125;&#125; 请使用对象属性值的简写方式 1234567891011const job = 'FrontEnd'// badconst item = &#123; job: job&#125;// goodconst item = &#123; job&#125; 对象属性值的简写方式要和声明式的方式分组 123456789101112131415161718const job = 'FrontEnd'const department = 'JDC'// badconst item = &#123; sex: 'male', job, age: 25, department&#125;// goodconst item = &#123; job, department, sex: 'male', age: 25&#125; 数组 请使用字面量值创建数组 12345// badconst items = new Array()// goodconst items = [] 向数组中添加元素时，请使用 push 方法 1234567const items = []// baditems[items.length] = 'test'// gooditems.push('test') 使用拓展运算符 ... 复制数组 12345678910111213// badconst items = []const itemsCopy = []const len = items.lengthlet i// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i]&#125;// gooditemsCopy = [...items] 使用数组的 map 等方法时，请使用 return 声明，如果是单一声明语句的情况，可省略 return 12345678910111213141516171819202122232425262728293031323334353637383940414243// good[1, 2, 3].map(x =&gt; &#123; const y = x + 1 return x * y&#125;)// good[1, 2, 3].map(x =&gt; x + 1)// badconst flat = &#123;&#125;[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123; const flatten = memo.concat(item) flat[index] = flatten&#125;)// goodconst flat = &#123;&#125;[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; &#123; const flatten = memo.concat(item) flat[index] = flatten return flatten&#125;)// badinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg if (subject === 'Mockingbird') &#123; return author === 'Harper Lee' &#125; else &#123; return false &#125;&#125;)// goodinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg if (subject === 'Mockingbird') &#123; return author === 'Harper Lee' &#125; return false&#125;) 解构赋值 当需要使用对象的多个属性时，请使用解构赋值 12345678910111213141516171819// badfunction getFullName (user) &#123; const firstName = user.firstName const lastName = user.lastName return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125;// goodfunction getFullName (user) &#123; const &#123; firstName, lastName &#125; = user return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125;// betterfunction getFullName (&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`&#125; 当需要使用数组的多个值时，请同样使用解构赋值 12345678const arr = [1, 2, 3, 4]// badconst first = arr[0]const second = arr[1]// goodconst [first, second] = arr 函数需要回传多个值时，请使用对象的解构，而不是数组的解构 123456789101112131415// badfunction doSomething () &#123; return [top, right, bottom, left]&#125;// 如果是数组解构，那么在调用时就需要考虑数据的顺序const [top, xx, xxx, left] = doSomething()// goodfunction doSomething () &#123; return &#123; top, right, bottom, left &#125;&#125;// 此时不需要考虑数据的顺序const &#123; top, left &#125; = doSomething() 字符串 字符串统一使用单引号的形式 &#39;&#39; 12345// badconst department = "JDC"// goodconst department = 'JDC' 字符串太长的时候，请不要使用字符串连接符换行 \，而是使用 + 123const str = '凹凸实验室 凹凸实验室 凹凸实验室' + '凹凸实验室 凹凸实验室 凹凸实验室' + '凹凸实验室 凹凸实验室' 程序化生成字符串时，请使用模板字符串 12345678910const test = 'test'// badconst str = ['a', 'b', test].join()// badconst str = 'a' + 'b' + test// goodconst str = `ab$&#123;test&#125;` 函数 请使用函数声明，而不是函数表达式 123456789// badconst foo = function () &#123; // do something&#125;// goodfunction foo () &#123; // do something&#125; 不要在非函数代码块中声明函数 1234567891011121314// badif (isUse) &#123; function test () &#123; // do something &#125;&#125;// goodlet testif (isUse) &#123; test = () =&gt; &#123; // do something &#125;&#125; 不要使用 arguments，可以选择使用 ... arguments 只是一个类数组，而 ... 是一个真正的数组 12345678910// badfunction test () &#123; const args = Array.prototype.slice.call(arguments) return args.join('')&#125;// goodfunction test (...args) &#123; return args.join('')&#125; 不要更改函数参数的值 123456789// badfunction test (opts) &#123; opts = opts || &#123;&#125;&#125;// goodfunction test (opts = &#123;&#125;) &#123; // ...&#125; 原型 使用 class，避免直接操作 prototype 12345678910111213141516171819202122// badfunction Queue (contents = []) &#123; this._queue = [..contents]&#125;Queue.prototype.pop = function () &#123; const value = this._queue[0] this._queue.splice(0, 1) return value&#125;// goodclass Queue &#123; constructor (contents = []) &#123; this._queue = [...contents] &#125; pop () &#123; const value = this._queue[0] this._queue.splice(0, 1) return value &#125;&#125; 模块 使用标准的 ES6 模块语法 import 和 export 1234567891011// badconst util = require('./util')module.exports = util// goodimport Util from './util'export default Util// betterimport &#123; Util &#125; from './util'export default Util 不要使用 import 的通配符 *，这样可以确保你只有一个默认的 export 12345// badimport * as Util from './util'// goodimport Util from './util' 迭代器 不要使用 iterators 1234567891011121314const numbers = [1, 2, 3, 4, 5]// badlet sum = 0for (let num of numbers) &#123; sum += num&#125;// goodlet sum = 0numbers.forEach(num =&gt; sum += num)// betterconst sum = numbers.reduce((total, num) =&gt; total + num, 0) 对象属性 使用 . 来访问对象属性 12345678910const joke = &#123; name: 'haha', age: 28&#125;// badconst name = joke['name']// goodconst name = joke.name 变量声明 声明变量时，请使用 const、let 关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能会和现有变量冲突，另外，也很难明确该变量的作用域是什么。这里推荐使用 const 来声明变量，我们需要避免全局命名空间的污染。 12345// baddemo = new Demo()// goodconst demo = new Demo() 将所有的 const 和 let 分组 12345678910111213// badlet aconst blet cconst dlet e// goodconst bconst dlet alet clet e Hoisting var 存在变量提升的情况，即 var 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 const 和 let 并不存在这种情况，他们被赋予了 Temporal Dead Zones, TDZ 1234567891011121314151617181920function example () &#123; console.log(notDefined) // =&gt; throws a ReferenceError&#125;function example () &#123; console.log(declareButNotAssigned) // =&gt; undefined var declaredButNotAssigned = true&#125;function example () &#123; let declaredButNotAssigned console.log(declaredButNotAssigned) // =&gt; undefined declaredButNotAssigned = true&#125;function example () &#123; console.log(declaredButNotAssigned) // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned) // =&gt; throws a ReferenceError const declaredButNotAssigned = true&#125; 匿名函数的变量名会提升，但函数内容不会 123456789function example () &#123; console.log(anonymous) // =&gt; undefined anonymous() var anonymous = function () &#123; console.log('test') &#125;&#125; 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会 123456789101112131415161718192021function example() &#123; console.log(named) // =&gt; undefined named() // =&gt; TypeError named is not a function superPower() // =&gt; ReferenceError superPower is not defined var named = function superPower () &#123; console.log('Flying') &#125;&#125;function example() &#123; console.log(named) // =&gt; undefined named() // =&gt; TypeError named is not a function var named = function named () &#123; console.log('named') &#125;&#125; 分号 我们遵循 Standard 的规范，不使用分号。 关于应不应该使用分号的讨论有很多，本规范认为非必要的时候，应该不使用分号，好的 JS 程序员应该清楚场景下是一定要加分号的，相信你也是名好的开发者。 1234567891011// badconst test = 'good';(function () &#123; const str = 'hahaha';&#125;)()// goodconst test = 'good';(() =&gt; &#123; const str = 'hahaha'&#125;)(); 标准特性为了代码的可移植性和兼容性，我们应该最大化的使用标准方法，例如优先使用 string.charAt(3) 而不是 string[3] eval()由于 eval 方法比较 evil，所以我们约定禁止使用该方法 with() {}由于 with 方法会产生神奇的作用域，所以我们也是禁止使用该方法的 for-in 循环推荐使用 for in 语法，但是在对对象进行操作时，容易忘了检测 hasOwnProperty(key)，所以我们启用了 ESLint 的 guard-for-in 选项 对数组进行 for in 的时候，顺序是不固定的 修改内置对象的原型不要修改内置对象，如 Object 和 Array]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注释规范]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[遵循标准HTML注释规范写法应该遵循以下标准： Comments must start with the four character sequence U+003C LESS-THAN SIGN, U+0021 EXCLAMATION MARK, U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS (&lt;!–). Following this sequence, the comment may have text, with the additional restriction that the text must not start with a single “&gt;” (U+003E) character, nor start with a U+002D HYPHEN-MINUS character (-) followed by a “&gt;” (U+003E) character, nor contain two consecutive U+002D HYPHEN-MINUS characters (–), nor end with a U+002D HYPHEN-MINUS character (-). Finally, the comment must be ended by the three character sequence U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN (–&gt;). 必须以4个有序字符开始：编码为 U+003C LESS-THAN SIGN 的小于号, 编码为 U+0021 EXCLAMATION MARK 的感叹号, 编码为 U+002D HYPHEN-MINUS 横线, 编码为 U+002D HYPHEN-MINUS横线 ，即 “&lt;!–” 在此之后是注释内容，注释的内容有以下限制： 不能以单个 “&gt;” (U+003E) 字符开始 不能以由 “-“（U+002D HYPHEN-MINUS）和 ”&gt;” (U+003E) 组合的字符开始，即 “-&gt;” 不能包含两个连续的 U+002D HYPHEN-MINUS 字符，即 “–” 不能以一个 U+002D HYPHEN-MINUS 字符结束，即 “-” 必须以3个有序字符结束：U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN，即 “–&gt;” 标准写法： 1&lt;!--Comment Text--&gt; 错误的写法： 1234567&lt;!--&gt;The Wrong Comment Text--&gt;&lt;!---&gt;The Wrong Comment Text--&gt;&lt;!--The--Wrong--Comment Text--&gt;&lt;!--The Wrong Comment Text---&gt; 参考 www.w3.org #Comments 团队约定单行注释一般用于简单的描述，如某些状态描述、属性描述等 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行 推荐： 12&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt; 不推荐： 12345&lt;div&gt;...&lt;/div&gt;&lt;!-- Comment Text --&gt; &lt;div&gt;&lt;!-- Comment Text --&gt; ...&lt;/div&gt; 模块注释一般用于描述模块的名称以及模块开始与结束的位置 注释内容前后各一个空格字符，&lt;!-- S Comment Text --&gt; 表示模块开始，&lt;!-- E Comment Text --&gt; 表示模块结束，模块与模块之间相隔一行 推荐写法： 1234567891011&lt;!-- S Comment Text A --&gt; &lt;div class="mod_a"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text A --&gt; &lt;!-- S Comment Text B --&gt; &lt;div class="mod_b"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text B --&gt; 不推荐写法： 12345678910&lt;!-- S Comment Text A --&gt;&lt;div class="mod_a"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text A --&gt;&lt;!-- S Comment Text B --&gt; &lt;div class="mod_b"&gt; ...&lt;/div&gt;&lt;!-- E Comment Text B --&gt; 嵌套模块注释当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用 12&lt;!-- S Comment Text --&gt;&lt;!-- E Comment Text --&gt; 而改用 1&lt;!-- /Comment Text --&gt; 注释写在模块结尾标签底部，单独一行。 123456789101112131415&lt;!-- S Comment Text A --&gt;&lt;div class="mod_a"&gt; &lt;div class="mod_b"&gt; ... &lt;/div&gt; &lt;!-- /mod_b --&gt; &lt;div class="mod_c"&gt; ... &lt;/div&gt; &lt;!-- /mod_c --&gt; &lt;/div&gt;&lt;!-- E Comment Text A --&gt;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML规范]]></title>
    <url>%2F2019%2F05%2F27%2Fhtml%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[DOCTYPE 声明 一个DOCTYPE必须包含以下部分，并严格按照顺序出现： A string that is an ASCII case-insensitive match for the string “&lt;!DOCTYPE”. One or more space characters. A string that is an ASCII case-insensitive match for the string “html”. Optionally, a DOCTYPE legacy string or an obsolete permitted DOCTYPE string (defined below). Zero or more space characters. A “&gt;” (U+003E) character. 一个ASCII字符串 “&lt;!DOCTYPE” ，大小写不敏感 一个或多个空白字符 一个ASCII字符串”html”，大小写不敏感 一个可选的历史遗留的DOCTYPE字符串 （DOCTYPE legacy string），或者一个可选的已过时但被允许的DOCTYPE字符串 （obsolete permitted DOCTYPE string） 字符串 一个或多个空白字符 一个编码为 U+003E 的字符 “&gt;” 团队约定HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明： 1&lt;!DOCTYPE html&gt; 更多关于 DOCTYPE声明#The DOCTYPE 页面语言LANGLang属性的取值应该遵循互联网工程任务组–IETF（The Internet Engineering Task Force）制定的关于语言标签的文档 BCP 47 - Tags for Identifying Languages 团队约定推荐使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值1&lt;html lang="zh-CN"&gt; 更多地区语言参考： zh-SG 中文 (简体, 新加坡) 对应 cmn-Hans-SG 普通话 (简体, 新加坡) zh-HK 中文 (繁体, 香港) 对应 cmn-Hant-HK 普通话 (繁体, 香港) zh-MO 中文 (繁体, 澳门) 对应 cmn-Hant-MO 普通话 (繁体, 澳门) zh-TW 中文 (繁体, 台湾) 对应 cmn-Hant-TW 普通话 (繁体, 台湾) 已废弃不推荐使用的 Languages Tags以下写法已于 2009 年废弃，请勿使用（cmn、wuu、yue、gan 等已由 2005 年的 extlang 升级到 2009 年的 language）： zh-cmn, zh-cmn-Hans, zh-cmn-Hant, zh-wuu, zh-yue, zh-gan 以下写法已于 2009 年废弃，不推荐使用： zh-Hans, zh-Hans-CN, zh-Hans-SG, zh-Hans-HK, zh-Hans-MO, zh-Hans-TW, zh-Hant, zh-Hant-CN, zh-Hant-SG, zh-Hant-HK, zh-Hant-MO, zh-Hant-TW 更多已废弃 Languages Tags 参考 IANA Language Subtag Registry 里面的 “Type: redundant“” 更多关于 Languages Tags ：W3C Language tags in HTML and XML 网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？ CHARSET Because the character sets in ISO-8859 was limited in size, and not compatible in multilingual environments, the Unicode Consortium developed the Unicode Standard. The Unicode Standard covers (almost) all the characters, punctuations, and symbols in the world. Unicode enables processing, storage, and transport of text independent of platform and language. The default character encoding in HTML-5 is UTF-8. 因为 ISO-8859 中字符集大小是有限的，且在多语言环境中不兼容，所以 Unicode 联盟开发了 Unicode 标准。 Unicode 标准覆盖了（几乎）所有的字符、标点符号和符号。 Unicode 使文本的处理、存储和运输，独立于平台和语言。 HTML-5 中默认的字符编码是 UTF-8 参阅 HTML Unicode (UTF-8) Reference 团队约定一般情况下统一使用 “UTF-8” 编码1&lt;meta charset="UTF-8"&gt; 由于历史原因，有些业务可能会使用 “GBK” 编码 1&lt;meta charset="GBK"&gt; 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 IETF对UTF-8的定义，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。 更多关于UTF-8写法: UTF8 or UTF-8? GBK：Application of IANA Charset Registration for GBK Charset ：character-encoding-declaration 元素及标签闭合HTML元素共有以下5种： 空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr 原始文本元素：script、style RCDATA元素：textarea、title 外来元素：来自MathML命名空间和SVG命名空间的元素。 常规元素：其他HTML允许的元素都称为常规元素。 元素标签的闭合应遵循以下原则： Tags are used to delimit the start and end of elements in the markup. Raw text, escapable raw text, and normal elements have a start tag to indicate where they begin, and an end tag to indicate where they end. The start and end tags of certain normal elements can be omitted, as described below in the section on optional tags. Those that cannot be omitted must not be omitted. Void elements only have a start tag; end tags must not be specified for void elements. Foreign elements must either have a start tag and an end tag, or a start tag that is marked as self-closing, in which case they must not have an end tag. 原始文本元素、RCDATA元素以及常规元素都有一个开始标签来表示开始，一个结束标签来表示结束。 某些元素的开始和结束标签是可以省略的，如果规定标签不能被省略，那么就绝对不能省略它。 空元素只有一个开始标签，且不能为空元素设置结束标签。 外来元素可以有一个开始标签和配对的结束标签，或者只有一个自闭合的开始标签，且后者情况下该元素不能有结束标签。 团队约定为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定： 所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。 空元素标签都不加 “/” 字符 推荐： 123456&lt;div&gt; &lt;h1&gt;我是h1标题&lt;/h1&gt; &lt;p&gt;我是一段文字，我有始有终，浏览器能正确解析&lt;/p&gt;&lt;/div&gt; &lt;br&gt; 不推荐： 123456&lt;div&gt; &lt;h1&gt;我是h1标题&lt;/h1&gt; &lt;p&gt;我是一段文字，我有始无终，浏览器亦能正确解析&lt;/div&gt;&lt;br/&gt; 更多关于元素及标签关闭：#Elements 书写风格HTML代码大小写HTML标签名、类名、标签属性和大部分属性值统一用小写 推荐： 1&lt;div class="demo"&gt;&lt;/div&gt; 不推荐： 123&lt;div class="DEMO"&gt;&lt;/div&gt; &lt;DIV CLASS="DEMO"&gt;&lt;/DIV&gt; HTML文本、CDATA、JavaScript、meta标签某些属性等内容可大小写混合 12345678910111213141516&lt;!-- 优先使用 IE 最新版本和 Chrome Frame --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt;&lt;!-- HTML文本内容 --&gt;&lt;h1&gt;I AM WHAT I AM &lt;/h1&gt;&lt;!-- JavaScript 内容 --&gt;&lt;script type="text/javascript"&gt; var demoName = 'demoName'; ...&lt;/script&gt; &lt;!-- CDATA 内容 --&gt;&lt;script type="text/javascript"&gt;&lt;![CDATA[...]]&gt;&lt;/script&gt; 类型属性不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含 推荐： 12&lt;link rel="stylesheet" href="" &gt;&lt;script src=""&gt;&lt;/script&gt; 不推荐： 12&lt;link rel="stylesheet" type="text/css" href="" &gt;&lt;script type="text/javascript" src="" &gt;&lt;/script&gt; 元素属性 元素属性值使用双引号语法 元素属性值可以写上的都写上 推荐： 123&lt;input type="text"&gt; &lt;input type="radio" name="name" checked="checked" &gt; 不推荐： 1234&lt;input type=text&gt; &lt;input type='text'&gt; &lt;input type="radio" name="name" checked &gt; 更多关于元素属性：#Attributes 特殊字符引用 In certain cases described in other sections, text may be mixed with character references. These can be used to escape characters that couldn’t otherwise legally be included in text. 文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。 在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 推荐： 1&lt;a href="#"&gt;more&amp;gt;&amp;gt;&lt;/a&gt; 不推荐： 1&lt;a href="#"&gt;more&gt;&gt;&lt;/a&gt; 更多关于符号引用：#Character references 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 123&lt;div class="jdc"&gt; &lt;a href="#"&gt;&lt;/a&gt;&lt;/div&gt; 纯数字输入框使用 type=&quot;tel&quot; 而不是 type=&quot;number&quot; 1&lt;input type="tel"&gt; 代码嵌套元素嵌套规范，每个块状元素独立一行，内联元素可选 推荐： 12345&lt;div&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 不推荐： 1234567&lt;div&gt; &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/p&gt; 段落元素与标题元素只能嵌套内联元素 推荐： 12&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 不推荐： 12&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>rules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO的使用]]></title>
    <url>%2F2019%2F05%2F26%2FHEXO%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1234$ hexo deployhexo clean hexo g hexo d More info: Deployment 编辑要求必须包含title、date、categories、tags]]></content>
      <categories>
        <category>使用说明</category>
      </categories>
      <tags>
        <tag>user</tag>
      </tags>
  </entry>
</search>
